var documenterSearchIndex = {"docs":
[{"location":"HowTo/multiple_events/#multievent","page":"Multiple events","title":"How to model multiple events","text":"When dealing with overlapping data, it is often necessary to model multiple eventtypes (e.g. fixations, stimuli, responses).","category":"section"},{"location":"HowTo/multiple_events/#Load-Example-Data","page":"Multiple events","title":"Load Example Data","text":"using Unfold\nusing UnfoldMakie, CairoMakie\nusing DataFrames\nusing StatsModels\nusing MixedModels\nusing DisplayAs # hide\n\ninclude(joinpath(dirname(pathof(Unfold)), \"../test/test_utilities.jl\")) # to load data\ndat, evts = loadtestdata(\"test_case_4b\");\n\nevts[1:5,:]\n\nThe type column of table evts contains two conditions: eventAandeventB(if your eventstypes are specified in a different column, you need to define the keywordargumenteventcolumnin thefit` command below)","category":"section"},{"location":"HowTo/multiple_events/#Specify-formulas-and-basisfunctions","page":"Multiple events","title":"Specify formulas and basisfunctions","text":"\nbf1 = firbasis(Ï„ = (-0.4, 0.8), sfreq = 50)\nbf2 = firbasis(Ï„ = (-0.2, 1.2), sfreq = 50)\nbf2|> DisplayAs.withcontext(:is_pluto=>true) # hide\n\nFor each event, a basis function and formula must be specified. The same basis and formulas may be used.\n\nf  = @formula 0 ~ 1\n\nFor each event, we must specify the formula and basis function to be used.\n\n\nbfDict = [ \"eventA\" => (f, bf1),\n           \"eventB\" => (f, bf2) ]\n\nbfDict |> DisplayAs.withcontext(:is_pluto=>true) # hide\n\nFinally, fitting & plotting works the same way as always\n\nm = Unfold.fit(\n    UnfoldModel,\n    bfDict,\n    evts,\n    dat,\n    solver = (x, y) -> Unfold.solver_default(x, y; stderror = true),\n    eventcolumn = \"type\",\n)\nresults = coeftable(m)\nplot_erp(results; stderror = true, mapping = (; col = :eventname))","category":"section"},{"location":"generated/HowTo/FIRduration/#hassall-duration","page":"Duration-scaled basisfunctions (Hassall-style)","title":"FIR-Scaled duration predictors","text":"using Unfold\nusing Interpolations\n\nusing UnfoldSim\nusing UnfoldMakie, CairoMakie\nusing DataFrames\nusing DisplayAs # hide\n\ndata, evts = UnfoldSim.predef_eeg(sfreq = 10, n_repeats = 1)\n\nevts.duration = 5:24\n\nputting scale_duration = Interpolation.Linear() will introduce a Cameron-Hassall 2022 PNAS- Style basisfunction, that scales with the :duration column\n\nbasisfunction = firbasis(Ï„ = (-1, 2), sfreq = 5, scale_duration = Interpolations.Linear())\n\nTwo examples with duration = 10\n\nUnfold.kernel(basisfunction, [0, 10])\n\nand duration = 20\n\nUnfold.kernel(basisfunction, [0, 20])\n\nlet's fit a model\n\nf = @formula 0 ~ 1 + condition\nbf_vec = [Any => (f, basisfunction)]\nm = fit(UnfoldModel, bf_vec, evts, data; eventfields = [:latency, :duration]);\n\n\n# currently bugged for small matrices\n# plot_designmatrix(designmatrix(m))\n# thus using\nheatmap(Matrix(modelmatrix(m))')\n\nAs one can see, the designmatrix is nicely scaled\n\nWe can predict overlap-corrected results\n\np = predict(m; overlap = false)[1]\nheatmap(p[1, :, :])\n\nnote the missings which are displayed as white pixels.","category":"section"},{"location":"generated/HowTo/FIRduration/#Block-design-predictors","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Block-design predictors","text":"In contrast, it is also possible to put scale_duration = true - which wil not scale the matrix as before, but introduce a step-function.\n\nputting scale_duration = Interpolation.Linear() will introduce a Cameron-Hassall 2022 PNAS- Style basisfunction, that scales with the :duration column\n\nbasisfunction = firbasis(Ï„ = (-1, 2), sfreq = 5, scale_duration = true)\n\nTwo examples with duration = 10\n\nUnfold.kernel(basisfunction, [0, 10])\n\nand duration = 20\n\nUnfold.kernel(basisfunction, [0, 20])\n\nlet's fit a model\n\nf = @formula 0 ~ 1 + condition\nbf_vec = [Any => (f, basisfunction)]\nm = fit(UnfoldModel, bf_vec, evts, data; eventfields = [:latency, :duration]);\n\n\nheatmap(Matrix(modelmatrix(m))')\n\nas one can see, now the designmatrix is not stretched - but rather \"block\"-ed\n\np = predict(m; overlap = false)[1]\nheatmap(p[1, :, :])\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"91-developer/#dev_docs","page":"Developer documentation","title":"Developer documentation","text":"note: Contributing guidelines\nIf you haven't, please read the Contributing guidelines first.\n\nIf you want to make contributions to this package that involves code, then this guide is for you.","category":"section"},{"location":"91-developer/#First-time-clone","page":"Developer documentation","title":"First time clone","text":"tip: If you have writing rights\nIf you have writing rights, you don't have to fork. Instead, simply clone and skip ahead. Whenever upstream is mentioned, use origin instead.\n\nIf this is the first time you work with this repository, follow the instructions below to clone the repository.\n\nFork this repo\nClone your repo (this will create a git remote called origin)\nAdd this repo as a remote:\ngit remote add upstream https://github.com/unfoldtoolbox/Unfold.jl\n\nThis will ensure that you have two remotes in your git: origin and upstream. You will create branches and push to origin, and you will fetch and update your local main branch from upstream.","category":"section"},{"location":"91-developer/#Linting-and-formatting","page":"Developer documentation","title":"Linting and formatting","text":"Install a plugin on your editor to use EditorConfig. This will ensure that your editor is configured with important formatting settings.\n\nWe use https://pre-commit.com to run the linters and formatters. In particular, the Julia code is formatted using JuliaFormatter.jl, so please install it globally first:\n\njulia> # Press ]\npkg> activate\npkg> add JuliaFormatter\n\nTo install pre-commit, we recommend using pipx as follows:\n\n# Install pipx following the link\npipx install pre-commit\n\nWith pre-commit installed, activate it as a pre-commit hook:\n\npre-commit install\n\nTo run the linting and formatting manually, enter the command below:\n\npre-commit run -a\n\nNow, you can only commit if all the pre-commit tests pass.","category":"section"},{"location":"91-developer/#Testing","page":"Developer documentation","title":"Testing","text":"As with most Julia packages, you can just open Julia in the repository folder, activate the environment, and run test:\n\njulia> # press ]\npkg> activate .\npkg> test","category":"section"},{"location":"91-developer/#Working-on-a-new-issue","page":"Developer documentation","title":"Working on a new issue","text":"We try to keep a linear history in this repo, so it is important to keep your branches up-to-date.\n\nFetch from the remote and fast-forward your local main\ngit fetch upstream\ngit switch main\ngit merge --ff-only upstream/main\nBranch from main to address the issue (see below for naming)\ngit switch -c 42-add-answer-universe\nPush the new local branch to your personal remote repository\ngit push -u origin 42-add-answer-universe\nCreate a pull request to merge your remote branch into the org main.","category":"section"},{"location":"91-developer/#Branch-naming","page":"Developer documentation","title":"Branch naming","text":"If there is an associated issue, add the issue number.\nIf there is no associated issue, and the changes are small, add a prefix such as \"typo\", \"hotfix\", \"small-refactor\", according to the type of update.\nIf the changes are not small and there is no associated issue, then create the issue first, so we can properly discuss the changes.\nUse dash separated imperative wording related to the issue (e.g., 14-add-tests, 15-fix-model, 16-remove-obsolete-files).","category":"section"},{"location":"91-developer/#Commit-message","page":"Developer documentation","title":"Commit message","text":"Use imperative or present tense, for instance: Add feature or Fix bug.\nHave informative titles.\nWhen necessary, add a body with details.\nIf there are breaking changes, add the information to the commit message.","category":"section"},{"location":"91-developer/#Before-creating-a-pull-request","page":"Developer documentation","title":"Before creating a pull request","text":"Make sure the tests pass.\nMake sure the pre-commit tests pass.\nFetch any main updates from upstream and rebase your branch, if necessary:\ngit fetch upstream\ngit rebase upstream/main BRANCH_NAME\nThen you can open a pull request and work with the reviewer to address any issues.","category":"section"},{"location":"91-developer/#Building-and-viewing-the-documentation-locally","page":"Developer documentation","title":"Building and viewing the documentation locally","text":"Following the latest suggestions, we recommend using LiveServer to build the documentation. Here is how you do it:\n\nRun julia --project=docs to open Julia in the environment of the docs.\nIf this is the first time building the docs\nPress ] to enter pkg mode\nRun pkg> dev . to use the development version of your package\nPress backspace to leave pkg mode\nRun julia> using LiveServer\nRun julia> servedocs()","category":"section"},{"location":"HowTo/R/#Calling-Unfold.jl-from-R","page":"R: Calling Unfold.jl directly from R","title":"Calling Unfold.jl from R","text":"Julia code can be called from within R using JuliaCall. Here is a barebone  tutorial how to do so. If you ever run into issues, please write us an github issue - we have not extensively used this bridge in the past.","category":"section"},{"location":"HowTo/R/#Install-JuliaCall","page":"R: Calling Unfold.jl directly from R","title":"Install JuliaCall","text":"install.packages(\"JuliaCall\")\nlibrary(\"JuliaCall\")\ninstall_julia() # installs Julia\n\nOnce JuliaCall and Julia are installed, we can start installing Unfold and calling the library.\n\nTwo ways to do so: The \"proper\" way, with a reproducible environment:\n\nlibrary(\"JuliaCall\")\n\njulia <- julia_setup() # setup julia\npath_to_env = '/tmp/my_julia_env' # could be any path to a Julia Project.toml\njulia_eval(paste('import Pkg;','Pkg.activate(\"',path_to_env,'\");Pkg.instantiate()'))\n\n# if Unfold is not yet installed\njulia_eval('Pkg.add(\"Unfold\");')\n\n\nThe fast way:\n\njulia_install_package_if_needed(\"Unfold\")\n\nWe are now ready to create some fake data (which you'd replace with your own of course), and call Unfold.jl. We will only provide an example for an epoched, mass-univariate analysis.\n\n\nR_data <- matrix(rnorm(200), nrow = 10, ncol = 20) # 10 timepoints, 20 trials\nR_df <- data.frame(trial=1:20)\njulia_assign(\"jl_data\",R_data) # move data to julia\njulia_assign(\"jl_df\",R_df) # move DF to julia\n\njulia_library(\"Unfold\") # load Unfold - takes 2-3s\n\njulia_eval(\"m = fit(UnfoldModel,[Any=>(@formula(0~1+trial),1:10)],jl_df,jl_data)\") # first time slow, next time fast!\n\neff = julia_eval(\"effects(Dict(:trial=>[1,5,10]),m)\") # calculate marginal means and return DataFrame\n\n\nWonderful - you now have a tidy DataFrame in R, with the marginal effect of your unfold model evaluated at trial = 1,5,10.\n\nNote that the Julia's formula syntax is similar, but not identical to R's formulas. ``","category":"section"},{"location":"HowTo/pymne/#Loading-Data-into-Unfold","page":"ðŸ Import EEG with PyMNE.jl","title":"Loading Data into Unfold","text":"Unfold is generally agnostic to how you load your data. You only require a Matrix (channel x time) or 3D-Array(channel x time x epochs) and an event-dataframe.","category":"section"},{"location":"HowTo/pymne/#Setup","page":"ðŸ Import EEG with PyMNE.jl","title":"Setup","text":"using Unfold\nusing UnfoldMakie,CairoMakie\n\nusing DataFrames","category":"section"},{"location":"HowTo/pymne/#MNE-Demo-Dataset","page":"ðŸ Import EEG with PyMNE.jl","title":"MNE Demo Dataset","text":"The easiest way to showcase this is to simply use a demo-dataset from MNE.\n\nTo extract the metadata, we need Pandas which is not installed by default, we therefore need to install it via CondaPkg\n\nusing CondaPkg\nCondaPkg.add(\"pandas\")\nCondaPkg.add(\"mne\") # due to a bug in PyMNE https://github.com/beacon-biosignals/PyMNE.jl/issues/38 - we have to add mne additionally\nusing PyMNE\n\nNow we are ready to load some data.\n\nlimo_epochs = PyMNE.datasets.limo.load_data(subject=1,path=\"~/MNE/DATA\",update_path=false)\nlimo_epochs\n\nAfter loading, we can fit an Unfold model to it.\n\nFirst extract the data & convert it to Julia/Unfold requirements\n\ndata = pyconvert(Array,limo_epochs.get_data(picks=\"B11\"))\ndata  = permutedims(data,[2,3,1]) # permute to ch x times x epochs Array format\n\nevents = DataFrame(PyTable(limo_epochs.metadata))\nrename!(events,2 => :coherence)\nevents.face = string.(events.face)\n\ntimes = pyconvert(Vector,limo_epochs.times)\n\nNext fit an Unfold Model:\n\nuf = fit(UnfoldModel,[Any=>(@formula(0~face+coherence),times)],events,data)\nresults = coeftable(uf)\n\nplot_results(results)","category":"section"},{"location":"HowTo/pymne/#Read-some-of-your-own-data","page":"ðŸ Import EEG with PyMNE.jl","title":"Read some of your own data","text":"We can make use of all PyMNE importer functions to load the data. Try it for your own data! Get starting with Unfold in no-time!\n\n#eeglabdata = PyMNE.io.read_raw_eeglab(\"pathToEEGLabSet.set\")","category":"section"},{"location":"HowTo/pymne/#Contribute?","page":"ðŸ Import EEG with PyMNE.jl","title":"Contribute?","text":"Some extra conversions are needed to import the data from PyMNE to Unfold (as shown above). We could try putting these in a wrapper function - do you want to tackle this challenge? Would be a great first contribution to the toolbox :-)","category":"section"},{"location":"generated/HowTo/juliacall_unfold/#Using-Unfold.jl-from-Python","page":"ðŸ Calling Unfold.jl directly from Python","title":"Using Unfold.jl from Python","text":"it is straight forward to call Unfold from Python using JuliaCall.","category":"section"},{"location":"generated/HowTo/juliacall_unfold/#Quick-start","page":"ðŸ Calling Unfold.jl directly from Python","title":"Quick start","text":"Create a Python environment and install JuliaCall.\n\npip install juliacall\n\nCreate a Julia environment and install Unfold\n\n# Import the Julia package manager\nfrom juliacall import Pkg as jlPkg\n\n# Activate the environment in the current folder\njlPkg.activate(\".\")\n\n# Install Unfold (in the activated environment)\njlPkg.add(\"Unfold\")\n\nImport Julia's main module and Unfold\n\n# Import Julia's Main module\nfrom juliacall import Main as jl\n\n# Import Unfold\n# The function seval() can be used to evaluate a piece of Julia code given as a string\njl.seval(\"using Unfold\")\nUnfold = jl.Unfold # simplify name\n\nNow you can use all Unfold functions as for example\n\ndummy_model = Unfold.UnfoldLinearModel(jl.Dict())","category":"section"},{"location":"generated/HowTo/juliacall_unfold/#Example:-Unfold-model-fitting-from-Python","page":"ðŸ Calling Unfold.jl directly from Python","title":"Example: Unfold model fitting from Python","text":"In this notebook, you can find a more detailed example of how to use Unfold from Python to load data, fit an Unfold model and visualise the results in Python.","category":"section"},{"location":"generated/HowTo/juliacall_unfold/#Important-limitations","page":"ðŸ Calling Unfold.jl directly from Python","title":"Important limitations","text":"Python doesnt not offer the full expressions that are available in Julia. So there are some things you need to give special attention:\n\n@formula: we havent found a way to call macros yet, even though we think it should be possible. For now please use f = jl.seval(\"@formula(0~1+my+cool+design)\"). Later versions might support something like f = @formula(\"0~1+my+cool+design)\" directly\n\nSpecifying the design: Since Unfold 0.7 we officially switched to the\n\n[\"eventtypeA\"=>(formula,basisfunction),\n\"eventtypeB\"=>(otherformula,otherbasisfunction)]\n\nArray-based syntax, from a Dict-based syntax. Unfortunately, => (a pair) is not supported in Python and one needs to do some rewriting:\n\njl.convert(jl.Pair,(formula,basisfunction))\n\nwhich makes the code less readable. We are thinking of ways to remedy this - but right now there is now way around. For now, it is also possible to use the old syntax e.g. in python\n\n{\"eventtypeA\"=>(formula,basisfunction),\"eventtypeB\"=>(otherformula,otherbasisfunction)}\n\nwhich is clearly easier to read :)\n\nUnfoldSim.design: we need a Dict with a Symbol , one has to do something like condition_dict_jl = {convert(jl.Symbol,\"condA\"):[\"car\", \"face\"]} to do so. We will [try to allow strings}(https://github.com/unfoldtoolbox/UnfoldSim.jl/issues/96) here as well, removing this constraint.\n\nWhen preprocessing your raw data through MNE Python, take the following into consideration: The Raw object contains the first_samp attribute which is an integer representing the number of time samples that passed between the onset of the hardware acquisition system and the time when data recording started. The Raw data doesn't include these time samples, meaning that the first sample is the beginning of the data aquisition. From the Raw object you can obtain an events array from the annotations through mne.eventsfromannotations(). The events array, however, does include firstsamp, meaning that the annotated events in events array don't match the Raw object anymore. Alternatively, it might be easier to convert the annotations to a pandas dataframe directly (`todataframe()`), or even better, load the \"*events.tsv\" from a BIDS dataset. In the latter case, all columns will be preserved, which MNE's read_annotation drops.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"references/functions/#Effects.effects-Union{Tuple{T}, Tuple{AbstractDict, T}} where T<:UnfoldModel","page":"API: Functions","title":"Effects.effects","text":"effects(design::AbstractDict, model::UnfoldModel; typical = mean)\n\nCalculates marginal effects for all term combinations in design.\n\nImplementation based on Effects.jl package; likely could repackage in UnfoldEffects.jl; somebody wants to do it? This would make it easier to cross-maintain it to changes/bug fixes in the Effects.jl package. design is a dictionary containing those predictors (as keys) with levels (as values), that you want to evaluate. The typical refers to the value, which other predictors that are not specified in the dictionary, should take on.\n\nFor MixedModels, the returned effects are based on the \"typical\" subject, i.e. all random effects are put to 0.\n\nExample\n\n julia> f = @formula 0 ~ categoricalA + continuousA + continuousB\n julia> uf = fit(UnfoldModel, (Any => (f, times)), data, events)\n julia> d = Dict(:categorical => [\"levelA\", \"levelB\"], :continuous => [-2, 0, 2])\n julia> effects(d, uf)\n\nwill result in 6 predicted values: A/-2, A/0, A/2, B/-2, B/0, B/2.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#FileIO.load-Tuple{Any, Type{<:UnfoldModel}}","page":"API: Functions","title":"FileIO.load","text":"FileIO.load(file, ::Type{<:UnfoldModel}; generate_Xs=true)\n\nLoad UnfoldModel from a .jld2 file.\n\nBy default, the designmatrix is reconstructed. If it is not needed set generate_Xs=false which improves time-efficiency.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#FileIO.save-Union{Tuple{T}, Tuple{Any, T}} where T<:UnfoldModel","page":"API: Functions","title":"FileIO.save","text":"FileIO.save(file, uf::T; compress=false) where {T<:UnfoldModel}\n\nSave UnfoldModel in a (by default uncompressed) .jld2 file.\n\nFor memory efficiency the designmatrix is set to missing. If needed, it can be reconstructed when loading the model.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.coefnames-Tuple{Unfold.TimeExpandedTerm}","page":"API: Functions","title":"StatsAPI.coefnames","text":"coefnames(term)\n\n\ncoefnames of a TimeExpandedTerm concatenates the basis-function name with the kronecker product of the term name and the basis-function colnames. Separator is ' : ' Some examples for a firbasis:         basis313 : (Intercept) : 0.1         basis313 : (Intercept) : 0.2         basis_313 : (Intercept) : 0.3         ...\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.fit-Union{Tuple{T}, Tuple{Type{T}, StatsModels.FormulaTerm, DataFrames.AbstractDataFrame, AbstractArray, Union{Unfold.BasisFunction, AbstractArray}}} where T<:UnfoldModel","page":"API: Functions","title":"StatsAPI.fit","text":"fit(type::UnfoldModel,d::Vector{Pair},tbl::AbstractDataFrame,data::Array)\nfit(type::UnfoldModel,f::FormulaTerm,tbl::AbstractDataFrame,data::Array{T,3},times)\nfit(type::UnfoldModel,f::FormulaTerm,tbl::AbstractDataFrame,data::Array{T,2},basisfunction::BasisFunction)\n\nGenerates Designmatrix & fits model, either mass-univariate (one model per epoched-timepoint) or time-expanded (modeling linear overlap).\n\nkeyword arguments\n\nfit::Bool (default: true) - fit the model after constructing the designmatrix. Setting this to false is sometimes helpful if you only want to inspect the designmatrix.\ncontrasts::Dict: (default: Dict()) contrast to be applied to formula. Example: Dict(:my_condition=>EffectsCoding()). More information here: https://juliastats.org/StatsModels.jl/stable/contrasts/\neventcolumn::Union{Symbol,String} (default :event) - the column in tbl to differentiate the basisfunctions as defined in d::Vector{Pair}\nsolver::function: (default: solver_default). The solver used for y=Xb, e.g. (X,y;kwargs...) -> solver_default(X,y;kwargs...). There are faster & alternative solvers available, see solver_predefined for a list of options, see solver benchmark in the online documentation. To use the GPU, you can provide the data as a CuArray after using CUDA. Please change the solver to e.g. solver_predef(X,y;solver=:qr) as lsmr+cuda => crash typically. It's worth though, speed increases >100x possible\nshow_progress::Bool (default true) - show progress via ProgressMeter - passed to solver\neventfields::Array: (optional, default[:latency]) Array of symbols, representing column names intbl`, which are passed to basisfunction event-wise. First field of array always defines eventonset in samples.\nshow_warnings::Bool (default true) - show some additional warnings; setting to false does deactivate some warnings but not all (use e.g. Suppressor.jl for this)\n\nIf a Vector[Pairs] is provided, it has to have one of the following structures: For deconvolution analyses (use Any=>(f,bf) to match all rows of tbl in one basis functions). Assumes data is a continuous EEG stream, either a Vector or a ch x time Matrix\n\nf1 = @formula(0~1+my_condition)\n[\n :A=>(f1,firbasis((-0.1,1),128), # sfreq = 128Hz\n :B=>(f2,firbasis((-3,2),128)\n]\n\nfor mass-univariate analyses without deconvolution. Assumes data to be cut into epochs already (see Unfold.epoch). Follows eeglab standard ch x time x trials:\n\ntimesvector = range(-0.1,3,step=1/100)\n[\n :A=>(f1,timesvector),\n :B=>(f2,timesvector)\n]\n\nNotes\n\nThe type can be specified directly as well e.g. fit(type::UnfoldLinearModel) instead of relying on the automatic inference\nThe data is reshaped if it is missing one dimension to have the first dimension then 1 \"Channel\".\n\nExamples\n\nMass Univariate Linear\n\njulia> data,evts = UnfoldSim.predef_eeg()\njulia> data_e,times = Unfold.epoch(data=data,tbl=evts,Ï„=(-1.,1.9),sfreq=100) # cut the data into epochs. data_e is now ch x times x epoch\n\njulia> f  = @formula 0~1+continuousA+continuousB\njulia> model = fit(UnfoldModel,f,evts,data_e,times)\n# or:\njulia> model = fit(UnfoldModel,[Any=>(f,times)],evts,data_e)\n\nTimexpanded Univariate Linear\n\njulia> basisfunction = firbasis(Ï„=(-1,1),sfreq=10)\njulia> model = fit(UnfoldModel,f,evts,data,basisfunction)\n# or\njulia> model = fit(UnfoldModel,[Any=>(f,basisfunction],evts,data)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.modelmatrix","page":"API: Functions","title":"StatsAPI.modelmatrix","text":"StatsModels.modelmatrix(uf::UnfoldLinearModelContinuousTime, basisfunction = true)\n\nSetting the optional second args to false, will return the modelmatrix without the timeexpansion / basisfunction applied.\n\n\n\n\n\n","category":"function"},{"location":"references/functions/#StatsAPI.modelmatrix-Tuple{UnfoldLinearModel, Any}","page":"API: Functions","title":"StatsAPI.modelmatrix","text":"modelmatrix(uf::UnfoldLinearModel)\n\nreturns the modelmatrix of the model. Concatenates them, except in the MassUnivariate cases, where a vector of modelmatrices is return\n\nCompare with modelmatrices which returns a vector of modelmatrices, one per event\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.predict-Tuple{Any, Vector{<:StatsModels.FormulaTerm}, Vector{<:DataFrames.DataFrame}}","page":"API: Functions","title":"StatsAPI.predict","text":"function predict(\n    uf::UnfoldModel,\n    f::Vector{<:FormulaTerm},\n    evts::Vector{<:DataFrame};\n    overlap::Bool = true,\n    kwargs...\n)\n\nReturns a predicted (\"y_hat = X*b\") Array.\n\nuf is an <:UnfoldModel\nf is a (vector of) formulas, typically Unfold.formulas(uf), but formulas can be modified e.g. by effects.\nevts is a (vector of) events, can be Unfold.events(uf) to return the (possibly continuous-time) predictions of the model. Can be a custom even\n\nkwargs:\n\nif overlap = true (default), overlap based on the latency column of evts will be simulated, or in the case of !ContinuousTimeTrait just X*coef is returned.\n\nif overlap = false, returns predictions without overlap (models with ContinuousTimeTrait (=> with basisfunction / deconvolution) only), via predict_no_overlap\n\nif keep_basis or exclude_basis is defined, then predict_partial_overlap is called, which allows to selective introduce overlap based on specified (or excluded respective) events/basisfunctions\n\nepoch_to and  epoch_timewindow: calculate (partial) overlap controlled predictions, but returns them at the specified epoch_at event, with the times epoch_timewindow (default is taken from the basisfunction) in samples.\n\neventcolumn can be specified as well if different from the default event.\n\nHint: all kwargs can be Vector, or if e.g. string types are provided, will be put into a length==1 vector.\n\nOutput\n\nIf overlap=false, returns a 3D-Array\nIf overlap=true and epoch_to = nothing (default), returns a 2D-array\nIf overlap=true and epoch_to != nothing, returns a 3D array\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.r2-Tuple{UnfoldModel, AbstractArray}","page":"API: Functions","title":"StatsAPI.r2","text":"r2(model<:UnfoldModel)\n\nreturns the coeficient of determination\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsModels.modelcols-Tuple{Unfold.TimeExpandedTerm, Any}","page":"API: Functions","title":"StatsModels.modelcols","text":"modelcols(term, tbl)\n\n\ncalculates the actual designmatrix for a timeexpandedterm. Multiple dispatch on StatsModels.modelcols\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold._modelcols-Tuple{StatsModels.FormulaTerm, Any}","page":"API: Functions","title":"Unfold._modelcols","text":"_modelcols(form::FormulaTerm, events)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold._modelcols-Tuple{Vector, Vector}","page":"API: Functions","title":"Unfold._modelcols","text":"_modelcols(forms::Vector,events::Vector)\n\nA wrapper around StatsModels.modelcols that is only needed for easy multiple dispatch\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.apply_basisfunction-Tuple{Any, Unfold.BasisFunction, Any, Any}","page":"API: Functions","title":"Unfold.apply_basisfunction","text":"apply_basisfunction(\n    form,\n    basisfunction,\n    eventfields,\n    eventname\n)\n\n\ntimeexpand the rhs-term of the formula with the basisfunction\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.calc_epoch_timewindow-Tuple{Any, Any}","page":"API: Functions","title":"Unfold.calc_epoch_timewindow","text":"returns an integer range with the samples around epoch_event as defined in the corresponding basisfunction\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.combine_yhat!-Union{Tuple{T}, Tuple{Vector{<:Array{T}}, Array{T}}} where T","page":"API: Functions","title":"Unfold.combine_yhat!","text":"combine_yhat(list,single)\n\ncombines single into list, if either list or single contains missing, automatically casts the respective counter-part to allow missings as well\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.copy_eventinfo-Tuple{Any, Vararg{Any}}","page":"API: Functions","title":"Unfold.copy_eventinfo","text":"copy field-info from source to closest target\n\nArguments\n\nevts::DataFrame\nfrom_to::Pair specifies from which entry to which entry to copy, e.g. \"source\"=>\"target\"\nfield::String name of the column that contains the data to be copied to other events. Can be a pair in order to copy to a new column and thereby not replace any entries\n\nKeyword arguments\n\nsearch_fun::Symbol/Function can be :closest (default), :forward or :backwardor a custom function following the interfacesearchfun(sourcelatency::Float64,target_latencies::Vector)` returning a single integer index\ncolumn::String (default \"event\") the column where the from_to source and target events can be found in\n\nExample\n\nCopy reaction time values from button press to closest stimulus immediately before button press julia> copyeventinfo!(evts,\"button\"=>\"stimulus\",\"reactiontime\";search_fun=\"s after t\")\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.design_to_modeltype-Tuple{Any, Unfold.BasisFunction}","page":"API: Functions","title":"Unfold.design_to_modeltype","text":"!!! Important:    this is an ugly hack dating back to the time where UnfoldMixedModels was still an extension. We are overloading this function in UnfoldMixedModels.jl with a more specific type, to switch between MixedModels-Unfold types and not...\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.designmatrix-Tuple{Any, Any, Any}","page":"API: Functions","title":"Unfold.designmatrix","text":"designmatrix(type, f, tbl; kwargs...)\n\ncall without basis function, continue with basisfunction = nothing\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.designmatrix-Tuple{Type{<:UnfoldModel}, Union{Tuple, StatsModels.FormulaTerm}, Any, Any}","page":"API: Functions","title":"Unfold.designmatrix","text":"designmatrix(\n    unfoldmodeltype,\n    f,\n    tbl,\n    basisfunction;\n    contrasts,\n    eventname,\n    show_warnings,\n    kwargs...\n)\n\n\ndesignmatrix(type, f, tbl; kwargs...) Return a DesignMatrix used to fit the models.\n\nArguments\n\ntype::UnfoldModel\nf::FormulaTerm: Formula to be used in this designmatrix\ntbl: Events (usually a data frame) to be modelled\nbasisfunction::BasisFunction: basisfunction to be used in modeling (if specified)\ncontrasts::Dict: (optional) contrast to be applied to formula\neventfields::Array: (optional) Array of symbols which are passed to basisfunction event-wise.\n\nFirst field of array always defines eventonset in samples. Default is [:latency]\n\nExamples\n\njulia>  designmatrix(UnfoldLinearModelContinuousTime,Dict(Any=>(f,basisfunction1),tbl)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.designmatrix-Tuple{Type{<:UnfoldModel}, Vector{<:Pair}, Any}","page":"API: Functions","title":"Unfold.designmatrix","text":"designmatrix(\n    T::Type{<:UnfoldModel},\n    design_array::Vector{<:Pair},\n    tbl;\n    eventcolumn = :event,\n    contrasts = Dict{Symbol,Any}(),\n    kwargs...,\n\niteratively calls designmatrix for each event in the design_array, and returns a list of <:AbstractDesignMatrix\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.designmatrix-Tuple{UnfoldModel, Any}","page":"API: Functions","title":"Unfold.designmatrix","text":"designmatrix(\n    uf::UnfoldModel,\n    tbl;\n    eventcolumn = :event,\n    contrasts = Dict{Symbol,Any}(),\n    kwargs...,\n\nMain function called from fit(UnfoldModel...), generates the designmatrix, returns a list of <:AbstractDesignMatrix\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.drop_missing_epochs-Union{Tuple{T}, Tuple{Any, AbstractArray{T, 3}}} where T","page":"API: Functions","title":"Unfold.drop_missing_epochs","text":"[X,y] = drop_missing_epochs(X, y::Array)\n\nHelper function to remove epochs of y that contain missings. Drops them from both X and  y. Often used in combination with Unfold.epoch\n\nX can be anything that has two dimensions (Matrix, DataFrame etc)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.empty_modelmatrix-Tuple{AbstractDesignMatrix}","page":"API: Functions","title":"Unfold.empty_modelmatrix","text":"empty_modelmatrix(d::AbstractDesignMatrix)\n\nreturns an empty modelmatrix of the type DesignMatrix type of d\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.epoch-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Any}} where T<:Union{Missing, Number}","page":"API: Functions","title":"Unfold.epoch","text":"epoch(data::Array{T,1},evts::DataFrame,Ï„::Tuple/Vector,sfreq;kwargs...,\n\nBasic function to epoch data; all input also available as kwargs.\n\nAdditional kwarg: eventtime=:latency, which defines the column in evts that is used to cut the data (in samples). For uneven sample-times we use round()`\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.equalize_size-Union{Tuple{T}, Tuple{AbstractMatrix, AbstractVecOrMat{T}}} where T<:(Union{Missing, var\"#s147\"} where var\"#s147\"<:Number)","page":"API: Functions","title":"Unfold.equalize_size","text":"equalize_size(X, data)\n\n\nEquates the length of data and designmatrix by cutting the shorter one\n\nThe reason we need this is because when generating the designmatrix, we do not know how long the data actually are. We only assume that event-latencies are synchronized with the data\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.firbasis","page":"API: Functions","title":"Unfold.firbasis","text":"firbasis(Ï„, sfreq; ...)\nfirbasis(Ï„, sfreq, name; interpolate, scale_duration)\n\n\nGenerate a sparse FIR basis around the Ï„ timevector at sampling rate sfreq. This is useful if you cannot make any assumptions on the shape of the event responses. If unrounded events are supplied, they are split between samples. E.g. event-latency = 1.2 will result in a \"0.8\" and a \"0.2\" entry.\n\nAdvanced: second input can be duration in samples - careful: times(firbasis) always assumes duration = 1. Therefore, issues with LMM and predict will appear!\n\nkeyword arguments\n\ninterpolate (Bool, default false): if true, interpolates events between samples linearly. This results in predict functions to return a trailling 0scale_duration(Union{Bool,Interpolations-Interpolator}, default false):     if true, scales the response by the fit-kwargseventfieldssecond entry. That is, the FIR becomes a stepfunction instead of a impulse response.     if Interpolations.interpolator, e.g.Interpolations.Linear()- uses the fit-kwargseventfieldssecond entry to stretch the FIR kernel based onimresize`. This implements Hassall\n\nExamples\n\nGenerate a FIR basis function from -0.1s to 0.3s at 100Hz\n\njulia>  f = firbasis([-0.1,0.3],100)\n\nEvaluate at an event occuring at sample 103.3\n\njulia>  f(103.3)\n\n\n\n\n\n","category":"function"},{"location":"references/functions/#Unfold.firkernel-Tuple{Any, Any}","page":"API: Functions","title":"Unfold.firkernel","text":"firkernel(ev, times; interpolate, scale_duration)\n\n\nCalculate a sparse firbasis\n\nsecond input can be duration in samples - careful: times(firbasis) always assumes duration = 1. Therefore, issues with LMM and predict will appear!\n\nExamples\n\njulia>  f = firkernel(103.3,range(-0.1,step=0.01,stop=0.31))\njulia>  f_dur = firkernel([103.3 4],range(-0.1,step=0.01,stop=0.31))\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.formulas-Tuple{Vector{<:Pair}}","page":"API: Functions","title":"Unfold.formulas","text":"formulas(design::Vector{<:Pair})\n\nreturns vector of formulas, no schema has been applied (those formulas never saw the data). Also no timeexpansion has been applied (in the case of timecontinuous models)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.get_basis_colnames-Tuple{AbstractArray{<:StatsModels.FormulaTerm}}","page":"API: Functions","title":"Unfold.get_basis_colnames","text":"get_basis_colnames(m)\nget_basis_colnames(formulas)\n\nreturns list of colnames - e.g. times for firbasis.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.get_basis_indices-Tuple{Any, Vector}","page":"API: Functions","title":"Unfold.get_basis_indices","text":"get_basis_indices(uf, basisnames::Vector)\n\nreturns a boolean vector with length spanning all coefficients, which coefficient is defined by basisnames (vector of names)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.get_basis_names-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T}} where T<:UnfoldModel","page":"API: Functions","title":"Unfold.get_basis_names","text":"get_basisnames(model::UnfoldModel)\n\nReturn the basisnames for all predictor terms as a vector.\n\nThe returned vector contains the name of the event type/basis, repeated by their actual coefficient number (after StatsModels.apply_schema / timeexpansion). If a model has more than one event type (e.g. stimulus and fixation), the vectors are concatenated.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.hrfbasis-Tuple{Float64}","page":"API: Functions","title":"Unfold.hrfbasis","text":"hrfbasis(TR; parameters, name)\n\n\nGenerate a Hemodynamic-Response-Functio (HRF) basis with inverse-samplingrate \"TR\" (=1/FS)\n\nOptional Parameters p:                                                            defaults                                                           {seconds}         p(1) - delay of response (relative to onset)          6         p(2) - delay of undershoot (relative to onset)       16         p(3) - dispersion of response                         1         p(4) - dispersion of undershoot                       1         p(5) - ratio of response to undershoot                6         p(6) - onset {seconds}                                0         p(7) - length of kernel {seconds}                    32\n\nExamples\n\nGenerate a HRF basis function object with Sampling rate 1/TR. And evaluate it at an event occuring at TR 103.3 with duration of 4.1 TRs\n\njulia>  f = hrfbasis(2.3)\njulia>  f(103.3,4.1)\n\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.hrfkernel-Tuple{Any, Any, Any}","page":"API: Functions","title":"Unfold.hrfkernel","text":"hrfkernel(e, TR, p)\n\n\nCalculate a HRF kernel. Input e can be [onset duration]\n\nExamples\n\njulia>  f = hrfkernel(103.3,2.3,[6. 16. 1. 1. 6. 0. 32.])\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.linearize-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"API: Functions","title":"Unfold.linearize","text":"linearize(x)\n\n\nFlatten a 1D array from of a 2D/3D array. Also drops the empty dimension\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.matrix_by_basisname-Tuple{AbstractMatrix, Any, Vector}","page":"API: Functions","title":"Unfold.matrix_by_basisname","text":"Returns a view of the Matrix y, according to the indices of the timeexpanded basisname\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.modelmatrices-Tuple{AbstractDesignMatrix}","page":"API: Functions","title":"Unfold.modelmatrices","text":"modelmatrices(X::AbstractDesignMatrix)\nmodelmatrices(X::Vector{<:AbstractDesignMatrix})\nmodelmatrices(modelmatrix::AbstractMatrix)\n\nReturns the modelmatrices (also called designmatrices) separately for the events. This is similar to StatsModels.modelcols, but merely access the precomputed designmatrix. If the designmatrix needs to be computed, please use modelcols\n\nCompare to modelmatrix which further concatenates the designmatrices (in the ContinuousTime case).\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.predict_no_overlap-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T, Any, Vector, Vector}} where T<:UnfoldModel","page":"API: Functions","title":"Unfold.predict_no_overlap","text":"predict_no_overlap(, uf, coefs, f, evts)\n\n\nin ContinuousTime case (typically the deconvolution model), we return idealized predictions without overlap between events.\n\nin the Not-ContinuousTime case (typically the MassUnivariate model), we return predictions for each event independently. In that case, the function is unfortunately a missnomer, as overlap cannot be removed from mass-univariate models.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.predict_partial_overlap-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T, Any}} where T<:UnfoldModel","page":"API: Functions","title":"Unfold.predict_partial_overlap","text":"predict_partial_overlap(, uf, args; kwargs...)\n\n\nReturns predicted time-continuous values, but only for a subset of events. This is achieved by excluding the part of the designmatrix that belongs to the basisfunctions/events you do not want to have in your model.\n\nTypically called via predict, for configuration, keyword-arguments and usage see there.\n\nOne difference is, that we require the coefs(uf::UnfoldModel) already exctracted.\n\nDue to the time-continuous nature, running it with a model not containing the ContinuousTimeTrait it will throw an error.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.predicttable","page":"API: Functions","title":"Unfold.predicttable","text":"predicttable(model<:UnfoldModel,events=Unfold.events(model),args...;kwargs...)\n\nShortcut to call efficiently call (pseudocode) result_to_table(predict(...)).\n\nReturns a tidy DataFrame with the predicted results. Loops all input to predict, but really only makes sense to use if you specify either:\n\noverlap = false (the default) or epoch_to = \"eventname\".\n\n\n\n\n\n","category":"function"},{"location":"references/functions/#Unfold.prepare-Union{Tuple{T}, Tuple{Any, AbstractMatrix{<:Union{Missing, T}}}} where T<:Number","page":"API: Functions","title":"Unfold.prepare","text":"prepare(X, data)\n\n\nconvert and permutedim input to follow the following output:\n\nHÌ‚, Y, X = prepare(X, data)\n\nwhere HÌ‚ is used to save the beta, Y is the data in format ch x repeat x time (with size(time) = 1 if data is a Matrix), and X.\n\nif data is a CuArray, everything is transformed to CuArrays as well (via UnfoldCUDAExt.jl, CUDA needs to be loaded)\nsame datatype between X and data is enforced\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.prepare_XTX-Tuple{Tuple}","page":"API: Functions","title":"Unfold.prepare_XTX","text":"prepare_XTX(all)\n\n\ninstead of solving y = Xb, we solve X'Xb = X'y. This function calculates X'X and instantiates X'y to be used in the solver-step, to facilitate X'y calculations later, X' is also calculated.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.prepare_pinv-Tuple{Tuple}","page":"API: Functions","title":"Unfold.prepare_pinv","text":"prepare_pinv(all)\n\n\ncalculates pinv of the designmatrix for later use in the solver-step. This is helpful in case you have many chanels\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.result_to_table-Tuple{Any, Any, Vector{<:DataFrames.DataFrame}}","page":"API: Functions","title":"Unfold.result_to_table","text":"result_to_table(model<:UnfoldModel, eff::AbstractArray, events::Vector{<:DataFrame})\nresult_to_table(\n    eff::AbstractArray,\n    events::Vector{<:DataFrame},\n    times::Vector{<:Vector{<:Number}},\n    eventnames::Vector)\nresult_to_table(\n    eff::Vector{<:AbstractArray},\n    events::Vector{<:DataFrame},\n    times::Vector,\n    eventnames::Vector,\n)\n\nConverts an array-result (prediction or coefficient) together with the events, to a tidy dataframe.\n\nTo support multi-event models, we expect everything to be put into Vectors - this should be refactored at some point to be compatible with broadcasting, but it is not right now.\n\nargs\n\neff: A vector that contains the array(s) to be converted to a tidy dataframe. Each event in your events dataframe your have it's own array (i.e. the array should have length(eff) == length(unique(events.event))). Each array should be 3D, with channel x time x predictor events: A vector of event-dataframes, each need to match size(eff,3). Each individual event (unique(events.event)) should have it's own dataframe. E.g. [[df_event1::DataFrame], [df_event1::DataFrame]]times: A vector of time-vectors withlength(eff), each time-vector needs to matchsize.(eff,2)eventnames`: A vector of eventnames, either symbols or strings, should be a single entry per event\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.solver_default-Tuple{Any, AbstractMatrix}","page":"API: Functions","title":"Unfold.solver_default","text":"solver_default(X, y; kwargs...)\n\n\ndefault solvers.\n\nIf data is continuous (2D), we solve Xb = y via lsmr\nIf data is epoched (3D) we solve Xb = y via pinv\n\nWe highly recommend to check out solver_predefined for faster options by rather solving X'Xb = X'y via QR, cholesky, pinv or ``-solver. A benchmark is available in the online documentation.\n\nPlease see ?solver_main for keyword arguments of the solver (like stderror, multithreading, show_time, show_progress)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.solver_predefined-Tuple{Any, AbstractMatrix}","page":"API: Functions","title":"Unfold.solver_predefined","text":"solver_predefined(X, y_in; solver, kwargs...)\n\n\nhelper function that returns solver with appropriate prepare-pipelines and fitting solver-functions. X is a (typically sparse) designmatrix, y is a 2D or 3D array.\n\nsolver : one of :cg, :pinv, :intern, :qr, :cholesky, :lsmr (default)\n\nOnly lsmr solves Xb = y via an iterative solver and should be more accurate in principle.\n\nThe other predefined-solvers solve X'Xb = X'y which is often computationally much cheaper, and because X'X can be precalculated, it should be cheaper to apply.\n\nTesting this empirically is somewhat complicated, as depending on your sparsity structure (â‰ˆ your design) and the size of your data (sfreq & minutes) the best solver and the reached accuracy can change quite a bit.\n\nGPU\n\nAll solvers except :lsmr support GPU calculations. For lsmr on the GPU try solver_krylov instead\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.spdiagm_diag-Union{Tuple{T}, Tuple{Any, Vararg{Pair{<:Integer, T}}}} where T","page":"API: Functions","title":"Unfold.spdiagm_diag","text":"Speed improved version of spdiagm, takes a single float value instead of a vector, like a version of spdiagm that takes in a UniformScaling\n\ne.g.\n\nsz = 5 ix = [1,3,10] spdiagm_diag(sz,(.-ix.=>1)...)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.time_expand_allBasesSameCols-Tuple{FIRBasis, Any, Any}","page":"API: Functions","title":"Unfold.time_expand_allBasesSameCols","text":"Helper function to decide whether all bases have the same number of columns per event\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.timeexpand_cols-NTuple{4, Any}","page":"API: Functions","title":"Unfold.timeexpand_cols","text":"timeexpand_cols(basisfunction, bases, ncolsBasis, ncolsX)\n\n\ncalculates in which rows the individual event-basisfunctions should go in Xdc\n\nsee also timeexpandrows timeexpandvals\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.timeexpand_rows-NTuple{4, Any}","page":"API: Functions","title":"Unfold.timeexpand_rows","text":"timeexpand_rows(onsets, bases, shift, ncolsX)\n\n\ncalculates in which rows the individual event-basisfunctions should go in Xdc\n\ntimeexpandrows timeexpandvals\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.times-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T}} where T<:UnfoldModel","page":"API: Functions","title":"Unfold.times","text":"times(model<:UnfoldModel)\n\nreturns arrays of time-vectors, one for each basisfunction / parallel-fitted-model (MassUnivarite case)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.unfold_apply_schema-Tuple{Any, Any, Any}","page":"API: Functions","title":"Unfold.unfold_apply_schema","text":"wrapper to make apply_schema mixed models as extension possible\n\nNote: type is not necessary here, but for LMM it is for multiple dispatch reasons!\n\n\n\n\n\n","category":"method"},{"location":"tutorials/lm_overlap/#lm_overlap","page":"rERP (overlap correction)","title":"Linear Model with Overlap Correction","text":"note: Note\nWe recommend you briefly go over the mass-univariate linear modelling tutorial\n\nIn this notebook we will fit regression models to (simulated) EEG data. We will see that we need some type of overlap correction, as the events are close in time to each other, so that the respective brain responses overlap. If you want more detailed introduction to this topic check out our paper.","category":"section"},{"location":"tutorials/lm_overlap/#Setting-up-and-loading-the-data","page":"rERP (overlap correction)","title":"Setting up & loading the data","text":"using Unfold\nusing UnfoldSim\nusing UnfoldMakie,CairoMakie\nusing DataFrames\nusing DisplayAs # hide\n\ndata, evts = UnfoldSim.predef_eeg()\nnothing # hide","category":"section"},{"location":"tutorials/lm_overlap/#Overlap-Correction","page":"rERP (overlap correction)","title":"Overlap Correction","text":"For an overlap correction analysis we will do one additional step: define a temporal basisfunction. The steps are as following:\n\nspecify a temporal basisfunction\nspecify a formula\nfit a linear model for each channel (one for all timepoints!)\nvisualize the results.","category":"section"},{"location":"tutorials/lm_overlap/#Timeexpanded-/-Deconvolved-ModelFit","page":"rERP (overlap correction)","title":"Timeexpanded / Deconvolved ModelFit","text":"","category":"section"},{"location":"tutorials/lm_overlap/#1.-specify-a-temporal-basisfunction","page":"rERP (overlap correction)","title":"1. specify a temporal basisfunction","text":"By default, we would want to use a FIR basisfunction. See Basis Functions for more details.\n\nbasisfunction = firbasis(Ï„=(-0.4,.8),sfreq=100)\nnothing #hide","category":"section"},{"location":"tutorials/lm_overlap/#2.-specify-a-formula","page":"rERP (overlap correction)","title":"2. specify a formula","text":"We specify the same formula as before\n\nf  = @formula 0~1+condition+continuous\nnothing #hide","category":"section"},{"location":"tutorials/lm_overlap/#3.-fit-the-linear-model","page":"rERP (overlap correction)","title":"3. fit the linear model","text":"The formula and basisfunction is not enough on their own. We also need to specify which event and which formula matches - this is important in cases where there are multiple events with different formulas\n\nbf_vec = [Any=>(f,basisfunction)]\nbf_vec|> DisplayAs.withcontext(:is_pluto=>true) # hide\n\nnote: Note\nThe Any means to use all rows in evts. In case you have multiple events, you'd want to specify multiple basisfunctions e.g.   bfDict = [\"stimulus\"=>(f1,basisfunction1),                 \"response\"=>(f2,basisfunction2)]   You likely have to specify a further argument to fit: eventcolumn=\"type\" with type being the column in evts that codes for the event (stimulus / response in this case)\n\nNow we are ready to fit a UnfoldLinearModel. Not that instead of times as in the mass-univariate case, we have to provide the BasisFunction type now.\n\nm = fit(UnfoldModel,bf_vec,evts,data);\nnothing #hide","category":"section"},{"location":"tutorials/lm_overlap/#4.-Visualize-the-model","page":"rERP (overlap correction)","title":"4. Visualize the model","text":"Similarly to the previous tutorial, we can visualize the model\n\nresults = coeftable(m)\nplot_erp(results)\n\nCool! All overlapping activity has been removed and we recovered the simulated underlying signal.","category":"section"},{"location":"installation/#install_instruct","page":"Installing Julia + Unfold.jl","title":"Installation","text":"","category":"section"},{"location":"installation/#Installing-Julia","page":"Installing Julia + Unfold.jl","title":"Installing Julia","text":"The easiest way to install julia is using juliaup\n\nTLDR;\n\nWindows: winget install julia -s msstore\nMac/Linux: curl -fsSL https://install.julialang.org | sh\n\nWe further recommend to use VSCode. Make sure to install the Julia-Plugin, and install Revise.jl - a tutorial with screenshots can be found here","category":"section"},{"location":"installation/#Installing-Unfold.jl","page":"Installing Julia + Unfold.jl","title":"Installing Unfold.jl","text":"You can enter the package manager (similar to conda) using ] in the REPL (\"julia-commandline\").\n\nThis should result in (currentFolder) pkg> (with currentFolder being the project you currently work in)\n\nhint: Hint\nif you see (@v1.9) pkg> instead, you still have to activate your environment. This can be done using:cd(\"/path/to/your/project\")  and ]activate .or alternatively ]activate /path/to/your/project/\n\nNow you can do pkg> add Unfold\n\nand after some installation:\n\njulia> using Unfold in the REPL","category":"section"},{"location":"tutorials/lm_mu/#lm_massunivariate","page":"rERP (mass univariate)","title":"Mass Univariate Linear Models (no overlap correction)","text":"In this notebook we will fit regression models to simulated EEG data. We will see that we need some type of overlap correction, as the events are close in time to each other, so that the respective brain responses overlap. If you want more detailed introduction to this topic check out our paper.","category":"section"},{"location":"tutorials/lm_mu/#Setting-up-and-loading-the-data","page":"rERP (mass univariate)","title":"Setting up & loading the data","text":"using DataFrames\nusing Unfold\nusing UnfoldMakie, CairoMakie # for plotting\nusing UnfoldSim\nusing DisplayAs # hide\n\nnothing # hide","category":"section"},{"location":"tutorials/lm_mu/#Load-Data","page":"rERP (mass univariate)","title":"Load Data","text":"We'll start with some predefined simulated continuos EEG data. We have 2000 events, 1 channel and one condition with two levels\n\ndata, evts = UnfoldSim.predef_eeg()\nnothing # hide","category":"section"},{"location":"tutorials/lm_mu/#Inspection","page":"rERP (mass univariate)","title":"Inspection","text":"The data has only little noise. The underlying signal pattern is a positive-negative-positive spike.\n\ntimes_cont = range(0,length=200,step=1/100) # we simulated with 100hz for 0.5 seconds\n\nf,ax,h = plot(times_cont,data[1:200])\nvlines!(evts[evts.latency .<= 200, :latency] ./ 100;color=:black) # show events, latency in samples!\nax.xlabel = \"time [s]\"\nax.ylabel = \"voltage [ÂµV]\"\nf\n\nTo inspect the event dataframe we use\n\nshow(first(evts, 6), allcols = true)\n\nEvery row is an experimental event. Note that :latency refers to time in samples, (in BIDS-specification,  :onset would typically refer to seconds).","category":"section"},{"location":"tutorials/lm_mu/#Traditional-Mass-Univariate-Analysis","page":"rERP (mass univariate)","title":"Traditional Mass Univariate Analysis","text":"To perform a mass univariate analysis, you must complete the following steps:\n\nSplit data into epochs\nSpecify a formula\nFit a linear model to each time point & channel\nVisualize the results.","category":"section"},{"location":"tutorials/lm_mu/#1.-Split-data-into-epochs","page":"rERP (mass univariate)","title":"1. Split data into epochs","text":"Initially, you have data with a duration that represents the whole experimental trial. You need to cut the data into small regular epochs related to the some event, e.g. start of fixation.\n\n# Unfold supports multi-channel, so we could provide matrix ch x time, which we can create like this from a vector:\ndata_r = reshape(data, (1,:))\n# cut the data into epochs\ndata_epochs, times = Unfold.epoch(data = data, tbl = evts, Ï„ = (-0.4, 0.8), sfreq = 100); # channel x timesteps x trials\nsize(data_epochs)\n\nÏ„ specifies the epoch size.\nsfreq - sampling rate, converts Ï„ to samples.\n\ntypeof(data_epochs)\n\nnote: Note\nIn julia, missing is supported throughout the ecosystem. Thus, we can have partial trials and they will be incorporated / ignored at the respective functions. Helpful functions are the julia-base disallowmissing and the internal Unfold.drop_missing_epochs functions","category":"section"},{"location":"tutorials/lm_mu/#2.-Specify-a-formula","page":"rERP (mass univariate)","title":"2. Specify a formula","text":"Define a formula to be applied to each time point (and each channel) relative to the event. condition and continuous are the names of the event-describing columns in evts that we want to use for modelling.\n\nf = @formula 0 ~ 1 + condition + continuous # note the formulas left side is `0 ~ ` for technical reasons`\nnothing # hide","category":"section"},{"location":"tutorials/lm_mu/#3.-Fit-a-linear-model-to-each-time-point-and-channel","page":"rERP (mass univariate)","title":"3. Fit a linear model to each time point & channel","text":"Fit the \"UnfoldModel\" (the fit syntax is used throughout the Julia ecosystem, with the first element indicating what kind of model to fit)\n\nm = fit(UnfoldModel, f, evts, data_epochs, times);\nnothing #hide\n\nAlternative way to call this model is below. This syntax allows you to fit multiple events at once. For example, replacing Any with :fixation =>... will fit this model specifically to the fixation event type.\n\nm = fit(UnfoldModel, [Any=>(f, times)], evts, data_epochs);\nnothing #hide\n\nInspect the fitted model:\n\nm\nm|> DisplayAs.withcontext(:is_pluto=>true) # hide\n\nNote these functions to discover the model: design, designmatrix, modelfit and most importantly, coeftable.\n\ninfo: Info\nThere are of course further methods, e.g. `coef`, `ranef`, `Unfold.formula`, `modelmatrix` which might be helpful at some point, but not important now.\n\nUsing coeftable, we can get a tidy DataFrames, very useful for your further analysis.\n\nfirst(coeftable(m), 6)","category":"section"},{"location":"tutorials/lm_mu/#4.-Visualize-the-results","page":"rERP (mass univariate)","title":"4. Visualize the results","text":"Tidy DataFrames are easy to visualize using e.g. AlgebraOfGraphics.jl. Function plot_erp from UnfoldMakiemakes it even easier.\n\nresults = coeftable(m)\nplot_erp(results)\n\nAs you can see, there is a lot going on, even in the baseline period! This is because the signal was simulated with overlapping events. In the next tutorial you will learn how to fix this.","category":"section"},{"location":"references/extensions/#Package-extensions","page":"Overview of package extensions","title":"Package-extensions","text":"In  Julia 1.9 Package Extensions were introduced. Unfold.jl is making use of them in four ways. Prior to using some functionality, you have to add + load specific package(s) for the functionality to be available. The reason for this is, that if you don't need e.g. GPU-support, you also will not need to install it.","category":"section"},{"location":"references/extensions/#GPU:-Krylov,CUDA","page":"Overview of package extensions","title":"GPU: Krylov,CUDA","text":"To use gpu support as described in @Ref(custom_solvers) you have to:\n\nusing Krylov,CUDA\nusing Unfold","category":"section"},{"location":"references/extensions/#RobustSolvers.jl","page":"Overview of package extensions","title":"RobustSolvers.jl","text":"To use robust (outlier-\"safe\") solvers support as described in @Ref(custom_solvers) you have to:\n\nimport RobustSolvers\nusing Unfold","category":"section"},{"location":"references/extensions/#Non-linear-effects:-BSplineKit.jl","page":"Overview of package extensions","title":"Non-linear effects: BSplineKit.jl","text":"Finally to use non-linear effects/splines like in @formula 0~1+spl(continuous,5) you have to use:\n\nimport BSplineKit\nusing Unfold\n\nnote: Note\nIn principle you should be able to load the package after loading Unfold. But sometimes this doesnt work, a Base.retry_load_extensions() call might help in these situations.","category":"section"},{"location":"generated/HowTo/contrasts/#contrasts","page":"Change contrasts / coding schema","title":"Contrast Coding","text":"using CairoMakie\nusing Unfold\nusing UnfoldMakie\nusing UnfoldSim\n\n\n# Contrast coding\n\nUnfold.jl uses the StatsModels package for the formula interface. This allows for a wide range of contrast coding schemes. For a full tutorial, please see the StatsModels docs. Please read their tutorial, as a motivation of why one would change the contrast coding scheme is outside of the realms of this package and more a basic linear regression question.\n\nhint: Hint\nGiven we have a nice effects implementation (mimicking emmeans and similar packages), coding schema is typically less important.\n\nHere we will show a simple example of how to change the contrast coding scheme. We will use the condition variable, which has two levels, A and B. We will change the contrast coding from Dummy aka Reference aka 0/1 coding to Sum coding, which is the default in R.\n\neeg, evts = UnfoldSim.predef_eeg(noiselevel = 0)\nf = @formula 0 ~ 1 + condition\nbasis = firbasis((-0.1, 0.6), 100)\nm_dummy = fit(UnfoldModel, f, evts, eeg, basis)\nm_effec =\n    fit(UnfoldModel, f, evts, eeg, basis; contrasts = Dict(:condition => EffectsCoding()))\n\nwe could directly inspect the designmatrix\n\nmodelmatrix(m_dummy, false)[1][1:5, :]\n\nand the effects coding\n\nmodelmatrix(m_effec, false)[1][1:5, :]\n\nTo confirm the difference in the actual fit, let's visualize them\n\nc_d = coeftable(m_dummy)\nc_e = coeftable(m_effec)\nc_d.group .= \"Dummy Coding\"\nc_e.group .= \"Effects Coding\"\nc = vcat(c_d, c_e)\n\nplot_erp(c; mapping = (; color = :coefname, col = :group))\n\nAs expected, the effects-coding slope of condition: face is half the size of the dummy-coding one (because -1/1 coding was used).\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/explanations/nonlinear_effects/#[Non-linear-effects]](@id-nonlinear)","page":"Non-Linear effects","title":"[Non-linear effects]](@id nonlinear)","text":"import BSplineKit\nusing Unfold\nusing CairoMakie\nusing DataFrames\nusing Random\nusing Colors\nusing Missings","category":"section"},{"location":"generated/explanations/nonlinear_effects/#Generating-a-non-linear-signal","page":"Non-Linear effects","title":"Generating a non-linear signal","text":"We start with generating data variables\n\nrng = MersenneTwister(2) # make repeatable\nn = 20 # number of datapoints\nevts = DataFrame(:x => rand(rng, n))\nsignal = -(3 * (evts.x .- 0.5)) .^ 2 .+ 0.5 .* rand(rng, n)\n\nplot(evts.x, signal)\n\nLooks perfectly non-linear. Great!","category":"section"},{"location":"generated/explanations/nonlinear_effects/#Compare-linear-and-non-linear-fit","page":"Non-Linear effects","title":"Compare linear & non-linear fit","text":"First, we have to reshape signal data to a 3d array, so it will fit to Unfold format:  1 channel x 1 timepoint x 20 datapoints.\n\nsignal = reshape(signal, length(signal), 1, 1)\nsignal = permutedims(signal, [3, 2, 1])\nsize(signal)\n\nNext we define three different models: linear, 4 splines and 10 splines. Note difference in formulas: one x, the other spl(x, 4).\n\ndesign_linear = [Any => (@formula(0 ~ 1 + x), [0])];\ndesign_spl3 = [Any => (@formula(0 ~ 1 + spl(x, 4)), [0])];\ndesign_spl10 = [Any => (@formula(0 ~ 1 + spl(x, 10)), [0])];\nnothing #hide\n\nNext, fit the parameters.\n\nuf_linear = fit(UnfoldModel, design_linear, evts, signal);\nuf_spl3 = fit(UnfoldModel, design_spl3, evts, signal);\nuf_spl10 = fit(UnfoldModel, design_spl10, evts, signal); #hide\nnothing #hide\n\nExtract the fitted values using Unfold.effects.\n\np_linear = Unfold.effects(Dict(:x => range(0, stop = 1, length = 100)), uf_linear);\np_spl3 = Unfold.effects(Dict(:x => range(0, stop = 1, length = 100)), uf_spl3);\np_spl10 = Unfold.effects(Dict(:x => range(0, stop = 1, length = 100)), uf_spl10);\nfirst(p_linear, 5)\n\nPlot them.\n\npl = plot(evts.x, signal[1, 1, :])\nlines!(p_linear.x, p_linear.yhat)\nlines!(p_spl3.x, coalesce.(p_spl3.yhat, NaN))\nlines!(p_spl10.x, coalesce.(p_spl10.yhat, NaN))\npl\n\nWe see here, that the linear effect (blue line) underfits the data, the yellow spl(x, 10) overfits it, but the green spl(x, 4) fits it perfectly.","category":"section"},{"location":"generated/explanations/nonlinear_effects/#Looking-under-the-hood","page":"Non-Linear effects","title":"Looking under the hood","text":"Let's have a brief look how the splines manage what they are managing.\n\nThe most important bit to understand is, that we are replacing x by a set of coefficients spl(x). These new coefficients each tile the range of x (in our case, from [0-1]) in overlapping areas, while each will be fit by one coefficient. Because the ranges are overlapping, we get a smooth function.\n\nMaybe this becomes clear after looking at a basisfunction:\n\nterm_spl = Unfold.formulas(uf_spl10)[1].rhs.terms[2]\n\nThis is the spline term. Note, this is a special type available in the BSplineKit.jl extension in Unfold.jl. It's abstract type is AbstractSplineTerm defined in Unfold.jl\n\ntypeof(term_spl)\n\nconst splFunction = Base.get_extension(Unfold, :UnfoldBSplineKitExt).splFunction\nsplFunction([0.2], term_spl)\n\nEach column of this 1-row matrix is a coefficient for our regression model.\n\nlines(disallowmissing(splFunction([0.2], term_spl))[1, :])\n\nNote: We have to use disallowmissing, because our splines return a missing whenever we ask it to return a value outside its defined range, e.g.:\n\nsplFunction([-0.2], term_spl)\n\nBecause it never has seen any data outside and can't extrapolate!\n\nBack to our main issue. Let's plot the whole basis set\n\nbasisSet = splFunction(0.0:0.01:1, term_spl)\nbasisSet = disallowmissing(basisSet[.!any(ismissing.(basisSet), dims = 2)[:, 1], :]) # remove missings\nax = Axis(Figure()[1, 1])\n[lines!(ax, basisSet[:, k]) for k = 1:size(basisSet, 2)]\ncurrent_figure()\n\nNotice how we flipped the plot around, i.e. now on the x-axis we do not plot the coefficients, but the x-values. Now each line is one basis-function of the spline.\n\nUnfold returns us one coefficient per basis-function\n\nÎ² = coef(uf_spl10)[1, 1, :]\nÎ² = Float64.(disallowmissing(Î²))\n\nBut because we used an intercept, we have to do some remodelling in the basisSet.\n\nX = hcat(ones(size(basisSet, 1)), basisSet[:, 1:5], basisSet[:, 7:end])\n\nNow we can weight the spline by the basisfunction.\n\nweighted = (Î² .* X')\n\nPlotting them creates a nice looking plot!\n\nax = Axis(Figure()[1, 1])\n[lines!(weighted[k, :]) for k = 1:10]\ncurrent_figure()\n\nNow sum them up.\n\nlines(sum(weighted, dims = 1)[1, :])\nplot!(X * Î², color = \"gray\") #(same as matrixproduct X*Î² directly!)\ncurrent_figure()\n\nAnd this is how you can think about splines.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"HowTo/custom_solvers/#custom_solvers","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers","text":"A solver takes an Unfold-specified DesignMatrix and the data, and typically solves the equation system y = Xb (in the case of Linear Models). There are many different ways how one can approach this problem, depending if the matrix is sparse, if it is 2D or 3D, if one wants to use GPU etc.\n\nMost implemented solvers ultimately make use of solver_main for their main loop. See the reference tutorial for more information if that is interesting to you.","category":"section"},{"location":"HowTo/custom_solvers/#Setup-some-data","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Setup some data","text":"using Unfold\nusing UnfoldMakie, CairoMakie\nusing UnfoldSim\ndat, evts = UnfoldSim.predef_eeg(; noiselevel = 10, return_epoched = true)\n\nf = @formula 0 ~ 1 + condition + continuous\ndesignDict = Dict(Any => (f, range(0, 1, length = size(dat, 1))))","category":"section"},{"location":"HowTo/custom_solvers/#GPU-Solvers","page":"Alternative Solvers (Robust, GPU, B2B)","title":"GPU Solvers","text":"GPU solvers can significantly speed up your model fitting, with observed improvements of up to a factor of 30-100!","category":"section"},{"location":"HowTo/custom_solvers/#fastest-GPU-solver","page":"Alternative Solvers (Robust, GPU, B2B)","title":"fastest GPU solver","text":"Empirically we found that solving X'Xb = X'y is the fastest way to solve for b. To achieve this, you can run:\n\nusing CUDA\ngpu_solver =(x, y) -> Unfold.solver_predefined(x, y; solver=:qr)\nm = Unfold.fit(UnfoldModel, designDict, evts, cu(dat), solver = gpu_solver)\n\nWhere the cu is the magic that moves the data to the GPU. Internatlly, the solver function will move the matrix as well and pre-calculate some matrices (especially X'X, X' and allocate X'y).","category":"section"},{"location":"HowTo/custom_solvers/#lsmr-GPU-solver","page":"Alternative Solvers (Robust, GPU, B2B)","title":"lsmr GPU solver","text":"the Krylov.lsmr implementation directly solves y = Xb, but allows for running on the GPU.\n\nusing Krylov, CUDA # necessary to load the right package extension\ngpu_solver =(x, y) -> Unfold.solver_krylov(x, y; GPU = true)\nm = Unfold.fit(UnfoldModel, designDict, evts, dat, solver = gpu_solver)\n\nTo test it, you will need to run it yourself as we cannot run it on the docs. If you require a different graphicscard vendor than NVIDA/CUDA, please create an issue. Currently, we are unable to test it due to lack of hardware.","category":"section"},{"location":"HowTo/custom_solvers/#Robust-Solvers","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Robust Solvers","text":"Robust solvers automatically adjust for outlier trials, but they come at a significant computational cost.\n\nusing RobustModels # necessary to load the Unfold package extension\nse_solver = (x, y) -> Unfold.solver_robust(x, y)\nm = Unfold.fit(UnfoldModel, designDict, evts, dat, solver = se_solver)\nresults = coeftable(m)\nplot_erp(results; stderror = true)","category":"section"},{"location":"HowTo/custom_solvers/#Back2Back-regression","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Back2Back regression","text":"Since 2025, this solver requires UnfoldDecode - please find the tutorial and explanation there, the example here is for historic reasons and will be removed at a later point.\n\nusing UnfoldDecode\nb2b_solver = (x, y) -> UnfoldDecode.solver_b2b(x, y; ross_val_reps = 5)\ndat_3d = permutedims(repeat(dat, 1, 1, 20), [3 1 2])\nm = Unfold.fit(UnfoldModel, designDict, evts, dat_3d; solver = b2b_solver)\nresults = coeftable(m)\n\nplot_erp(results)\n\nThese are the decoding results for conditionA while considering conditionB, and vice versa.","category":"section"},{"location":"generated/explanations/predict/#The-predict-family","page":"Predictions","title":"The predict-family","text":"# Setup\nusing Unfold\nusing UnfoldSim\nusing CairoMakie\n\ndat, evts = UnfoldSim.predef_eeg(noiselevel = 5)\ndesign = [\n    \"car\" => (@formula(0 ~ 1 + continuous), firbasis(Ï„ = (-0.5, 1), sfreq = 100)),\n    \"face\" => (@formula(0 ~ 1 + continuous), firbasis(Ï„ = (-0.3, 0.5), sfreq = 100)),\n]\n\nm = fit(UnfoldModel, design, evts, dat; eventcolumn = :condition);\nnothing #hide","category":"section"},{"location":"generated/explanations/predict/#Overview","page":"Predictions","title":"Overview","text":"In a linear model EEG = XÎ² + e, predictions boil down to finding hatEEG = XÎ², thus EEG data without any error term. Different types of predictions can be generated by modifying the X accordingly.\n\nnote: Note\nWe simulated only a single channel, all results generalize to the multi channel case","category":"section"},{"location":"generated/explanations/predict/#Different-types-of-predictions","page":"Predictions","title":"Different types of predictions","text":"","category":"section"},{"location":"generated/explanations/predict/#Time-Continuous-case","page":"Predictions","title":"Time-Continuous case","text":"Let's start with the cases, where the EEG was not epoched before using Unfold, i.e. the EEG was analysed with e.g. FIR-deconvolution","category":"section"},{"location":"generated/explanations/predict/#Continuous-EEG","page":"Predictions","title":"Continuous EEG","text":"In the most simple case, we can predict the continuously modelled EEG - This returns EEG = XÎ²\n\np = predict(m) # same as predict(m, overlap = true)\nlines(p[1, 1:1000])","category":"section"},{"location":"generated/explanations/predict/#No-overlap","page":"Predictions","title":"No-overlap","text":"We can also predict each epoch without any overlap - This results in one prediction Array per event (in our case we have two events \"car\" and \"face\", thus size(p) = 2\n\np = predict(m, overlap = false)\nsize(p)\n\nEach Array has the size (1, samples, epochs):\n\nsize(p[1])\n\nVisualizing the 1000 events\n\nseries(range(-0.5, 1, step = 1 / 100), p[1][1, :, :]', solid_color = :orange)\nseries!(range(-0.3, 0.5, step = 1 / 100), p[2][1, :, :]', solid_color = :teal)\ncurrent_figure()\n\nnote: Note\nAt ~0.3s we can see a split between the predicted EEG single trials into 10 \"strands\" - this is the granularity of our continuous predictor. You could use effects to improve upon this granularity / customize it.","category":"section"},{"location":"generated/explanations/predict/#With-overlap,-epoched","page":"Predictions","title":"With-overlap, epoched","text":"Sometimes helpful is to add in the overlap we removed via the deconvolution.\n\np = predict(m, epoch_to = [\"car\"], eventcolumn = :condition)\nseries(range(-0.5, 1, step = 1 / 100), p[1, :, 1:3]', solid_color = :orange)","category":"section"},{"location":"generated/explanations/predict/#Partial-overlap","page":"Predictions","title":"Partial-overlap","text":"We can also include/exclude certain events with \"partial-overlap\", i.e. only overlap with kept events.\n\np_car = predict(m, keep_basis = [\"car\"], eventcolumn = :condition)\np_face = predict(m, exclude_basis = [\"car\"], eventcolumn = :condition) # same as keep_basis=[\"face\"]\nf = lines(p_car[1, 1:1000])\nlines!(p_face[1, 1:1000])\nf\n\nIn the plot, we see the two partial predictions for car and face. They are respectively \"0\" outside the basisfunction windows\n\nnote: Note\nThe above options can be combined as well, e.g. to get an epoch_to, exclude_basis version. epoch_timewindow can be specified as well.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/references/solver/#solver_implementation","page":"Solver/optimizer implementations","title":"Solver implementation","text":"This document describes how the solver_main is implemented and how to add custom solvers.\n\nsome setup\n\nusing Unfold, UnfoldSim, CairoMakie\nusing LinearAlgebra: cholesky","category":"section"},{"location":"generated/references/solver/#Solver-main","page":"Solver/optimizer implementations","title":"Solver main","text":"This function gis a eneral purpose solver-wrapper function. It calls  prepare_fun and iterates over the first dimension of data, repeatedly calling the solver_fun.\n\nWithout any bells and whistles (progress, history etc.) the function roughly looks like this:\n\nfunction _solver_min(X, data; prepare_fun, solver_fun!, stderror = false)\n    HÌ‚, dataP, prepared = prepare_fun(X, data)\n    for ch = 1:size(dataP, 2)\n        for t = 1:size(dataP, 3)\n            ch == 1 || copyto!(view(HÌ‚, ch, :, t), view(HÌ‚, ch - 1, :, t))\n            solver_fun!(view(HÌ‚, ch, :, t), view(dataP, :, ch, t), prepared...)\n        end\n    end\n    modelfit = stderror ? calculate_stderror(X, data, HÌ‚) : nothing\n\n    return modelfit\n\nend\n\nBefore diving into the prepare_fun and solver_fun! functions, let's discuss first the inner loop t=1:size(dataP,3). This loop really only comes alife (that is size(dataP,3)!=1) if a mass-univariate model is fitted, that is, when ndims(data)==3`. We still have it around for 2D, un-epoched data, to have exactly the same code in both cases.","category":"section"},{"location":"generated/references/solver/#prepare_fun","page":"Solver/optimizer implementations","title":"prepare_fun`","text":"This function is the setup / prepare function. It is typically a chain of functions with similar input / output characteristica. The first fuction of the chain/pipeline should be a function taking (X,data)and returning (HÌ‚::AbstractArray, dataP::AbstractArray, prepared::Tuple).\n\nHÌ‚ is used to save the beta/parameters inplace\ndataP is the data in format ch x repeat x time (with size(time) = 1 if data initially was a Matrix/2D-array)\nprepared is a tuple of all the other variables needed in the solver-step, e.g. the pinv(X) or X'X or simply X\n\nThe prepare function which is typiclly the first, just permutes the data & converts everything to GPU in case data::CuArray.\n\nThe next function in a pipeline then would take this (HÌ‚::AbstractArray, dataP::AbstractArray, prepared::Tuple) inputs and process it further.`","category":"section"},{"location":"generated/references/solver/#solver_fun!","page":"Solver/optimizer implementations","title":"solver_fun!","text":"This function actually performs the fitting. It takes the inputs (HÌ‚::view(Matrix),data::view(Array),prepared::Tuple)\n\nHÌ‚ is the current beta/parameters view, a vector/slice for one channel and one timepoint\ndata is similarly the current data view, a vector/slice for one channel and one timepoint\nprepared is the tuple-output of the prepare function.\n\nThe solver_fun! can output some history of the solver, e.g. a log for iterative solvers.","category":"section"},{"location":"generated/references/solver/#Example-(simple)","page":"Solver/optimizer implementations","title":"Example (simple)","text":"let's setup our own solver:\n\n_my_solver!(HÌ‚, data, X) = HÌ‚ .= Matrix(X) \\ data\n\nlet's simulate some data and see this in action\n\ndata, evts = UnfoldSim.predef_eeg()\nm = fit(\n    UnfoldModel,\n    @formula(0 ~ 1 + condition),\n    evts,\n    data,\n    firbasis((-0.1, 0.5), 100);\n    solver = (x, y) ->\n        Unfold.solver_main(x, y; solver_fun! = _my_solver!, show_time = true),\n)\n\nRemember from this table the time for one solve (~700ms on my test-computer) this is the time per channel.\n\nseries(coef(m))","category":"section"},{"location":"generated/references/solver/#Cholesky-Example","page":"Solver/optimizer implementations","title":"Cholesky Example","text":"note: Note\nthe following function is already implemented in Unfold.jl as well. See ?Unfold.solver_predefined\n\nGiven that the prepare function returns all necessary ingredients, this is a bit simple. So let's make it more complex\n\nfor nicety, we need some unpacking wrappers\n\n_prepare_cholesky(all::Tuple) = _prepare_cholesky(all...)\n_prepare_cholesky(HÌ‚, data, all::Tuple) = _prepare_cholesky(HÌ‚, data, all...)\n\nthis function effectively only pre-calculates the cholesky decomposition\n\n_prepare_cholesky(HÌ‚, data, Xt, R_xx, R_xy) = (HÌ‚, data, (Xt, cholesky(R_xx), R_xy))\n\nnow we have everything to put together our solver-pipeline\n\n_my_prepare =\n    (x, y) -> Unfold.prepare(collect(x), y) |> Unfold.prepare_XTX |> _prepare_cholesky\n\nlet's test (note we have to reshape the data)\n\n@time _my_prepare(modelmatrix(m), reshape(data, 1, :))\n\nfinally, we need a solver this is how we solve the single-channel equation\n\nfunction _my_cholesky!(beta, data, Xt, XtX_cholesky, R_xy)\n    @time Unfold.calc_Rxy!(R_xy, Xt, data)\n    @time beta .= XtX_cholesky \\ R_xy\nend\n\nm = fit(\n    UnfoldModel,\n    @formula(0 ~ 1 + condition),\n    evts,\n    data,\n    firbasis((-0.1, 0.5), 100);\n    solver = (x, y) -> Unfold.solver_main(\n        x,\n        y;\n        prepare_fun = _my_prepare,\n        solver_fun! = _my_cholesky!,\n        show_time = true,\n    ),\n)\n\nThis (on my test-computer) took only 97ms per channel, so it is ~7x faster per channel.\n\nseries(coef(m))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"HowTo/standarderrors/#standard_errors","page":"Standard errors","title":"Standard Errors","text":"","category":"section"},{"location":"HowTo/standarderrors/#Setup-some-data","page":"Standard errors","title":"Setup some data","text":"using Unfold\nusing UnfoldMakie, CairoMakie\nusing UnfoldSim\ndat, evts = UnfoldSim.predef_eeg(; noiselevel = 10, return_epoched = true)\n\nf = @formula 0 ~ 1 + condition + continuous\ndesignDict = Dict(Any => (f, range(0, 1, length = size(dat, 1))))\n\nIt is possible to specify a solver that calculates the standard errors of the estimates for a single subject as it possible for custom solvers.\n\nse_solver = (x, y) -> Unfold.solver_default(x, y, stderror = true)\nm = Unfold.fit(UnfoldModel, designDict, evts, dat, solver = se_solver)\nresults = coeftable(m)\nplot_erp(results; stderror = true)\n\nwarning: Warning\nIn case of overlap-correction: Use single-subject standard errors on your own risk. EEG data is autocorrelated, which means that standard errors are typically too small.","category":"section"},{"location":"generated/HowTo/effects/#effects","page":"Marginal effects (must read re: splines)","title":"Marginal effects","text":"Marginal effect plots are useful for understanding model fits.\n\nIf you are an EEG researcher, you can think of the coefficients as the 'difference waves' and the (marginal) effects as the 'modelled ERP evaluated at a certain predictor value combination'. In some way, we are fitting a model with coefficients, receiving intercepts and slopes, and then try to recover the 'classical' ERPs in their \"data-domain\", typically with some effect adjustment, overlap removal, or similar.","category":"section"},{"location":"generated/HowTo/effects/#Setup-things","page":"Marginal effects (must read re: splines)","title":"Setup things","text":"Setup some packages\n\nusing Unfold\nusing DataFrames\nusing Random\nusing CSV\nusing UnfoldMakie\nusing UnfoldSim\nusing UnfoldMakie\nusing DisplayAs # hide\n\nGenerate data and fit a model with a 2-level categorical predictor and a continuous predictor without interaction.\n\ndata, evts = UnfoldSim.predef_eeg(; noiselevel = 8)\n\nbasisfunction = firbasis(Ï„ = (-0.1, 0.5), sfreq = 100; interpolate = false)\n\nf = @formula 0 ~ 1 + condition + continuous # 1\n\nm = fit(UnfoldModel, [Any => (f, basisfunction)], evts, data, eventcolumn = \"type\")\nm |> DisplayAs.withcontext(:is_pluto => true) # hide\n\nPlot the results\n\nplot_erp(coeftable(m))\n\nThe coefficients are represented by three lines on a figure:\n\nthe intercept showing the reference category for a typical p1/n1/p3 ERP components;\nthe slope of continuous variables with 1ÂµV range;\nthe effect of categorical variabe with 3ÂµV range.","category":"section"},{"location":"generated/HowTo/effects/#Effects-function","page":"Marginal effects (must read re: splines)","title":"Effects function","text":"In order to better understand the actual predicted ERP curves, often researchers had to do manual contrasts. Remember that a linear model is y = X * b, which allows (after b was estimated) to input a so-called contrast vector for X. You might know this in the form of [1, 0, -1, 1] or similar form. However, for larger models, this method can be prone to errors.\n\nThe effects function is a convenient way to specify contrast vectors by providing the actual levels of the experimental design. It can be used to calculate all possible combinations of multiple variables.\n\nIf a predictor-variable is not specified here, the function will automatically set it to its typical value. This value is usually the mean, but for categorical variables, it could be something else. The R package emmeans has a lot of discussion on this topic.\n\neff = effects(Dict(:condition => [\"car\", \"face\"]), m)\nplot_erp(eff; mapping = (; color = :condition,))\n\nWe can also generate continuous predictions:\n\neff = effects(Dict(:continuous => -5:0.5:5), m)\nplot_erp(\n    eff;\n    mapping = (; color = :continuous, group = :continuous => nonnumeric),\n    categorical_color = false,\n    categorical_group = false,\n)\n\nOr we can split our marginal effects by condition and calculate all combinations \"automagically\".\n\neff = effects(Dict(:condition => [\"car\", \"face\"], :continuous => -5:2:5), m)\nplot_erp(eff; mapping = (; color = :condition, col = :continuous))","category":"section"},{"location":"generated/HowTo/effects/#What-is-typical-anyway?","page":"Marginal effects (must read re: splines)","title":"What is typical anyway?","text":"The effects function includes an argument called typical, which specifies the function applied to the marginalized covariates/factors. The default value is mean, which is usually sufficient for analysis.\n\nHowever, for skewed distributions, it may be more appropriate to use the mode, while for outliers, the median or winsor mean may be more appropriate.\n\nTo illustrate, we will use the maximum function on the continuous predictor.\n\neff_max = effects(Dict(:condition => [\"car\", \"face\"]), m; typical = maximum)\neff_max.typical .= :maximum\neff = effects(Dict(:condition => [\"car\", \"face\"]), m)\neff.typical .= :mean # mean is the default\n\nplot_erp(vcat(eff, eff_max); mapping = (; color = :condition, col = :typical))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"90-contributing/#contributing","page":"Contributing guidelines","title":"Contributing guidelines","text":"First of all, thanks for the interest!\n\nWe welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc.\n\nBe polite and respectful, and follow the code of conduct.","category":"section"},{"location":"90-contributing/#Bug-reports-and-discussions","page":"Contributing guidelines","title":"Bug reports and discussions","text":"If you think you found a bug, feel free to open an issue. Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please.","category":"section"},{"location":"90-contributing/#Working-on-an-issue","page":"Contributing guidelines","title":"Working on an issue","text":"If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below). Otherwise, say what your proposed solution is and wait for a discussion around it.\n\ntip: Tip\nFeel free to ping us after a few days if there are no responses.\n\nIf your solution involves code (or something that requires running the package locally), check the developer documentation. Otherwise, you can use the GitHub interface directly to create your pull request.","category":"section"},{"location":"generated/HowTo/unfold_io/#unfold_io","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"Unfold.jl allows storing Unfold models in a memory-efficient way using (compressed) .jld2 files.","category":"section"},{"location":"generated/HowTo/unfold_io/#Simulate-EEG-data-and-fit-an-Unfold-model","page":"Save and load Unfold models","title":"Simulate EEG data and fit an Unfold model","text":"<details>\n<summary>Click to expand</summary>","category":"section"},{"location":"generated/HowTo/unfold_io/#Simulate-some-example-data-using-UnfoldSim.jl","page":"Save and load Unfold models","title":"Simulate some example data using UnfoldSim.jl","text":"using UnfoldSim\ndata, events = UnfoldSim.predef_eeg(; n_repeats = 10)\nfirst(events, 5)","category":"section"},{"location":"generated/HowTo/unfold_io/#Fit-an-Unfold-model","page":"Save and load Unfold models","title":"Fit an Unfold model","text":"using Unfold\nbasisfunction = firbasis(Ï„ = (-0.5, 1.0), sfreq = 100, name = \"stimulus\")\nf = @formula 0 ~ 1 + condition + continuous\nbfDict = Dict(Any => (f, basisfunction))\nm = fit(UnfoldModel, bfDict, events, data);\nnothing #hide\n\n</details >","category":"section"},{"location":"generated/HowTo/unfold_io/#Save-and-load-the-fitted-Unfold-model","page":"Save and load Unfold models","title":"Save and load the fitted Unfold model","text":"The following code saves the model in a compressed .jld2 file. The default option of the save function is compress=false. For memory efficiency the designmatrix is set to missing. If needed, it can be reconstructed when loading the model.\n\nsave_path = mktempdir(; cleanup = false) # create a temporary directory for the example\nsave(joinpath(save_path, \"m_compressed.jld2\"), m; compress = true);\nnothing #hide\n\nThe load function allows to retrieve the model again. By default, the designmatrix is reconstructed. If it is not needed set generate_Xs=false` which improves time-efficiency.\n\nm_loaded = load(joinpath(save_path, \"m_compressed.jld2\"), UnfoldModel, generate_Xs = true);\nnothing #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"explanations/basisfunctions/#Basis-Functions","page":"Basisfunctions","title":"Basis Functions","text":"This document will give you an explanation of basis functions. We start with basis functions for fMRI because they are very popular.","category":"section"},{"location":"explanations/basisfunctions/#HRF-/-BOLD","page":"Basisfunctions","title":"HRF / BOLD","text":"We want to define a basis function. There are currently only few basisfunctions implemented in Unfold.jl, but your imagination knows no borders!\n\nWe first have a look at the BOLD-HRF basisfunction aka Blood Oxygenation Level Dependent Hemodynamic Response Function:\n\nusing Unfold, DSP\n\nTR = 1.5 # the sampling rate\nbold = hrfbasis(TR) # using default SPM parameters\neventonset = 1.3\nbold_kernel = e -> Unfold.kernel(bold, e)\nlines(bold_kernel(eventonset)[:,1]) # returns a matrix, thus [:, 1]\n\nThis is the shape that is assumed to reflect the activity for an event. Generally, we would like to know how much to scale this response shape per condition, e.g. in condA we might scale it by 0.7, in condB by 1.2.\n\nBut let's start at the beginning and first simulate an fMRI signal. Then you will also appreciate why we need to deconvolve it later.","category":"section"},{"location":"explanations/basisfunctions/#Convolving-a-response-shape-to-get-a-\"recorded\"-fMRI-signal","page":"Basisfunctions","title":"Convolving a response shape to get a \"recorded\" fMRI signal","text":"We start by convolving this HRF function with an impulse vector at event onsets.\n\ny = zeros(100) # signal length = 100\ny[[10, 30, 45]] .= 0.7 # 3 events at given for condition A\ny[[37]] .= 1.2 # 1 events at given for condition B\n\ny_conv = conv(y, bold_kernel(0)) # convolve!\nlines(y_conv[:,1])\n\nNext, we would add some noise:\n\nusing Random\ny_conv += randn(size(y_conv))\nlines(y_conv[:,1])\n\nðŸŽ‰ - we did it, we simulated fMRI data.\n\nNow you can see that the conditions overlap in time. To get back to the original amplitude values, we need to specify a basis function and use Unfold to deconvolve the signals.\n\nnote: Note\nEvents can fall between TR (the sampling rate). Some packages subsample the time signal, but in Unfold we can call the bold.kernel function directly at a given event time, which allows us to use non-TR multiples.","category":"section"},{"location":"explanations/basisfunctions/#FIR-Basis-Function","page":"Basisfunctions","title":"FIR Basis Function","text":"Okay, let's have a look at a different basis function: The FIR basisfunction. FIR stands for Finite-Impulse-Response and is a term taken from the filtering literature.\n\nusing Unfold #hide\n\nbasisfunction = firbasis(Ï„=(-0.4,.8), sfreq=50, name=\"myFIRbasis\")\nfir_kernel = e -> Unfold.kernel(basisfunction, e)\nm = fir_kernel(0)\nf = Figure()\nf[1,1] = Axis(f)\nfor col = 1:size(m, 2)\n    lines!(m[:,col])\nend\ncurrent_figure()\n\nThe first thing to notice is that it is not a single basisfunction, but a set of basisfunctions. So every condition is explained by several basis functions!\n\nTo make it clear better show it in 2D:\n\nfir_kernel(0)[1:10,1:10]\n\n(all . are 0's)\n\nThe FIR basis set consists of multiple basis functions. That is, each event is now time-expanded to multiple predictors, each with a certain time delay to the event onset. This allows us to model any linear overlap shape, and doesn't force us to make assumptions about the convolution kernel, as we had to do in the BOLD case.","category":"section"},{"location":"generated/HowTo/baddata/#Removing-BAD-data","page":"Mark bad data segments","title":"Removing BAD data","text":"Sometimes one has bad data (artefacts etc.) in the data that one wants to remove prior to fitting.","category":"section"},{"location":"generated/HowTo/baddata/#Setup","page":"Mark bad data segments","title":"Setup","text":"<details>\n<summary>Click to expand</summary>\n\n# Load required packages\nusing UnfoldSim\nusing Unfold\n\nusing CairoMakie, UnfoldMakie\n\nusing Random\n\n</details >","category":"section"},{"location":"generated/HowTo/baddata/#Simulation","page":"Mark bad data segments","title":"Simulation","text":"Let's start with a simulation of some data, and add some bad-data.\n\nrng = MersenneTwister(1)\ndata, evts = UnfoldSim.predef_eeg(n_repeats = 1)\nix = 100:500\ndata[ix] .+= 50 .* (rand(rng, length(ix)) .- 0.5)\n\nf = lines(data[1:1000])\nf\n\nClearly this data is bad and we should rather remove it! We can use Julias missing data-type to indicate those portions.\n\nusing Missings\ndata_missing = allowmissing(data)\ndata_missing[ix] .= missing\n\nlines(f.figure[2, 1], data_missing[1:1000])\nf\n\nNice, the data is sucessfully marked as missing, without changing the overall size / timing of the data\n\nWe can now fit a model with, and without the noise data. Unfold automatically detects missing data, and does not use it in the modelfit.\n\nm = fit(UnfoldModel, @formula(0 ~ 1), evts, data, firbasis((-0.3, 0.5), 100))\nm_missing =\n    fit(UnfoldModel, @formula(0 ~ 1), evts, data_missing, firbasis((-0.3, 0.5), 100))\nc = coeftable(m)\nc.group .= \"with bad data\"\nc_missing = coeftable(m_missing)\nc_missing.group .= \"bad data removed\"\n\nplot_erp(vcat(c, c_missing), mapping = (; color = :group))\n\nCurrently no helper function exists to translate e.g. MNE BAD segments/annotations automatically, but pull requests are very welcome!\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/HowTo/circular_splines/#Circular-Splines","page":"Circular splines","title":"Circular Splines","text":"","category":"section"},{"location":"generated/HowTo/circular_splines/#Setup","page":"Circular splines","title":"Setup","text":"<details>\n<summary>Click to expand</summary>\n\n# Load required packages\n\nusing Unfold\nusing UnfoldSim\nusing BSplineKit\nusing StableRNGs\nusing CairoMakie, UnfoldMakie\n\n</details> ```\n\ndata, evts = UnfoldSim.predef_eeg(; return_epoched = true)\nevts.cycle = rand(StableRNG(1), size(evts, 1))\ntimes = range(0, 1, length = size(data, 1))\nm = fit(UnfoldModel, @formula(0 ~ 1 + circspl(cycle, 5, 0, 1)), evts, data, times)\n\neff = effects(Dict(:cycle => 0:0.2:1), m)\nplot_erp(eff; mapping = (; color = :cycle, group = :cycle))\n\n\ndata, evts = UnfoldSim.predef_eeg(; return_epoched = false)\nevts.cycle = rand(StableRNG(1), size(evts, 1))\n#times = range(0,1,length=size(data,1))\nm = fit(\n    UnfoldModel,\n    [Any => (@formula(0 ~ 1 + circspl(cycle, 5, 0, 1)), firbasis((0, 1), 10))],\n    evts,\n    data,\n)\n\neff = effects(Dict(:cycle => 0:0.2:1), m)\nplot_erp(eff; mapping = (; color = :cycle, group = :cycle))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"references/types/#Unfold.AbstractModelFit","page":"API: Types","title":"Unfold.AbstractModelFit","text":"Abstract Type to report modelresults\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.BasisFunction","page":"API: Types","title":"Unfold.BasisFunction","text":"See FIRBasis for an examples\n\na BasisFunction should implement:\n\nkernel() # kernel(b::BasisFunction,sample) => returns the designmatrix for that event\nheight() # number of samples in continuous time, NaN if not defined\nwidth()  # number of coefficient columns (e.g. HRF 1 to 3, FIR=height(),except if interpolate=true )\ncolnames() # unique names of expanded columns\ntimes() # vector of times along expanded columns, length = height()\nname() # name of basisfunction\ncollabel() [default \"colname_basis\"] # name for coeftable\nshift_onset() [default 0]\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.DesignMatrixLinearModel","page":"API: Types","title":"Unfold.DesignMatrixLinearModel","text":"DesignMatrix\n\nType that keeps an Array of  formulas, designmatrices modelmatrix (Array or Array of Arrays in case of MixedModel) and events-dataframe\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.FIRBasis","page":"API: Types","title":"Unfold.FIRBasis","text":"Defines a FIRBasisfunction which can be called for each event, defining the time-expanded basis kernel\n\nmutable struct FIRBasis <: Unfold.BasisFunction\n\ntimes: vector of times along rows of kernel-output (in seconds)\nname: name of the event, should be the actual eventName in eventcolumn of the dataframes later\nshift_onset: by how many samples do we need to shift the event onsets? This number is determined by how many 'negative' timepoints the basisfunction defines\ninterpolate: should we linearly interpolate events not on full samples?\nscale_duration: should we scale kernel to the duration? If yes, with which method\n\n(tipp: most users would you want to call firbasis, not generate it manually)\n\nExamples\n\njulia>  b = FIRBasis(range(0,1,length=10),\"basisA\",-1)\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.LinearModelFit","page":"API: Types","title":"Unfold.LinearModelFit","text":"Contains the results of linearmodels (continuous and not)\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.TimeExpandedTerm","page":"API: Types","title":"Unfold.TimeExpandedTerm","text":"Object with a term and an applicable BasisFunction and a eventfield that are later passed to the basisfunction.\n\nstruct TimeExpandedTerm{T<:StatsModels.AbstractTerm} <: StatsModels.AbstractTerm\n\nterm: Term that the basis function is applied to. This is regularly called in other functions to get e.g. term-coefnames and timeexpand those\nbasisfunction: Kernel that determines what should happen to the designmatrix of the term\neventfields: Which fields of the event-table should be passed to the basisfunction.Important: The first entry has to be the event-latency in samples!\n\nExamples\n\njulia>  b = TimeExpandedTerm(term,kernel,[:latencyTR,:durationTR])\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.UnfoldLinearModel","page":"API: Types","title":"Unfold.UnfoldLinearModel","text":"Concrete type to implement an Mass-Univariate LinearModel. .design contains the formula + times dict .designmatrix contains a DesignMatrix modelfit is a Any container for the model results\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.UnfoldLinearModelContinuousTime","page":"API: Types","title":"Unfold.UnfoldLinearModelContinuousTime","text":"Concrete type to implement an deconvolution LinearModel. .design contains the formula + times dict .designmatrix contains a DesignMatrix modelfit is a Any container for the model results\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.UnfoldModel","page":"API: Types","title":"Unfold.UnfoldModel","text":"using Base: @deprecate_binding The main abstract model-type of the toolbox. E.g. UnfoldLinearModel is a concrete type of this\n\n\n\n\n\n","category":"type"},{"location":"generated/explanations/window_length/#Window-length-effects","page":"Window Length Effect","title":"Window length effects","text":"using Unfold, UnfoldSim\nusing CairoMakie, AlgebraOfGraphics, MakieThemes\nusing Random\nusing DataFrames, DataFramesMeta\nusing ColorSchemes, Colors\n\nimportant: Important\nFor analyzing real-world EEG data we recommend that researchers should â€” a priori â€” make an educated guess about the length of the underlying EEG activity and select this as their EW. This also suggests to use event windows with different sizes between events (as is possible with Unfold). Further, as can be seen below, when choosing longer time-windows the overfit is only of moderate size, thus we additionally recommend to generally err on the longer side, to not miss any important activity. \nFor a more in depth explanation on this, you can read our 2023 CCN paper: Skukies & Ehinger, 2023\n\nset_theme!(theme_ggthemr(:fresh))\n\nAs opposed to classical averaged ERPs overlap corrected regression ERPs can be influenced by the chosen window length: Long estimation windows might capture all relevant event-related activity, but might introduce artifacts due to overfit, short estimation windows might not overfit, but also might not capture all (overlapping) activity, and thereby introduce bias.\n\nThus a common question we get is, how to specify the length of the estimation windows.","category":"section"},{"location":"generated/explanations/window_length/#Init-functions","page":"Window Length Effect","title":"Init functions","text":"First we need a function that simulates some continous data; conviently we can use UnfoldSim for this\n\nfunction gen_data(rng, noiselevel, sfreq)\n    noise = PinkNoise(; noiselevel = noiselevel)\n\n    dat, evts = UnfoldSim.predef_eeg(\n        rng;\n        sfreq = sfreq,\n        p1 = (p100(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5, 0], Dict()),\n        n1 = (n170(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5, 0], Dict()),\n        p3 = (p300(; sfreq = sfreq), @formula(0 ~ 1 + continuous), [5, 0], Dict()),\n        n_repeats = 20,\n        noise = noise,\n    )\n    return dat, evts\nend;\nnothing #hide\n\nNext a convience function to calculate the estimates\n\nfunction calc_time_models(evts, dat, tWinList, sfreq)\n    mList = []\n    for twindow in tWinList\n        m = fit(\n            UnfoldModel,\n            [Any => (@formula(0 ~ 1), firbasis(twindow, sfreq))],\n            evts,\n            dat,\n        )\n        res = coeftable(m)\n        res.tWin .= string.(Ref(twindow[2]))\n        push!(mList, res)\n    end\n    return vcat(mList...)\nend;\nnothing #hide","category":"section"},{"location":"generated/explanations/window_length/#Init-variables","page":"Window Length Effect","title":"Init variables","text":"tWinList = [(-0.1, x) for x in [3, 2.5, 2, 1.5, 1, 0.5]]\nnoiselevel = 8.5\nsfreq = 250;\nnothing #hide","category":"section"},{"location":"generated/explanations/window_length/#Generate-data-and-calculate-estimates","page":"Window Length Effect","title":"Generate data and calculate estimates","text":"dat, evts = gen_data(MersenneTwister(2), noiselevel, sfreq);\n\nres = calc_time_models(evts, dat, tWinList, sfreq);\nnothing #hide\n\nWe also append some additional information to the results dataframe\n\nFor comparison lets also generate the ground truth of our data; this is a bit cumbersome and you don't have to care (too much) about it\n\ndat_gt, evts_gt = UnfoldSim.predef_eeg(;\n    p1 = (p100(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()),\n    sfreq = sfreq,\n    n1 = (n170(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()),\n    p3 = (p300(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()),\n    n_repeats = 1,\n    noiselevel = 0,\n    return_epoched = true,\n);\ntime_gt = range(0, length = length(dat_gt[:, 1]), step = 1 / sfreq)\nunique_event = unique(res.tWin)\ndf_gt = DataFrame(\n    tWin = reduce(vcat, fill.(unique_event, length(dat_gt[:, 1]))),\n    eventname = Any,\n    channel = repeat([1], length(dat_gt[:, 1]) * length(unique_event)),\n    coefname = reduce(\n        vcat,\n        fill(\"GroundTruth\", length(dat_gt[:, 1]) * length(unique_event)),\n    ),\n    estimate = repeat(dat_gt[:, 1], length(unique_event)),\n    group = reduce(vcat, fill(nothing, length(dat_gt[:, 1]) * length(unique_event))),\n    stderror = reduce(vcat, fill(nothing, length(dat_gt[:, 1]) * length(unique_event))),\n    time = repeat(time_gt, length(unique_event)),\n);\nnothing #hide\n\nAnd append ground truth to our results df\n\nres_gt = vcat(res, df_gt);\nnothing #hide","category":"section"},{"location":"generated/explanations/window_length/#Plot-results","page":"Window Length Effect","title":"Plot results","text":"Choose which data to plot\n\nh_t =\n    AlgebraOfGraphics.data(res) * mapping(\n        :time,\n        :estimate,\n        color = :tWin,\n        group = (:tWin, :coefname) => (x, y) -> string(x[2]) * y,\n    );\nnothing #hide\n\nWe use the following to plot some length indicator lines\n\nuntWin = unique(res_gt.tWin)\nsegDF = DataFrame(\n    :x => hcat(repeat([-0.1], length(untWin)), parse.(Float64, untWin))[:],\n    :y => repeat(reverse(1:length(untWin)), outer = 2),\n)\nsegDF.tWin .= \"0.0\"\nsegDF.tWin .= segDF.x[reverse(segDF.y .+ 6)]\nsegDF.y = segDF.y .* 0.2 .+ 6;\nnothing #hide\n\nLayer for indicator lines\n\nh_l =\n    AlgebraOfGraphics.data(@subset(segDF, :tWin .!= \"3.0\")) *\n    mapping(:x, :y, color = :tWin, group = :tWin => x -> string.(x));\nnothing #hide\n\nGround truth Layer\n\nh_gt =\n    AlgebraOfGraphics.data(df_gt) *\n    mapping(:time, :estimate, group = (:tWin, :coefname) => (x, y) -> string(x) * y) *\n    visual(Lines, linewidth = 5, color = Colors.Gray(0.6));\nnothing #hide\n\nAdd all visuals together and draw\n\nh1 =\n    h_gt + visual(Lines, colormap = get(ColorSchemes.Blues, 0.3:0.01:1.2)) * (h_l + h_t) |>\n    x -> draw(x, axis = (; xlabel = \"time [s]\", ylabel = \"estimate [a.u.]\"));\nnothing #hide\n\nAdd zero grid lines\n\nh1 = hlines!(current_axis(), [0], color = Colors.Gray(0.8));\nh2 = vlines!(current_axis(), [0], color = Colors.Gray(0.8));\ntranslate!(h1, 0, 0, -1);\ntranslate!(h2, 0, 0, -1);\nnothing #hide\n\nPlot figure\n\ncurrent_figure()\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"references/benchmarks/#Benchmarks","page":"Solver benchmarks","title":"Benchmarks","text":"We ran benchmarks on 2024-11-07 as described in ./benchmark/cuda/solver_comparison.jl. Given that some were run on a GPU, we cannot run them on continuous-integration online.\n\nimportant: Important\nAllocations are only CPU allocations - GPU allocations were not counted.\nSolvers other than default_multi are currently NOT multi-threaded\nSolvers other than default_multi and krylov_gpu solve XXb = Xy instead of Xb=y directly. They are likely less accurate, but should be faster for multi-channel data, as we can precalulate cholesky, qr or similar & the to-be-inverted matrix is much smaller.","category":"section"},{"location":"references/benchmarks/#Small-Model","page":"Solver benchmarks","title":"Small Model","text":"n_channels = 1,\nsfreq = 10,\nn_splines = 4,\nn_repeats = 10;\n\ngpu method el_type time GB percent_X_filled sizeDesign n_channels overlap comment\ntrue cholesky Float64   0.068 (1190, 130) 1 (0.2, 0.2) PosDefException(-1)\nfalse cholesky Float64 0.00056 0.00069 0.068 (1190, 130) 1 (0.2, 0.2) \ntrue intern Float64 0.00088 0.00017 0.068 (1190, 130) 1 (0.2, 0.2) \nfalse intern Float64 0.0011 0.00069 0.068 (1190, 130) 1 (0.2, 0.2) \ntrue qr Float64 0.0013 0.00019 0.068 (1190, 130) 1 (0.2, 0.2) \nfalse cg Float64 0.0015 0.00057 0.068 (1190, 130) 1 (0.2, 0.2) \nfalse default_multi Float64 0.0017 0.00016 0.068 (1190, 130) 1 (0.2, 0.2) \nfalse qr Float64 0.002 0.00076 0.068 (1190, 130) 1 (0.2, 0.2) \ntrue cg Float64 0.0054 0.00056 0.068 (1190, 130) 1 (0.2, 0.2) \ntrue pinv Float64 0.0054 0.00032 0.068 (1190, 130) 1 (0.2, 0.2) \nfalse pinv Float64 0.016 0.0016 0.068 (1190, 130) 1 (0.2, 0.2) \ntrue krylov_gpu Float64 0.032 0.0013 0.068 (1190, 130) 1 (0.2, 0.2) ","category":"section"},{"location":"references/benchmarks/#small-to-midsize:-multi-channel","page":"Solver benchmarks","title":"small-to-midsize: multi-channel","text":"n_channels = 128,\nsfreq = 100,\nn_splines = 4,\nn_repeats = 200;","category":"section"},{"location":"references/benchmarks/#Float64","page":"Solver benchmarks","title":"Float64","text":"gpu method el_type time GB percent_X_filled sizeDesign n_channels overlap comment\ntrue cholesky Float64   0.0068 (239522, 1210) 128 (0.2, 0.2) PosDefException(-1)\ntrue qr Float64 0.38 0.25 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue pinv Float64 0.42 0.26 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue intern Float64 0.7 0.25 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue cg Float64 1.2 0.32 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse cholesky Float64 1.5 0.31 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse qr Float64 1.7 0.31 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse cg Float64 2.0 0.3 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse pinv Float64 2.1 0.38 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue krylov_gpu Float64 5.9 0.4 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse default_multi Float64 13.0 1.2 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse intern Float64 13.0 1.7 0.0068 (239522, 1210) 128 (0.2, 0.2) ","category":"section"},{"location":"references/benchmarks/#Float32","page":"Solver benchmarks","title":"Float32","text":"gpu method el_type time GB percent_X_filled sizeDesign n_channels overlap comment\ntrue cholesky Float32   0.0068 (239522, 1210) 128 (0.2, 0.2) PosDefException(-1)\ntrue krylov_gpu Float32   0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue pinv Float32 0.39 0.25 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue qr Float32 0.62 0.24 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue intern Float32 0.69 0.24 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue cg Float32 1.2 0.31 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse cholesky Float32 1.2 0.17 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse cg Float32 1.3 0.16 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse qr Float32 1.4 0.17 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse pinv Float32 1.6 0.21 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse intern Float32 13.0 0.86 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse default_multi Float32 13.0 0.97 0.0068 (239522, 1210) 128 (0.2, 0.2) ","category":"section"},{"location":"references/benchmarks/#large,-realistic-model","page":"Solver benchmarks","title":"large, realistic model","text":"    n_channels = 128,\n    sfreq = 500,\n    n_splines = (4, 4),\n    n_repeats = 500,\n\ngpu method el_type time GB percent_X_filled sizeDesign n_channels overlap comment\ntrue cholesky Float64   0.0015 (3001479, 9616) 128 (0.2, 0.2) PosDefException(-1)\nfalse cholesky Float64   0.0015 (3001479, 9616) 128 (0.2, 0.2) PosDefException(2760)\nfalse intern Float64   0.0015 (3001479, 9616) 128 (0.2, 0.2) SingularException(9599)\ntrue cg Float64 9.3 3.6 0.0015 (3001479, 9616) 128 (0.2, 0.2) \ntrue qr Float64 11.0 3.5 0.0015 (3001479, 9616) 128 (0.2, 0.2) \ntrue intern Float64 13.0 3.5 0.0015 (3001479, 9616) 128 (0.2, 0.2) \nfalse qr Float64 80.0 6.3 0.0015 (3001479, 9616) 128 (0.2, 0.2) \ntrue pinv Float64 80.0 4.2 0.0015 (3001479, 9616) 128 (0.2, 0.2) \ntrue krylov_gpu Float64 107.0 3.9 0.0015 (3001479, 9616) 128 (0.2, 0.2) \nfalse default_multi Float64 500.0 15.0 0.0015 (3001479, 9616) 128 (0.2, 0.2) \nfalse pinv Float64 520.0 11.0 0.0015 (3001479, 9616) 128 (0.2, 0.2) \nfalse cg Float64 939.0 5.7 0.0015 (3001479, 9616) 128 (0.2, 0.2) ","category":"section"},{"location":"#Unfold.jl-Documentation","page":"Unfold.jl Documentation","title":"Unfold.jl Documentation","text":"Welcome to Unfold.jl: a Julia Package for regression and event-based time series analysis, with a focus on regression ERPs for EEG analysis. The modular approach allows for easy modification to other context, like iEEG, pupil dilation, fMRI etc. - while maintaining the speed of Julia!\n\n<div style=\"width:100%; margin: auto;\">\n\n<img src=\"https://cloud.s-ccs.de/public.php/dav/files/nDQXYteFgFXrAjj/\" style=\"width:45%;\">\n<img src=\"https://cloud.s-ccs.de/public.php/dav/files/gAAaaRdSebCY4fd\"  style=\"width:45%;\">\n\n</div>","category":"section"},{"location":"#Key-features","page":"Unfold.jl Documentation","title":"Key features","text":"Overlap correction: Multiple ways to model overlap between temporally close events\nðŸ“ˆ Regression ERPs: Fit linear and non-linear predictors, mass univariate models, define contrasts, calculate marginal effects\nðŸ§  Intuitive: Easy to specify models (w~i+lcox formulas), easy to get ðŸ§¹ tidy results\nâš¡ Fast & modular: Many solvers, GPU support, easily extensible\nðŸŒ Ecosystem: A diverse ecosystem allows for mixed-models, decoding, statistics, plotting and simulation","category":"section"},{"location":"#Installation","page":"Unfold.jl Documentation","title":"Installation","text":"julia> using Pkg; Pkg.add(\"Unfold\")\n\nFor more detailed instructions please refer to Installing Julia & Unfold.jl.","category":"section"},{"location":"#Quick-start","page":"Unfold.jl Documentation","title":"Quick start","text":"There are four main model types\n\nTimeexpansion No, Mixed No  : fit(UnfoldModel, [Any=>(f, -0.1:0.01:0.5)], evts, data_epoch)\nTimeexpansion Yes, Mixed No : fit(UnfoldModel, [Any=>(f, basisfunction)], evts, data)\nTimeexpansion No, Mixed Yes : fit(UnfoldModel, [Any=>(fLMM, -0.1:0.01:0.5)], evts, data_epoch)\nTimeexpansion Yes, Mixed Yes: fit(UnfoldModel, [Any=>(fLMM, basisfunction)], evts, data)","category":"section"},{"location":"#Usage-example","page":"Unfold.jl Documentation","title":"Usage example","text":"","category":"section"},{"location":"#rERP-model","page":"Unfold.jl Documentation","title":"rERP model","text":"using Unfold\nusing UnfoldSim\ndata, evts = UnfoldSim.predef_eeg()\n\nf = @formula 0 ~ 1 + condition\nbasisfunction = firbasis(Ï„ = (-0.1,0.5), sfreq = 100)\nfit(UnfoldModel, [Any=>(f, basisfunction)], evts, data)\nnothing #hide","category":"section"},{"location":"#MixedModels","page":"Unfold.jl Documentation","title":"MixedModels","text":"It is also possible to fit Linear Mixed Models using the sister-package UnfoldMixedModels.jl\n\nusing UnfoldMixedModels\nusing UnfoldSim\ndata, evts = UnfoldSim.predef_eeg(10;return_epoched=true) # 10 subjects\ndata = reshape(data,size(data,1),:) # concatenate subjects\n\ntimes = range(-0.1,0.5,size(data,1)) # arbitrary time-vector\n\nfLMM = @formula 0 ~ 1 + condition + (1|subject) + (1|item)\nfit(UnfoldModel, [Any=>(f, times)], evts, data)\nnothing #hide","category":"section"},{"location":"#Where-to-start:-Learning-roadmap","page":"Unfold.jl Documentation","title":"Where to start: Learning roadmap","text":"","category":"section"},{"location":"#1.-First-step","page":"Unfold.jl Documentation","title":"1. First step","text":"ðŸ“Œ Goal: First run a mass-univariate analysis, similar to ERPs. Then add the overlap correction. Also very common is to have multiple-events (Stimulus, Response, Fixations etc.)\nðŸ”— first the mass-univariate approach - then theoverlap-correction tutorial -  finally multiple events","category":"section"},{"location":"#2.-Intermediate-topics","page":"Unfold.jl Documentation","title":"2. Intermediate topics","text":"ðŸ“Œ Goal: Next familiarize yoursel with marginal effects, and potentially non-linear spline modelling. Defining contrasts can also be helpful \nðŸ”—  marginal effects - non linear effects - contrast coding","category":"section"},{"location":"#3.-Advanced-topics","page":"Unfold.jl Documentation","title":"3. Advanced topics","text":"ðŸ“Œ Goal: There are a lot of advanced topics in Unfold.jl, learn how to use the GPU or outlier-robust solvers, or define your own solver \nðŸ”— GPU and robust models - solver definition","category":"section"},{"location":"#Statement-of-need","page":"Unfold.jl Documentation","title":"Statement of need","text":"<!---\nNote: The statement of need is also used in the `README.md`. Make sure that they are synchronized.\n-->","category":"section"},{"location":"generated/HowTo/eventhandling/#eventhandling","page":"Tools to modify/transform/translate events","title":"Eventhandling","text":"This tutorial introduces some helpful scripts to copy information between events - something that commonly happens.","category":"section"},{"location":"generated/HowTo/eventhandling/#Setup-things","page":"Tools to modify/transform/translate events","title":"Setup things","text":"Setup some packages\n\nusing Unfold\nusing DataFrames\n\nLet's start with a typical event structure you might get from a stimulus - response paradigm. The condition is only encoded in the stimulus, the reaction time only in the RT-event. Also, there is a nasty \"break\" event in between, making our task a bit harder\n\nevts = DataFrame(\n    :event => [\"S\", \"R\", \"break\", \"S\", \"R\", \"S\", \"R\"],\n    :latency => [1, 3, 4, 6, 7, 10, 12],\n    :condition => [\"face\", missing, missing, \"bike\", missing, \"bike\", missing],\n    :rt => [missing, 0.3, missing, missing, 0.4, missing, 0.5],\n)\n\nThe quest is now to copy some info from S to R and others from R to preceeding S\n\nevts_new = copy_eventinfo(evts, \"S\" => \"R\", :condition; search_fun = :forward)\n\nIn order to copy the RT, we want to have a \"lookback\", that is the preceeding \"S\" shuold be used\n\ncopy_eventinfo!(evts_new, \"R\" => \"S\", \"rt\"; search_fun = :backward)\n\nOther convenient pattern is to copy to a new column - useful to test the copying behavior\n\ncopy_eventinfo!(evts_new, \"R\" => \"S\", \"rt\" => \"newcolumn\"; search_fun = :backward)\n\nYou can also use \"standard\" DataFrames patterns e.g.\n\nfor grp in groupby(evts_new, :event)\n    grp.newcolumn .= grp.event[1] .== \"S\" ? \"STIMULUS\" : \"OTHER\"\nend\nevts_new\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
