var documenterSearchIndex = {"docs":
[{"location":"HowTo/multiple_events/#How-to-model-multiple-events","page":"Overlap: Multiple events","title":"How to model multiple events","text":"","category":"section"},{"location":"HowTo/multiple_events/","page":"Overlap: Multiple events","title":"Overlap: Multiple events","text":"When dealing with overlapping data, it is often necessary to model multiple eventtypes (e.g. fixations, stimuli, responses).","category":"page"},{"location":"HowTo/multiple_events/#Load-Example-Data","page":"Overlap: Multiple events","title":"Load Example Data","text":"","category":"section"},{"location":"HowTo/multiple_events/","page":"Overlap: Multiple events","title":"Overlap: Multiple events","text":"using Unfold\nusing UnfoldMakie, CairoMakie\nusing DataFrames\nusing StatsModels\nusing MixedModels\nusing DisplayAs # hide\n\ninclude(joinpath(dirname(pathof(Unfold)), \"../test/test_utilities.jl\")) # to load data\ndat, evts = loadtestdata(\"test_case_4b\");\n\nevts[1:5,:]","category":"page"},{"location":"HowTo/multiple_events/","page":"Overlap: Multiple events","title":"Overlap: Multiple events","text":"The type column of table evts contains two conditions: eventAandeventB(if your eventstypes are specified in a different column, you need to define the keywordargumenteventcolumnin thefit` command below)","category":"page"},{"location":"HowTo/multiple_events/#Specify-formulas-and-basisfunctions","page":"Overlap: Multiple events","title":"Specify formulas and basisfunctions","text":"","category":"section"},{"location":"HowTo/multiple_events/","page":"Overlap: Multiple events","title":"Overlap: Multiple events","text":"\nbf1 = firbasis(τ = (-0.4, 0.8), sfreq = 50)\nbf2 = firbasis(τ = (-0.2, 1.2), sfreq = 50)\nbf2|> DisplayAs.withcontext(:is_pluto=>true) # hide","category":"page"},{"location":"HowTo/multiple_events/","page":"Overlap: Multiple events","title":"Overlap: Multiple events","text":"For each event, a basis function and formula must be specified. The same basis and formulas may be used.","category":"page"},{"location":"HowTo/multiple_events/","page":"Overlap: Multiple events","title":"Overlap: Multiple events","text":"f  = @formula 0 ~ 1","category":"page"},{"location":"HowTo/multiple_events/","page":"Overlap: Multiple events","title":"Overlap: Multiple events","text":"For each event, we must specify the formula and basis function to be used. ","category":"page"},{"location":"HowTo/multiple_events/","page":"Overlap: Multiple events","title":"Overlap: Multiple events","text":"\nbfDict = [ \"eventA\" => (f, bf1),\n           \"eventB\" => (f, bf2) ]\n\nbfDict |> DisplayAs.withcontext(:is_pluto=>true) # hide","category":"page"},{"location":"HowTo/multiple_events/","page":"Overlap: Multiple events","title":"Overlap: Multiple events","text":"Finally, fitting & plotting works the same way as always","category":"page"},{"location":"HowTo/multiple_events/","page":"Overlap: Multiple events","title":"Overlap: Multiple events","text":"m = Unfold.fit(\n    UnfoldModel,\n    bfDict,\n    evts,\n    dat,\n    solver = (x, y) -> Unfold.solver_default(x, y; stderror = true),\n    eventcolumn = \"type\",\n)\nresults = coeftable(m)\nplot_erp(results; stderror = true, mapping = (; col = :eventname))","category":"page"},{"location":"HowTo/pymne/#Loading-Data-into-Unfold","page":"Import EEG with 🐍 PyMNE.jl","title":"Loading Data into Unfold","text":"","category":"section"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"Unfold is generally agnostic to how you load your data. You only require a Matrix (channel x time) or 3D-Array(channel x time x epochs) and an event-dataframe.","category":"page"},{"location":"HowTo/pymne/#Setup","page":"Import EEG with 🐍 PyMNE.jl","title":"Setup","text":"","category":"section"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"using Unfold\nusing UnfoldMakie,CairoMakie\nusing PyMNE\nusing DataFrames","category":"page"},{"location":"HowTo/pymne/#MNE-Demo-Dataset","page":"Import EEG with 🐍 PyMNE.jl","title":"MNE Demo Dataset","text":"","category":"section"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"The easiest way to showcase this is to simply use a demo-dataset from MNE.","category":"page"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"limo_epochs = PyMNE.datasets.limo.load_data(subject=1,path=\"~/MNE/DATA\",update_path=false)\nlimo_epochs","category":"page"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"Now we can fit a simple Unfold model to it. ","category":"page"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"First extract the data & convert it to Julia/Unfold requirements","category":"page"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"data = limo_epochs.get_data(picks=\"B11\")\ndata  = permutedims(data,[2,3,1]) # get into ch x times x epochs\n\nfunction convert_pandas(df_pd)\n      df= DataFrame()\n    for col in df_pd.columns\n        df[!, col] = getproperty(df_pd, col).values\n    end\n    return df\nend\nevents = convert_pandas(limo_epochs.metadata)\nrename!(events,2=>:coherence) # negative signs in formulas are not good ;)\nevents.face = string.(events.face) # ugly names, but fast\n","category":"page"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"Next fit an Unfold Model","category":"page"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"uf = fit(UnfoldModel,[Any=>(@formula(0~face+coherence),Float64.(limo_epochs.times))],events,data)\nresults = coeftable(uf)","category":"page"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"plot_results(results)","category":"page"},{"location":"HowTo/pymne/#Read-some-of-your-own-data","page":"Import EEG with 🐍 PyMNE.jl","title":"Read some of your own data","text":"","category":"section"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"We can make use of all PyMNE importer functions to load the data. Try it for your own data! Get starting with Unfold in no-time!","category":"page"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"#eeglabdata = PyMNE.io.read_raw_eeglab(\"pathToEEGLabSet.set\")","category":"page"},{"location":"HowTo/pymne/#Contribute?","page":"Import EEG with 🐍 PyMNE.jl","title":"Contribute?","text":"","category":"section"},{"location":"HowTo/pymne/","page":"Import EEG with 🐍 PyMNE.jl","title":"Import EEG with 🐍 PyMNE.jl","text":"Some extra conversions are needed to import the data from PyMNE to Unfold (as shown above). We could try putting these in a wrapper function - do you want to tackle this challenge? Would be a great first contribution to the toolbox :-)","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"EditURL = \"../../../literate/HowTo/juliacall_unfold.jl\"","category":"page"},{"location":"generated/HowTo/juliacall_unfold/#Using-Unfold.jl-from-Python","page":"🐍 Calling Unfold.jl directly from Python","title":"Using Unfold.jl from Python","text":"","category":"section"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"it is straight forward to call Unfold from Python using JuliaCall.","category":"page"},{"location":"generated/HowTo/juliacall_unfold/#Quick-start","page":"🐍 Calling Unfold.jl directly from Python","title":"Quick start","text":"","category":"section"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Create a Python environment and install JuliaCall.","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"pip install juliacall","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Create a Julia environment and install Unfold","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"# Import the Julia package manager\nfrom juliacall import Pkg as jlPkg\n\n# Activate the environment in the current folder\njlPkg.activate(\".\")\n\n# Install Unfold (in the activated environment)\njlPkg.add(\"Unfold\")","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Import Julia's main module and Unfold","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"# Import Julia's Main module\nfrom juliacall import Main as jl\n\n# Import Unfold\n# The function seval() can be used to evaluate a piece of Julia code given as a string\njl.seval(\"using Unfold\")\nUnfold = jl.Unfold # simplify name","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Now you can use all Unfold functions as for example","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"dummy_model = Unfold.UnfoldLinearModel(jl.Dict())","category":"page"},{"location":"generated/HowTo/juliacall_unfold/#Example:-Unfold-model-fitting-from-Python","page":"🐍 Calling Unfold.jl directly from Python","title":"Example: Unfold model fitting from Python","text":"","category":"section"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"In this notebook, you can find a more detailed example of how to use Unfold from Python to load data, fit an Unfold model and visualise the results in Python.","category":"page"},{"location":"generated/HowTo/juliacall_unfold/#Important-limitations","page":"🐍 Calling Unfold.jl directly from Python","title":"Important limitations","text":"","category":"section"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Python doesnt not offer the full expressions that are available in Julia. So there are some things you need to give special attention:","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"@formula: we havent found a way to call macros yet, even though we think it should be possible. For now please use f = jl.seval(\"@formula(0~1+my+cool+design)\"). Later versions might support something like f = @formula(\"0~1+my+cool+design)\" directly","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Specifying the design: Since Unfold 0.7 we officially switched to the","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"[\"eventtypeA\"=>(formula,basisfunction),\n\"eventtypeB\"=>(otherformula,otherbasisfunction)]","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Array-based syntax, from a Dict-based syntax. Unfortunately, => (a pair) is not supported in Python and one needs to do some rewriting:","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"jl.convert(jl.Pair,(formula,basisfunction))","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"which makes the code less readable. We are thinking of ways to remedy this - but right now there is now way around. For now, it is also possible to use the old syntax e.g. in python","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"{\"eventtypeA\"=>(formula,basisfunction),\"eventtypeB\"=>(otherformula,otherbasisfunction)}","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"which is clearly easier to read :)","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"UnfoldSim.design: we need a Dict with a Symbol , one has to do something like condition_dict_jl = {convert(jl.Symbol,\"condA\"):[\"car\", \"face\"]} to do so. We will [try to allow strings}(https://github.com/unfoldtoolbox/UnfoldSim.jl/issues/96) here as well, removing this constraint.","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"When preprocessing your raw data through MNE Python, take the following into consideration: The Raw object contains the first_samp attribute which is an integer representing the number of time samples that passed between the onset of the hardware acquisition system and the time when data recording started. The Raw data doesn't include these time samples, meaning that the first sample is the beginning of the data aquisition. From the Raw object you can obtain an events array from the annotations through mne.eventsfromannotations(). The events array, however, does include firstsamp, meaning that the annotated events in events array don't match the Raw object anymore. Alternatively, it might be easier to convert the annotations to a pandas dataframe directly (`todataframe()`), or even better, load the \"*events.tsv\" from a BIDS dataset. In the latter case, all columns will be preserved, which MNE's read_annotation drops.","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"This page was generated using Literate.jl.","category":"page"},{"location":"references/functions/","page":"API: Functions","title":"API: Functions","text":"Modules = [Unfold]\nOrder   = [:function]","category":"page"},{"location":"references/functions/#Effects.effects-Union{Tuple{T}, Tuple{AbstractDict, T}} where T<:UnfoldModel","page":"API: Functions","title":"Effects.effects","text":"effects(design::AbstractDict, model::UnfoldModel; typical = mean)\n\nCalculates marginal effects for all term combinations in design.\n\nImplementation based on Effects.jl package; likely could repackage in UnfoldEffects.jl; somebody wants to do it? This would make it easier to cross-maintain it to changes/bug fixes in the Effects.jl package. design is a dictionary containing those predictors (as keys) with levels (as values), that you want to evaluate. The typical refers to the value, which other predictors that are not specified in the dictionary, should take on.\n\nFor MixedModels, the returned effects are based on the \"typical\" subject, i.e. all random effects are put to 0.\n\nExample\n\n julia> f = @formula 0 ~ categoricalA + continuousA + continuousB\n julia> uf = fit(UnfoldModel, (Any => (f, times)), data, events)\n julia> d = Dict(:categorical => [\"levelA\", \"levelB\"], :continuous => [-2, 0, 2])\n julia> effects(d, uf)\n\nwill result in 6 predicted values: A/-2, A/0, A/2, B/-2, B/0, B/2.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#FileIO.load-Tuple{Any, Type{<:UnfoldModel}}","page":"API: Functions","title":"FileIO.load","text":"FileIO.load(file, ::Type{<:UnfoldModel}; generate_Xs=true)\n\nLoad UnfoldModel from a .jld2 file. \n\nBy default, the designmatrix is reconstructed. If it is not needed set generate_Xs=false which improves time-efficiency.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#FileIO.save-Union{Tuple{T}, Tuple{Any, T}} where T<:UnfoldModel","page":"API: Functions","title":"FileIO.save","text":"FileIO.save(file, uf::T; compress=false) where {T<:UnfoldModel}\n\nSave UnfoldModel in a (by default uncompressed) .jld2 file.\n\nFor memory efficiency the designmatrix is set to missing. If needed, it can be reconstructed when loading the model.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.coefnames-Tuple{Unfold.TimeExpandedTerm}","page":"API: Functions","title":"StatsAPI.coefnames","text":"coefnames(term)\n\n\ncoefnames of a TimeExpandedTerm concatenates the basis-function name with the kronecker product of the term name and the basis-function colnames. Separator is ' : ' Some examples for a firbasis:         basis313 : (Intercept) : 0.1         basis313 : (Intercept) : 0.2         basis_313 : (Intercept) : 0.3         ...\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.fit-Union{Tuple{T}, Tuple{Type{T}, StatsModels.FormulaTerm, DataFrames.AbstractDataFrame, AbstractArray, Union{Unfold.BasisFunction, AbstractArray}}} where T<:UnfoldModel","page":"API: Functions","title":"StatsAPI.fit","text":"fit(type::UnfoldModel,d::Vector{Pair},tbl::AbstractDataFrame,data::Array)\nfit(type::UnfoldModel,f::FormulaTerm,tbl::AbstractDataFrame,data::Array{T,3},times)\nfit(type::UnfoldModel,f::FormulaTerm,tbl::AbstractDataFrame,data::Array{T,2},basisfunction::BasisFunction)\n\nGenerates Designmatrix & fits model, either mass-univariate (one model per epoched-timepoint) or time-expanded (modeling linear overlap).\n\neventcolumn (Symbol/String, default :event) - the column in tbl::AbstractDataFrame to differentiate the basisfunctions as defined in d::Vector{Pair}\nshow_progress (Bool, default true) - show Progress via ProgressMeter\n\nIf a Vector[Pairs] is provided, it has to have one of the following structures: [:A=>(f,basisfunction), :B=>(f2,bf2)] - for deconvolutin analyses (use Any=>(f,bf) to match all rows of tbl in one basis functins) [:A=>(f,timesvector), :B=>(f2,timesvector)] - for mass univariate analyses. If multiple rERPs are calculated at the same time, the timesvectors must be the same\n\nNotes\n\nThe type can be specified directly as well e.g. fit(type::UnfoldLinearModel) instead of inferred\nThe data is reshaped if it is missing one dimension to have the first dimesion then 1 \"Channel\".\n\nExamples\n\nMass Univariate Linear\n\njulia> data,evts = loadtestdata(\"testCase1\")\njulia> data_r = reshape(data,(1,:))\njulia> data_e,times = Unfold.epoch(data=data_r,tbl=evts,τ=(-1.,1.9),sfreq=10) # cut the data into epochs. data_e is now ch x times x epoch\n\njulia> f  = @formula 0~1+continuousA+continuousB # 1\njulia> model = fit(UnfoldModel,f,evts,data_e,times)\n\nTimexpanded Univariate Linear\n\njulia> basisfunction = firbasis(τ=(-1,1),sfreq=10,name=\"A\")\njulia> model = fit(UnfoldModel,[Any=>(f,basisfunction],evts,data_r)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.modelmatrix-Tuple{UnfoldLinearModel, Any}","page":"API: Functions","title":"StatsAPI.modelmatrix","text":"modelmatrix(uf::UnfoldLinearModel)\n\nreturns the modelmatrix of the model. Concatenates them, except in the MassUnivariate cases, where a vector of modelmatrices is return\n\nCompare with modelmatrices which returns a vector of modelmatrices, one per event\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.predict-Tuple{Any, Vector{<:StatsModels.FormulaTerm}, Vector{<:DataFrames.DataFrame}}","page":"API: Functions","title":"StatsAPI.predict","text":"function predict(\n    uf,\n    f::Vector{<:FormulaTerm},\n    evts::Vector{<:DataFrame};\n    overlap = true,\n    kwargs...\n)\n\nReturns a predicted (\"y_hat = X*b\") Array. \n\nuf is an <:UnfoldModel\nf is a (vector of) formulas, typically Unfold.formulas(uf), but formulas can be modified e.g. by effects.\nevts is a (vector of) events, can be Unfold.events(uf) to return the (possibly continuous-time) predictions of the model. Can be a custom even\n\nkwargs:\n\nif overlap = true (default), overlap based on the latency column of 'evtswill be simulated, or in the case of!ContinuousTimeTraitjust X*coef is returned.  ifoverlap = false, returns predictions without overlap (models withContinuousTimeTrait(=> with basisfunction / deconvolution) only), viapredictnooverlap`\n\nif keep_basis or exclude_basis is defined, then predict_partial_overlap is called, which allows to selective introduce overlap based on specified (or excluded respective) events/basisfunctions\n\nepoch_to and  epoch_timewindow currently only defined for partialoverlap, calculated (partial) overlap controlled predictions, but returns them at the specified `epochatevent, with the timesepoch_timewindowin samples.eventcolumncan be specified as well if different from the defaultevent`\n\nHint: all vectors can be \"single\" types, and will be containered in a vector\n\nOutput\n\nIf overlap=false, returns a 3D-Array\nIf overlap=true and epoch_to=nothing (default), returns a 2D-array\nIf overlap=true and epoch_to!=nothing, returns a 3D array\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsModels.modelcols-Tuple{Unfold.TimeExpandedTerm, Any}","page":"API: Functions","title":"StatsModels.modelcols","text":"modelcols(term, tbl)\n\n\ncalculates the actual designmatrix for a timeexpandedterm. Multiple dispatch on StatsModels.modelcols\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold._modelcols-Tuple{StatsModels.FormulaTerm, Any}","page":"API: Functions","title":"Unfold._modelcols","text":"_modelcols(form::FormulaTerm, events)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold._modelcols-Tuple{Vector, Vector}","page":"API: Functions","title":"Unfold._modelcols","text":"_modelcols(forms::Vector,events::Vector)\n\nA wrapper around StatsModels.modelcols that is only needed for easy multiple dispatch\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.apply_basisfunction-Tuple{Any, Unfold.BasisFunction, Any, Any}","page":"API: Functions","title":"Unfold.apply_basisfunction","text":"apply_basisfunction(\n    form,\n    basisfunction,\n    eventfields,\n    eventname\n)\n\n\ntimeexpand the rhs-term of the formula with the basisfunction\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.combine_yhat!-Union{Tuple{T}, Tuple{Vector{<:Array{T}}, Array{T}}} where T","page":"API: Functions","title":"Unfold.combine_yhat!","text":"combine_yhat(list,single)\n\ncombines single into list, if either list or single contains missing, automatically casts the respective counter-part to allow missings as well\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.designmatrix-Tuple{Any, Any, Any}","page":"API: Functions","title":"Unfold.designmatrix","text":"designmatrix(type, f, tbl; kwargs...)\n\ncall without basis function, continue with basisfunction = nothing\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.designmatrix-Tuple{Type{<:UnfoldModel}, Union{Tuple, StatsModels.FormulaTerm}, Any, Any}","page":"API: Functions","title":"Unfold.designmatrix","text":"designmatrix(\n    unfoldmodeltype,\n    f,\n    tbl,\n    basisfunction;\n    contrasts,\n    eventname,\n    kwargs...\n)\n\n\ndesignmatrix(type, f, tbl; kwargs...) Return a DesignMatrix used to fit the models.\n\nArguments\n\ntype::UnfoldModel\nf::FormulaTerm: Formula to be used in this designmatrix\ntbl: Events (usually a data frame) to be modelled\nbasisfunction::BasisFunction: basisfunction to be used in modeling (if specified)\ncontrasts::Dict: (optional) contrast to be applied to formula\neventfields::Array: (optional) Array of symbols which are passed to basisfunction event-wise. \n\nFirst field of array always defines eventonset in samples. Default is [:latency]\n\nExamples\n\njulia>  designmatrix(UnfoldLinearModelContinuousTime,Dict(Any=>(f,basisfunction1),tbl)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.designmatrix-Tuple{UnfoldModel, Any}","page":"API: Functions","title":"Unfold.designmatrix","text":"designmatrix(\n    uf::UnfoldModel,\n    tbl;\n    eventcolumn = :event,\n    contrasts = Dict{Symbol,Any}(),\n    kwargs...,\n\nMain function, generates the designmatrix, returns a list of <:AbstractDesignMatrix\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.drop_missing_epochs-Union{Tuple{T}, Tuple{Any, AbstractArray{T, 3}}} where T","page":"API: Functions","title":"Unfold.drop_missing_epochs","text":"[X,y] = drop_missing_epochs(X, y::Array)\n\nHelper function to remove epochs of y that contain missings. Drops them from both X and  y. Often used in combination with Unfold.epoch\n\nX can be anything that has two dimensions (Matrix, DataFrame etc)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.empty_modelmatrix-Tuple{AbstractDesignMatrix}","page":"API: Functions","title":"Unfold.empty_modelmatrix","text":"empty_modelmatrix(d::AbstractDesignMatrix)\n\nreturns an empty modelmatrix of the type DesignMatrix type of d\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.epoch-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Any}} where T<:Union{Missing, Number}","page":"API: Functions","title":"Unfold.epoch","text":"epoch(data::Array{T,1},evts::DataFrame,τ::Tuple/Vector,sfreq;kwargs...,\n\nBasic function to epoch data; all input also available as kwargs.\n\nAdditional kwarg: eventtime=:latency, which defines the column in evts that is used to cut the data (in samples). For uneven sample-times we use round()`\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.equalize_size-Union{Tuple{T}, Tuple{AbstractMatrix, AbstractMatrix{T}}} where T<:(Union{Missing, var\"#s21\"} where var\"#s21\"<:Number)","page":"API: Functions","title":"Unfold.equalize_size","text":"equalize_size(X, data)\n\n\nEquates the length of data and designmatrix by cutting the shorter one\n\nThe reason we need this is because when generating the designmatrix, we do not know how long the data actually are. We only assume that event-latencies are synchronized with the data\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.firbasis","page":"API: Functions","title":"Unfold.firbasis","text":"firbasis(τ, sfreq; ...)\nfirbasis(τ, sfreq, name; interpolate)\n\n\nGenerate a sparse FIR basis around the τ timevector at sampling rate sfreq. This is useful if you cannot make any assumptions on the shape of the event responses. If unrounded events are supplied, they are split between samples. E.g. event-latency = 1.2 will result in a \"0.8\" and a \"0.2\" entry.\n\nkeyword arguments\n\ninterpolate (Bool, default false): if true, interpolates events between samples linearly. This results in predict functions to return a trailling 0\n\nExamples\n\nGenerate a FIR basis function from -0.1s to 0.3s at 100Hz\n\njulia>  f = firbasis([-0.1,0.3],100)\n\nEvaluate at an event occuring at sample 103.3\n\njulia>  f(103.3)\n\n\n\n\n\n","category":"function"},{"location":"references/functions/#Unfold.firkernel-Tuple{Any, Any}","page":"API: Functions","title":"Unfold.firkernel","text":"firkernel(e, times; interpolate)\n\n\nCalculate a sparse firbasis\n\nExamples\n\njulia>  f = firkernel(103.3,range(-0.1,step=0.01,stop=0.31))\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.formulas-Tuple{Vector{<:Pair}}","page":"API: Functions","title":"Unfold.formulas","text":"formulas(design::Vector{<:Pair})\n\nreturns vector of formulas, no schema has been applied (those formulas never saw the data). Also no timeexpansion has been applied (in the case of timecontinuous models)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.get_basis_colnames-Tuple{AbstractArray{<:StatsModels.FormulaTerm}}","page":"API: Functions","title":"Unfold.get_basis_colnames","text":"get_basis_colnames(m)\nget_basis_colnames(formulas)\n\nreturns list of colnames - e.g. times for firbasis.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.get_basis_indices-Tuple{Any, Vector}","page":"API: Functions","title":"Unfold.get_basis_indices","text":"get_basis_indices(uf, basisnames::Vector)\n\nreturns a boolean vector with length spanning all coefficients, which coefficient is defined by basisnames (vector of names)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.get_basis_names-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T}} where T<:UnfoldModel","page":"API: Functions","title":"Unfold.get_basis_names","text":"get_basisnames(model::UnfoldModel)\n\nReturn the basisnames for all predictor terms as a vector.\n\nThe returned vector contains the name of the event type/basis, repeated by their actual coefficient number (after StatsModels.apply_schema / timeexpansion). If a model has more than one event type (e.g. stimulus and fixation), the vectors are concatenated.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.hrfbasis-Tuple{Float64}","page":"API: Functions","title":"Unfold.hrfbasis","text":"hrfbasis(TR; parameters, name)\n\n\nGenerate a Hemodynamic-Response-Functio (HRF) basis with inverse-samplingrate \"TR\" (=1/FS)\n\nOptional Parameters p:                                                            defaults                                                           {seconds}         p(1) - delay of response (relative to onset)          6         p(2) - delay of undershoot (relative to onset)       16         p(3) - dispersion of response                         1         p(4) - dispersion of undershoot                       1         p(5) - ratio of response to undershoot                6         p(6) - onset {seconds}                                0         p(7) - length of kernel {seconds}                    32\n\nExamples\n\nGenerate a HRF basis function object with Sampling rate 1/TR. And evaluate it at an event occuring at TR 103.3 with duration of 4.1 TRs\n\njulia>  f = hrfbasis(2.3)\njulia>  f(103.3,4.1)\n\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.hrfkernel-Tuple{Any, Any, Any}","page":"API: Functions","title":"Unfold.hrfkernel","text":"hrfkernel(e, TR, p)\n\n\nCalculate a HRF kernel. Input e can be [onset duration]\n\nExamples\n\njulia>  f = hrfkernel(103.3,2.3,[6. 16. 1. 1. 6. 0. 32.])\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.linearize-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"API: Functions","title":"Unfold.linearize","text":"linearize(x)\n\n\nFlatten a 1D array from of a 2D/3D array. Also drops the empty dimension\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.matrix_by_basisname-Tuple{AbstractMatrix, Any, Vector}","page":"API: Functions","title":"Unfold.matrix_by_basisname","text":"Returns a view of the Matrix y, according to the indices of the timeexpanded basisname\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.modelmatrices-Tuple{AbstractDesignMatrix}","page":"API: Functions","title":"Unfold.modelmatrices","text":"modelmatrices(X::AbstractDesignMatrix)\nmodelmatrices(X::Vector{<:AbstractDesignMatrix})\nmodelmatrices(modelmatrix::AbstractMatrix)\n\nReturns the modelmatrices (also called designmatrices) separately for the events. This is similar to StatsModels.modelcols, but merely access the precomputed designmatrix. If the designmatrix needs to be computed, please use modelcols\n\nCompare to modelmatrix which further concatenates the designmatrices (in the ContinuousTime case).\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.predicttable","page":"API: Functions","title":"Unfold.predicttable","text":"predicttable(model<:UnfoldModel,events=Unfold.events(model),args...;kwargs...)\n\nShortcut to call efficiently call (pseudocode) result_to_table(predict(...)).\n\nReturns a tidy DataFrame with the predicted results. Loops all input to predict, but really only makes sense to use if you specify either:\n\noverlap = false (the default) or epoch_to = \"eventname\".\n\n\n\n\n\n","category":"function"},{"location":"references/functions/#Unfold.result_to_table-Tuple{Any, Any, Vector{<:DataFrames.DataFrame}}","page":"API: Functions","title":"Unfold.result_to_table","text":"result_to_table(model<:UnfoldModel, eff::AbstractArray, events::Vector{<:DataFrame})\nresult_to_table(\n    eff::AbstractArray,\n    events::Vector{<:DataFrame},\n    times::Vector{<:Vector{<:Number}},\n    eventnames::Vector)\n\nConverts an array-result (prediction or coefficient) together with the events, to a tidy dataframe\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.spdiagm_diag-Union{Tuple{T}, Tuple{Any, Vararg{Pair{<:Integer, T}}}} where T","page":"API: Functions","title":"Unfold.spdiagm_diag","text":"Speed improved version of spdiagm, takes a single float value instead of a vector, like a version of spdiagm that takes in a UniformScaling\n\ne.g. \n\nsz = 5 ix = [1,3,10] spdiagm_diag(sz,(.-ix.=>1)...)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.time_expand_allBasesSameCols-Tuple{FIRBasis, Any, Any}","page":"API: Functions","title":"Unfold.time_expand_allBasesSameCols","text":"Helper function to decide whether all bases have the same number of columns per event\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.timeexpand_cols-NTuple{4, Any}","page":"API: Functions","title":"Unfold.timeexpand_cols","text":"timeexpand_cols(basisfunction, bases, ncolsBasis, ncolsX)\n\n\ncalculates in which rows the individual event-basisfunctions should go in Xdc\n\nsee also timeexpandrows timeexpandvals\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.timeexpand_rows-NTuple{4, Any}","page":"API: Functions","title":"Unfold.timeexpand_rows","text":"timeexpand_rows(onsets, bases, shift, ncolsX)\n\n\ncalculates in which rows the individual event-basisfunctions should go in Xdc\n\ntimeexpandrows timeexpandvals\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.times-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T}} where T<:UnfoldModel","page":"API: Functions","title":"Unfold.times","text":"times(model<:UnfoldModel)\n\nreturns arrays of time-vectors, one for each basisfunction / parallel-fitted-model (MassUnivarite case)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.unfold_apply_schema-Tuple{Any, Any, Any}","page":"API: Functions","title":"Unfold.unfold_apply_schema","text":"wrapper to make apply_schema mixed models as extension possible\n\nNote: type is not necessary here, but for LMM it is for multiple dispatch reasons!\n\n\n\n\n\n","category":"method"},{"location":"tutorials/lm_overlap/#lm_overlap","page":"LM overlap correction","title":"Linear Model with Overlap Correction","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"note: Note\nWe recommend you briefly go over the mass-univariate linear modelling tutorial","category":"page"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"In this notebook we will fit regression models to (simulated) EEG data. We will see that we need some type of overlap correction, as the events are close in time to each other, so that the respective brain responses overlap. If you want more detailed introduction to this topic check out our paper.","category":"page"},{"location":"tutorials/lm_overlap/#Setting-up-and-loading-the-data","page":"LM overlap correction","title":"Setting up & loading the data","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"using Unfold\nusing UnfoldSim\nusing UnfoldMakie,CairoMakie\nusing DataFrames\nusing DisplayAs # hide\n\ndata, evts = UnfoldSim.predef_eeg()\nnothing # hide","category":"page"},{"location":"tutorials/lm_overlap/#Overlap-Correction","page":"LM overlap correction","title":"Overlap Correction","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"For an overlap correction analysis we will do one additional step: define a temporal basisfunction. The steps are as following:","category":"page"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"specify a temporal basisfunction\nspecify a formula\nfit a linear model for each channel (one for all timepoints!)\nvisualize the results.","category":"page"},{"location":"tutorials/lm_overlap/#Timeexpanded-/-Deconvolved-ModelFit","page":"LM overlap correction","title":"Timeexpanded / Deconvolved ModelFit","text":"","category":"section"},{"location":"tutorials/lm_overlap/#1.-specify-a-temporal-basisfunction","page":"LM overlap correction","title":"1. specify a temporal basisfunction","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"By default, we would want to use a FIR basisfunction. See Basis Functions for more details.","category":"page"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"basisfunction = firbasis(τ=(-0.4,.8),sfreq=100)\nnothing #hide","category":"page"},{"location":"tutorials/lm_overlap/#2.-specify-a-formula","page":"LM overlap correction","title":"2. specify a formula","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"We specify the same formula as before","category":"page"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"f  = @formula 0~1+condition+continuous\nnothing #hide","category":"page"},{"location":"tutorials/lm_overlap/#3.-fit-the-linear-model","page":"LM overlap correction","title":"3. fit the linear model","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"The formula and basisfunction is not enough on their own. We also need to specify which event and which formula matches - this is important in cases where there are multiple events with different formulas","category":"page"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"bf_vec = [Any=>(f,basisfunction)]\nbf_vec|> DisplayAs.withcontext(:is_pluto=>true) # hide","category":"page"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"note: Note\nThe Any means to use all rows in evts. In case you have multiple events, you'd want to specify multiple basisfunctions e.g.    bfDict = [\"stimulus\"=>(f1,basisfunction1),                 \"response\"=>(f2,basisfunction2)]You likely have to specify a further argument to fit: eventcolumn=\"type\" with type being the column in evts that codes for the event (stimulus / response in this case)","category":"page"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"Now we are ready to fit a UnfoldLinearModel. Not that instead of times as in the mass-univariate case, we have to provide the BasisFunction type now.","category":"page"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"m = fit(UnfoldModel,bf_vec,evts,data); \nnothing #hide","category":"page"},{"location":"tutorials/lm_overlap/#4.-Visualize-the-model","page":"LM overlap correction","title":"4. Visualize the model","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"Similarly to the previous tutorial, we can visualize the model","category":"page"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"results = coeftable(m)\nplot_erp(results)","category":"page"},{"location":"tutorials/lm_overlap/","page":"LM overlap correction","title":"LM overlap correction","text":"Cool! All overlapping activity has been removed and we recovered the simulated underlying signal.","category":"page"},{"location":"installation/#install_instruct","page":"Installing Julia + Unfold.jl","title":"Installation","text":"","category":"section"},{"location":"installation/#Installing-Julia","page":"Installing Julia + Unfold.jl","title":"Installing Julia","text":"","category":"section"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"The easiest way to install julia is using juliaup","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"TLDR; ","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"Windows: winget install julia -s msstore\nMac/Linux: curl -fsSL https://install.julialang.org | sh","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"We further recommend to use VSCode. Make sure to install the Julia-Plugin, and install Revise.jl - a tutorial with screenshots can be found here","category":"page"},{"location":"installation/#Installing-Unfold.jl","page":"Installing Julia + Unfold.jl","title":"Installing Unfold.jl","text":"","category":"section"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"You can enter the package manager (similar to conda) using ] in the REPL (\"julia-commandline\").","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"This should result in (currentFolder) pkg> (with currentFolder being the project you currently work in)","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"hint: Hint\nif you see (@v1.9) pkg> instead, you still have to activate your environment. This can be done using:cd(\"/path/to/your/project\")  and ]activate . or alternatively ]activate /path/to/your/project/","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"Now you can do pkg> add Unfold","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"and after some installation:","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"julia> using Unfold in the REPL","category":"page"},{"location":"tutorials/lm_mu/#lm_massunivariate","page":"Mass univariate LM","title":"Mass Univariate Linear Models (no overlap correction)","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"In this notebook we will fit regression models to simulated EEG data. We will see that we need some type of overlap correction, as the events are close in time to each other, so that the respective brain responses overlap. If you want more detailed introduction to this topic check out our paper.","category":"page"},{"location":"tutorials/lm_mu/#Setting-up-and-loading-the-data","page":"Mass univariate LM","title":"Setting up & loading the data","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"using DataFrames\nusing Unfold\nusing UnfoldMakie, CairoMakie # for plotting\nusing UnfoldSim\nusing DisplayAs # hide\n\nnothing # hide","category":"page"},{"location":"tutorials/lm_mu/#Load-Data","page":"Mass univariate LM","title":"Load Data","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"We'll start with some predefined simulated continuos EEG data. We have 2000 events, 1 channel and one condition with two levels","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"data, evts = UnfoldSim.predef_eeg()\nnothing # hide","category":"page"},{"location":"tutorials/lm_mu/#Inspection","page":"Mass univariate LM","title":"Inspection","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"The data has only little noise. The underlying signal pattern is a positive-negative-positive spike.","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"times_cont = range(0,length=200,step=1/100) # we simulated with 100hz for 0.5 seconds\n\nf,ax,h = plot(times_cont,data[1:200])\nvlines!(evts[evts.latency .<= 200, :latency] ./ 100;color=:black) # show events, latency in samples!\nax.xlabel = \"time [s]\"\nax.ylabel = \"voltage [µV]\"\nf","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"To inspect the event dataframe we use","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"show(first(evts, 6), allcols = true)","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"Every row is an experimental event. Note that :latency refers to time in samples, (in BIDS-specification,  :onset would typically refer to seconds).","category":"page"},{"location":"tutorials/lm_mu/#Traditional-Mass-Univariate-Analysis","page":"Mass univariate LM","title":"Traditional Mass Univariate Analysis","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"To perform a mass univariate analysis, you must complete the following steps:","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"Split data into epochs \nSpecify a formula \nFit a linear model to each time point & channel\nVisualize the results.","category":"page"},{"location":"tutorials/lm_mu/#1.-Split-data-into-epochs","page":"Mass univariate LM","title":"1. Split data into epochs","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"Initially, you have data with a duration that represents the whole experimental trial. You need to cut the data into small regular epochs related to the some event, e.g. start of fixation.","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"# Unfold supports multi-channel, so we could provide matrix ch x time, which we can create like this from a vector:\ndata_r = reshape(data, (1,:))\n# cut the data into epochs\ndata_epochs, times = Unfold.epoch(data = data, tbl = evts, τ = (-0.4, 0.8), sfreq = 100); # channel x timesteps x trials\nsize(data_epochs)","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"τ specifies the epoch size.\nsfreq - sampling rate, converts τ to samples.","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"typeof(data_epochs)","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"note: Note\nIn julia, missing is supported throughout the ecosystem. Thus, we can have partial trials and they will be incorporated / ignored at the respective functions. Helpful functions are the julia-base disallowmissing and the internal Unfold.drop_missing_epochs functions","category":"page"},{"location":"tutorials/lm_mu/#2.-Specify-a-formula","page":"Mass univariate LM","title":"2. Specify a formula","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"Define a formula to be applied to each time point (and each channel) relative to the event. condition and continuous are the names of the event-describing columns in evts that we want to use for modelling.","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"f = @formula 0 ~ 1 + condition + continuous # note the formulas left side is `0 ~ ` for technical reasons`\nnothing # hide","category":"page"},{"location":"tutorials/lm_mu/#3.-Fit-a-linear-model-to-each-time-point-and-channel","page":"Mass univariate LM","title":"3. Fit a linear model to each time point & channel","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"Fit the \"UnfoldModel\" (the fit syntax is used throughout the Julia ecosystem, with the first element indicating what kind of model to fit)","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"m = fit(UnfoldModel, f, evts, data_epochs, times); \nnothing #hide","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"Alternative way to call this model is below. This syntax allows you to fit multiple events at once. For example, replacing Any with :fixation =>... will fit this model specifically to the fixation event type.","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"m = fit(UnfoldModel, [Any=>(f, times)], evts, data_epochs); \nnothing #hide","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"Inspect the fitted model:","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"m\nm|> DisplayAs.withcontext(:is_pluto=>true) # hide","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"Note these functions to discover the model: design, designmatrix, modelfit and most importantly, coeftable. ","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"info: Info\nThere are of course further methods, e.g. `coef`, `ranef`, `Unfold.formula`, `modelmatrix` which might be helpful at some point, but not important now.","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"Using coeftable, we can get a tidy DataFrames, very useful for your further analysis.","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"first(coeftable(m), 6)","category":"page"},{"location":"tutorials/lm_mu/#4.-Visualize-the-results","page":"Mass univariate LM","title":"4. Visualize the results","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"Tidy DataFrames are easy to visualize using e.g. AlgebraOfGraphics.jl. Function plot_erp from UnfoldMakiemakes it even easier.  ","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"results = coeftable(m)\nplot_erp(results)","category":"page"},{"location":"tutorials/lm_mu/","page":"Mass univariate LM","title":"Mass univariate LM","text":"As you can see, there is a lot going on, even in the baseline period! This is because the signal was simulated with overlapping events. In the next tutorial you will learn how to fix this.","category":"page"},{"location":"references/extensions/#Package-extensions","page":"Overview of package extensions","title":"Package-extensions","text":"","category":"section"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"In  Julia 1.9 Package Extensions were introduced. Unfold.jl is making use of them in four ways. Prior to using some functionality, you have to add + load specific package(s) for the functionality to be available. The reason for this is, that if you don't need e.g. GPU-support, you also will not need to install it.","category":"page"},{"location":"references/extensions/#MixedModels","page":"Overview of package extensions","title":"MixedModels","text":"","category":"section"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"To use formulas like @formula(0~1+condition+(1+condition|subject)) you have to load MixedModels. e.g.","category":"page"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"using MixedModels\nusing Unfold","category":"page"},{"location":"references/extensions/#GPU:-Krylov,CUDA","page":"Overview of package extensions","title":"GPU: Krylov,CUDA","text":"","category":"section"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"To use gpu support as described in @Ref(custom_solvers) you have to:","category":"page"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"using Krylov,CUDA\nusing Unfold","category":"page"},{"location":"references/extensions/#RobustSolvers.jl","page":"Overview of package extensions","title":"RobustSolvers.jl","text":"","category":"section"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"To use robust (outlier-\"safe\") solvers support as described in @Ref(custom_solvers) you have to:","category":"page"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"using RobustSolvers\nusing Unfold","category":"page"},{"location":"references/extensions/#Non-linear-effects:-BSplineKit.jl","page":"Overview of package extensions","title":"Non-linear effects: BSplineKit.jl","text":"","category":"section"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"Finally to use non-linear effects/splines like in @formula 0~1+spl(continuous,5) you have to use:","category":"page"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"using BSplineKit\nusing Unfold","category":"page"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"note: Note\nIn principle you should be able to load the package after loading Unfold. But sometimes this doesnt work, a Base.retry_load_extensions() call might help in these situations.","category":"page"},{"location":"tutorials/lmm_mu/#lmm_massunivariate","page":"Mass univariate Mixed Model","title":"Mass Univariate Linear Mixed Models","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"\nusing Unfold\nusing UnfoldSim\nusing MixedModels # important to load to activate the UnfoldMixedModelsExtension\nusing UnfoldMakie, CairoMakie # plotting\nusing DataFrames\nusing CategoricalArrays\nnothing;#hide","category":"page"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"important: Important\nYou have to run using MixedModels before or after loading Unfold to activate the MixedModels abilities!","category":"page"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"This notebook is similar to the Mass Univariate Linear Models (no overlap correction) tutorial, but fits mass-univariate mixed models - that is, one model over all subjects, instead of one model per subject. This allows to include item effects, for example.","category":"page"},{"location":"tutorials/lmm_mu/#Mass-Univariate-**Mixed**-Models","page":"Mass univariate Mixed Model","title":"Mass Univariate Mixed Models","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"Again we have 4 steps:","category":"page"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"Split data into epochs \nSpecify a formula \nFit a linear model to each time point & channel\nVisualize the results.","category":"page"},{"location":"tutorials/lmm_mu/#1.-Epoching","page":"Mass univariate Mixed Model","title":"1. Epoching","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"data, evts = UnfoldSim.predef_eeg(10; return_epoched = true) # simulate 10 subjects\ndata = reshape(data, 1, size(data, 1), :) # concatenate the data into a long EEG dataset\ntimes = range(0, length = size(data, 2), step = 1 / 100)\ntransform!(evts, :subject => categorical => :subject); # :subject must be categorical, otherwise MixedModels.jl complains\nnothing #hide","category":"page"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"The events dataFrame has an additional column (besides being much taller): subject","category":"page"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"first(evts, 6)","category":"page"},{"location":"tutorials/lmm_mu/#2.-Formula-specification","page":"Mass univariate Mixed Model","title":"2. Formula specification","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"We define the formula. Importantly, we need to specify a random effect. We use zerocorr to speed up the calculation.","category":"page"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"f = @formula 0 ~ 1 + condition * continuous + zerocorr(1 + condition * continuous | subject);\nnothing #hide","category":"page"},{"location":"tutorials/lmm_mu/#3.-Model-fitting","page":"Mass univariate Mixed Model","title":"3. Model fitting","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"We can now run the LinearMixedModel at each time point.","category":"page"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"m = fit(UnfoldModel, f, evts, data, times)\nnothing #hide","category":"page"},{"location":"tutorials/lmm_mu/#4.-Visualization-of-results","page":"Mass univariate Mixed Model","title":"4. Visualization of results","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"Let's start with the fixed effects.  We see the condition effects and some residual overlap activity in the fixed effects.","category":"page"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"results = coeftable(m)\n\nres_fixef = results[isnothing.(results.group), :]\nplot_erp(res_fixef)","category":"page"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"And now comes the random effect:","category":"page"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"res_ranef = results[results.group .== :subject, :]\nplot_erp(res_ranef)","category":"page"},{"location":"tutorials/lmm_mu/#Statistics","page":"Mass univariate Mixed Model","title":"Statistics","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"Mass univariate Mixed Model","title":"Mass univariate Mixed Model","text":"Check out the LMM p-value tutorial","category":"page"},{"location":"generated/HowTo/timesplines/","page":"-","title":"-","text":"EditURL = \"../../../literate/HowTo/timesplines.jl\"","category":"page"},{"location":"generated/HowTo/timesplines/","page":"-","title":"-","text":"","category":"page"},{"location":"generated/HowTo/timesplines/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"EditURL = \"../../../literate/explanations/nonlinear_effects.jl\"","category":"page"},{"location":"generated/explanations/nonlinear_effects/#[Non-linear-effects]](@id-nonlinear)","page":"Non-Linear effects","title":"[Non-linear effects]](@id nonlinear)","text":"","category":"section"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"using BSplineKit, Unfold\nusing CairoMakie\nusing DataFrames\nusing Random\nusing Colors\nusing Missings","category":"page"},{"location":"generated/explanations/nonlinear_effects/#Generating-a-non-linear-signal","page":"Non-Linear effects","title":"Generating a non-linear signal","text":"","category":"section"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"We start with generating data variables","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"rng = MersenneTwister(2) # make repeatable\nn = 20 # number of datapoints\nevts = DataFrame(:x => rand(rng, n))\nsignal = -(3 * (evts.x .- 0.5)) .^ 2 .+ 0.5 .* rand(rng, n)\n\nplot(evts.x, signal)","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Looks perfectly non-linear. Great!","category":"page"},{"location":"generated/explanations/nonlinear_effects/#Compare-linear-and-non-linear-fit","page":"Non-Linear effects","title":"Compare linear & non-linear fit","text":"","category":"section"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"First, we have to reshape signal data to a 3d array, so it will fit to Unfold format:  1 channel x 1 timepoint x 20 datapoints.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"signal = reshape(signal, length(signal), 1, 1)\nsignal = permutedims(signal, [3, 2, 1])\nsize(signal)","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Next we define three different models: linear, 4 splines and 10 splines. Note difference in formulas: one x, the other spl(x, 4).","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"design_linear = [Any => (@formula(0 ~ 1 + x), [0])];\ndesign_spl3 = [Any => (@formula(0 ~ 1 + spl(x, 4)), [0])];\ndesign_spl10 = [Any => (@formula(0 ~ 1 + spl(x, 10)), [0])];\nnothing #hide","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Next, fit the parameters.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"uf_linear = fit(UnfoldModel, design_linear, evts, signal);\nuf_spl3 = fit(UnfoldModel, design_spl3, evts, signal);\nuf_spl10 = fit(UnfoldModel, design_spl10, evts, signal); #hide\nnothing #hide","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Extract the fitted values using Unfold.effects.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"p_linear = Unfold.effects(Dict(:x => range(0, stop = 1, length = 100)), uf_linear);\np_spl3 = Unfold.effects(Dict(:x => range(0, stop = 1, length = 100)), uf_spl3);\np_spl10 = Unfold.effects(Dict(:x => range(0, stop = 1, length = 100)), uf_spl10);\nfirst(p_linear, 5)","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Plot them.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"pl = plot(evts.x, signal[1, 1, :])\nlines!(p_linear.x, p_linear.yhat)\nlines!(p_spl3.x, coalesce.(p_spl3.yhat, NaN))\nlines!(p_spl10.x, coalesce.(p_spl10.yhat, NaN))\npl","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"We see here, that the linear effect (blue line) underfits the data, the yellow spl(x, 10) overfits it, but the green spl(x, 4) fits it perfectly.","category":"page"},{"location":"generated/explanations/nonlinear_effects/#Looking-under-the-hood","page":"Non-Linear effects","title":"Looking under the hood","text":"","category":"section"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Let's have a brief look how the splines manage what they are managing.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"The most important bit to understand is, that we are replacing x by a set of coefficients spl(x). These new coefficients each tile the range of x (in our case, from [0-1]) in overlapping areas, while each will be fit by one coefficient. Because the ranges are overlapping, we get a smooth function.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Maybe this becomes clear after looking at a basisfunction:","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"term_spl = Unfold.formulas(uf_spl10)[1].rhs.terms[2]","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"This is the spline term. Note, this is a special type available in the BSplineKit.jl extension in Unfold.jl. It's abstract type is AbstractSplineTerm defined in Unfold.jl","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"typeof(term_spl)","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"const splFunction = Base.get_extension(Unfold, :UnfoldBSplineKitExt).splFunction\nsplFunction([0.2], term_spl)","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Each column of this 1-row matrix is a coefficient for our regression model.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"lines(disallowmissing(splFunction([0.2], term_spl))[1, :])","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Note: We have to use disallowmissing, because our splines return a missing whenever we ask it to return a value outside its defined range, e.g.:","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"splFunction([-0.2], term_spl)","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Because it never has seen any data outside and can't extrapolate!","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Back to our main issue. Let's plot the whole basis set","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"basisSet = splFunction(0.0:0.01:1, term_spl)\nbasisSet = disallowmissing(basisSet[.!any(ismissing.(basisSet), dims = 2)[:, 1], :]) # remove missings\nax = Axis(Figure()[1, 1])\n[lines!(ax, basisSet[:, k]) for k = 1:size(basisSet, 2)]\ncurrent_figure()","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Notice how we flipped the plot around, i.e. now on the x-axis we do not plot the coefficients, but the x-values. Now each line is one basis-function of the spline.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Unfold returns us one coefficient per basis-function","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"β = coef(uf_spl10)[1, 1, :]\nβ = Float64.(disallowmissing(β))","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"But because we used an intercept, we have to do some remodelling in the basisSet.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"X = hcat(ones(size(basisSet, 1)), basisSet[:, 1:5], basisSet[:, 7:end])","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Now we can weight the spline by the basisfunction.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"weighted = (β .* X')","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Plotting them creates a nice looking plot!","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"ax = Axis(Figure()[1, 1])\n[lines!(weighted[k, :]) for k = 1:10]\ncurrent_figure()","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Now sum them up.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"lines(sum(weighted, dims = 1)[1, :])\nplot!(X * β, color = \"gray\") #(same as matrixproduct X*β directly!)\ncurrent_figure()","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"And this is how you can think about splines.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"This page was generated using Literate.jl.","category":"page"},{"location":"HowTo/lmm_pvalues/#lmm_pvalues","page":"P-values for mixedModels","title":"How To get P-Values for Mass-Univariate LMM","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"There are currently two ways to obtain p-values for LMMs: Wald's t-test and likelihood ratio tests (mass univariate only).","category":"page"},{"location":"HowTo/lmm_pvalues/#Setup","page":"P-values for mixedModels","title":"Setup","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"using MixedModels, Unfold # we require to load MixedModels to load the PackageExtension\nusing DataFrames\nusing UnfoldSim\nusing CairoMakie\nusing DisplayAs # hide\ndata_epoch, evts =\n    UnfoldSim.predef_2x2(; n_items = 52, n_subjects = 40, return_epoched = true)\ndata_epoch = reshape(data_epoch, size(data_epoch, 1), :) # \ntimes = range(0, 1, length = size(data_epoch, 1))","category":"page"},{"location":"HowTo/lmm_pvalues/#Define-f0-and-f1-and-fit!","page":"P-values for mixedModels","title":"Define f0 & f1 and fit!","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"\nf0 = @formula 0 ~ 1 + A + (1 + A | subject);\nf1 = @formula 0 ~ 1 + A + B + (1 + A | subject); # could also differ in random effects\n            \nm0 = fit(UnfoldModel,[Any=>(f0,times)],evts,data_epoch);\nm1 = fit(UnfoldModel,[Any=>(f1,times)],evts,data_epoch);\n\nm1|> DisplayAs.withcontext(:is_pluto=>true) # hide","category":"page"},{"location":"HowTo/lmm_pvalues/#Likelihood-ratio","page":"P-values for mixedModels","title":"Likelihood ratio","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"uf_lrt = likelihoodratiotest(m0, m1)\nuf_lrt[1]","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"As you can see, we have some likelihood ratio outcomes, exciting!","category":"page"},{"location":"HowTo/lmm_pvalues/#Extract-p-values","page":"P-values for mixedModels","title":"Extract p-values","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"pvalues(uf_lrt)","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"We have extracted the p-values and now need to make them usable.     The solution can be found in the documentation under ?pvalues.","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"pvals_lrt = vcat(pvalues(uf_lrt)...)\nnchan = 1\nntime = length(times)\nreshape(pvals_lrt, ntime, nchan)' # note the last transpose via ' !","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"Perfecto, these are the LRT p-values of a model condA vs. condA+condB with same random effect structure.","category":"page"},{"location":"HowTo/lmm_pvalues/#Walds-T-Test","page":"P-values for mixedModels","title":"Walds T-Test","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"This method is easier to calculate but has limitations in accuracy and scope. It may also be less accurate due to the liberal estimation of degrees of freedom. Testing is limited in this case, as random effects cannot be tested and only single predictors can be used, which may not be appropriate for spline effects. It is important to note that this discussion is beyond the scope of this LMM package. ","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"res = coeftable(m1)\n# only fixed effects: what is not in a ranef group is a fixef.\nres = res[isnothing.(res.group), :] \n# calculate t-value\nres[:, :tvalue] = res.estimate ./ res.stderror","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"We obtained Walds t, but how to translate them to a p-value?","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"Determining the necessary degrees of freedom for the t-distribution is a complex issue with much debate surrounding it.  One approach is to use the number of subjects as an upper bound for the p-value (your df will be between n_subject and sumn_trials).","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"df = length(unique(evts.subject))","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"Plug it into the t-distribution. ","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"using Distributions\nres.pvalue = pdf.(TDist(df),res.tvalue)","category":"page"},{"location":"HowTo/lmm_pvalues/#Comparison-of-methods","page":"P-values for mixedModels","title":"Comparison of methods","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"Cool! Let's compare both methods of p-value calculation!","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"df = DataFrame(:walds => res[res.coefname.==\"B: b_tiny\", :pvalue], :lrt => pvals_lrt)\nf = Figure()\n\nscatter(f[1,1],times,res[res.coefname .== \"B: b_tiny\",:estimate],axis=(;xlabel=\"time\",title=\"coef: B:b_tiny\"))\nscatter(f[1,2],df.walds,df.lrt,axis=(;title=\"walds-t pvalue\",ylabel=\"LRT pvalue\"))\nscatter(f[2,1],times,df.walds,axis=(;title=\"walds-t pvalue\",xlabel=\"time\"))\nscatter(f[2,2],times,df.lrt,axis=(;title=\"lrt pvalue\",xlabel=\"time\"))\n\nf","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"Look pretty similar! Note that the Walds-T is typically too liberal (LRT also, but to a lesser exted). Best is to use the forthcoming MixedModelsPermutations.jl or go the route via R and use KenwardRoger (data not yet published)","category":"page"},{"location":"HowTo/custom_solvers/#custom_solvers","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers","text":"","category":"section"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"A solver takes an Unfold-specified DesignMatrix and the data, and typically solves the equation system y = Xb (in the case of Linear Models). There are many different ways how one can approach this problem, depending if the matrix is sparse, if it is 2D or 3D, if one wants to use GPU etc.","category":"page"},{"location":"HowTo/custom_solvers/#Setup-some-data","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Setup some data","text":"","category":"section"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"using Unfold\nusing UnfoldMakie, CairoMakie\nusing UnfoldSim\ndat, evts = UnfoldSim.predef_eeg(; noiselevel = 10, return_epoched = true)\n\nf = @formula 0 ~ 1 + condition + continuous\ndesignDict = Dict(Any => (f, range(0, 1, length = size(dat, 1))))","category":"page"},{"location":"HowTo/custom_solvers/#GPU-Solvers","page":"Alternative Solvers (Robust, GPU, B2B)","title":"GPU Solvers","text":"","category":"section"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"GPU solvers can significantly speed up your model fitting, with observed improvements of up to a factor of 30!","category":"page"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"using Krylov, CUDA # necessary to load the right package extension\ngpu_solver =(x, y) -> Unfold.solver_krylov(x, y; GPU = true)\nm = Unfold.fit(UnfoldModel, designDict, evts, dat, solver = gpu_solver)","category":"page"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"To test it, you will need to run it yourself as we cannot run it on the docs. If you require a different graphicscard vendor than NVIDA/CUDA, please create an issue. Currently, we are unable to test it due to lack of hardware.","category":"page"},{"location":"HowTo/custom_solvers/#Robust-Solvers","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Robust Solvers","text":"","category":"section"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"Robust solvers automatically adjust for outlier trials, but they come at a significant computational cost.","category":"page"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"using RobustModels # necessary to load the Unfold package extension\nse_solver = (x, y) -> Unfold.solver_robust(x, y)\nm = Unfold.fit(UnfoldModel, designDict, evts, dat, solver = se_solver)\nresults = coeftable(m)\nplot_erp(results; stderror = true)","category":"page"},{"location":"HowTo/custom_solvers/#Back2Back-regression","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Back2Back regression","text":"","category":"section"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"b2b_solver = (x, y) -> Unfold.solver_b2b(x, y; ross_val_reps = 5)\ndat_3d = permutedims(repeat(dat, 1, 1, 20), [3 1 2])\nm = Unfold.fit(UnfoldModel, designDict, evts, dat_3d; solver = b2b_solver)\nresults = coeftable(m)\n\nplot_erp(results)","category":"page"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"These are the decoding results for conditionA while considering conditionB, and vice versa. ","category":"page"},{"location":"HowTo/standarderrors/#standard_errors","page":"Standard errors","title":"Standard Errors","text":"","category":"section"},{"location":"HowTo/standarderrors/#Setup-some-data","page":"Standard errors","title":"Setup some data","text":"","category":"section"},{"location":"HowTo/standarderrors/","page":"Standard errors","title":"Standard errors","text":"using Unfold\nusing UnfoldMakie, CairoMakie\nusing UnfoldSim\ndat, evts = UnfoldSim.predef_eeg(; noiselevel = 10, return_epoched = true)\n\nf = @formula 0 ~ 1 + condition + continuous\ndesignDict = Dict(Any => (f, range(0, 1, length = size(dat, 1))))","category":"page"},{"location":"HowTo/standarderrors/","page":"Standard errors","title":"Standard errors","text":"It is possible to specify a solver that calculates the standard errors of the estimates for a single subject as it possible for custom solvers.","category":"page"},{"location":"HowTo/standarderrors/","page":"Standard errors","title":"Standard errors","text":"se_solver = (x, y) -> Unfold.solver_default(x, y, stderror = true)\nm = Unfold.fit(UnfoldModel, designDict, evts, dat, solver = se_solver)\nresults = coeftable(m)\nplot_erp(results; stderror = true)","category":"page"},{"location":"HowTo/standarderrors/","page":"Standard errors","title":"Standard errors","text":"warning: Warning\nIn case of overlap-correction: Use single-subject standard errors on your own risk. EEG data is autocorrelated, which means that standard errors are typically too small.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"EditURL = \"../../../literate/HowTo/effects.jl\"","category":"page"},{"location":"generated/HowTo/effects/#effects","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects","text":"","category":"section"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"Marginal effect plots are useful for understanding model fits.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"If you are an EEG researcher, you can think of the coefficients as the 'difference waves' and the (marginal) effects as the 'modelled ERP evaluated at a certain predictor value combination'. In some way, we are fitting a model with coefficients, receiving intercepts and slopes, and then try to recover the 'classical' ERPs in their \"data-domain\", typically with some effect adjustment, overlap removal, or similar.","category":"page"},{"location":"generated/HowTo/effects/#Setup-things","page":"Marginal effects (focus on non-linear predictors)","title":"Setup things","text":"","category":"section"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"Setup some packages","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"using Unfold\nusing DataFrames\nusing Random\nusing CSV\nusing UnfoldMakie\nusing UnfoldSim\nusing UnfoldMakie\nusing DisplayAs # hide","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"Generate data and fit a model with a 2-level categorical predictor and a continuous predictor without interaction.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"data, evts = UnfoldSim.predef_eeg(; noiselevel = 8)\n\nbasisfunction = firbasis(τ = (-0.1, 0.5), sfreq = 100; interpolate = false)\n\nf = @formula 0 ~ 1 + condition + continuous # 1\n\nm = fit(UnfoldModel, [Any => (f, basisfunction)], evts, data, eventcolumn = \"type\")\nm |> DisplayAs.withcontext(:is_pluto => true) # hide","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"Plot the results","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"plot_erp(coeftable(m))\n\n#=\nThe coefficients are represented by three lines on a figure:\n- the intercept showing the reference category for a typical p1/n1/p3 ERP components;\n- the slope of continuous variables with 1µV range;\n- the effect of categorical variabe with 3µV range.\n=#","category":"page"},{"location":"generated/HowTo/effects/#Effects-function","page":"Marginal effects (focus on non-linear predictors)","title":"Effects function","text":"","category":"section"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"In order to better understand the actual predicted ERP curves, often researchers had to do manual contrasts. Remember that a linear model is y = X * b, which allows (after b was estimated) to input a so-called contrast vector for X. You might know this in the form of [1, 0, -1, 1] or similar form. However, for larger models, this method can be prone to errors.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"The effects function is a convenient way to specify contrast vectors by providing the actual levels of the experimental design. It can be used to calculate all possible combinations of multiple variables.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"If a predictor-variable is not specified here, the function will automatically set it to its typical value. This value is usually the mean, but for categorical variables, it could be something else. The R package emmeans has a lot of discussion on this topic.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"eff = effects(Dict(:condition => [\"car\", \"face\"]), m)\nplot_erp(eff; mapping = (; color = :condition,))","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"We can also generate continuous predictions:","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"eff = effects(Dict(:continuous => -5:0.5:5), m)\nplot_erp(\n    eff;\n    mapping = (; color = :continuous, group = :continuous => nonnumeric),\n    categorical_color = false,\n    categorical_group = false,\n)","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"Or we can split our marginal effects by condition and calculate all combinations \"automagically\".","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"eff = effects(Dict(:condition => [\"car\", \"face\"], :continuous => -5:2:5), m)\nplot_erp(eff; mapping = (; color = :condition, col = :continuous))","category":"page"},{"location":"generated/HowTo/effects/#What-is-typical-anyway?","page":"Marginal effects (focus on non-linear predictors)","title":"What is typical anyway?","text":"","category":"section"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"The effects function includes an argument called typical, which specifies the function applied to the marginalized covariates/factors. The default value is mean, which is usually sufficient for analysis.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"However, for skewed distributions, it may be more appropriate to use the mode, while for outliers, the median or winsor mean may be more appropriate.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"To illustrate, we will use the maximum function on the continuous predictor.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"eff_max = effects(Dict(:condition => [\"car\", \"face\"]), m; typical = maximum)\neff_max.typical .= :maximum\neff = effects(Dict(:condition => [\"car\", \"face\"]), m)\neff.typical .= :mean # mean is the default\n\nplot_erp(vcat(eff, eff_max); mapping = (; color = :condition, col = :typical))","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (focus on non-linear predictors)","title":"Marginal effects (focus on non-linear predictors)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/lmm_overlap/#lmm_overlap","page":"LMM + overlap correction","title":"Overlap Correction with Linear Mixed Models","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"\nusing Unfold\nusing UnfoldSim\n\nusing CategoricalArrays\nusing MixedModels\nusing UnfoldMakie, CairoMakie\nusing DataFrames\n\nnothing;#hide","category":"page"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"This notebook is similar to the Linear Model with Overlap Correction tutorial, but fits mixed models with overlap correction","category":"page"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"warning: Warning\nLimitation: This functionality is not ready for general use. There are still a lot of things to find out and tinker with. Don't use this if you haven't looked under the hood of the toolbox! Be aware of crashes / timeouts for non-trivial problems","category":"page"},{"location":"tutorials/lmm_overlap/#Get-some-data","page":"LMM + overlap correction","title":"Get some data","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"dat, evts = UnfoldSim.predef_2x2(; signalsize=20, n_items=16, n_subjects=16)\n\n# We also need to fix the latencies, they are now relative to 1:size(data, 1), but we want a continuous long EEG.\nsubj_idx = [parse(Int, split(string(s), 'S')[2]) for s in evts.subject]\nevts.latency .+= size(dat, 1) .* (subj_idx .- 1)\n\ndat = dat[:] # we need all data concatenated over subjects\nevts.subject  = categorical(Array(evts.subject))\nnothing #hide","category":"page"},{"location":"tutorials/lmm_overlap/#Linear-**Mixed**-Model-Continuous-Time","page":"LMM + overlap correction","title":"Linear Mixed Model Continuous Time","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"Again we have 4 steps:","category":"page"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"Specify a temporal basisfunction\nSpecify a formula\nFit a linear model for each channel (one model for all timepoints!)\nVisualize the results.","category":"page"},{"location":"tutorials/lmm_overlap/#1.-Specify-a-temporal-basisfunction","page":"LMM + overlap correction","title":"1. Specify a temporal basisfunction","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"By default, we would want to use a FIR basis function. See Basis Functions for more details.","category":"page"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"basisfunction = firbasis(τ=(-0.4, .8), sfreq=20, name=\"stimulus\")\nnothing #hide","category":"page"},{"location":"tutorials/lmm_overlap/#2.-Specify-the-formula","page":"LMM + overlap correction","title":"2. Specify the formula","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"Define the formula and specify a random effect. ","category":"page"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"note: Note\nWe use zerocorr to prevent the model from computing all correlations between all timepoints and factors.","category":"page"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"f  = @formula 0 ~ 1 + A  *B + zerocorr(1 + A*B|subject);","category":"page"},{"location":"tutorials/lmm_overlap/#3.-Fit-the-model","page":"LMM + overlap correction","title":"3. Fit the model","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"bfDict = Dict(Any=>(f, basisfunction))\n# Skipping this tutorial for now due to a significant error.\nm = fit(UnfoldModel, bfDict, evts, dat) \n\nresults = coeftable(m)\nfirst(results, 6)","category":"page"},{"location":"tutorials/lmm_overlap/#4.-Visualize-results","page":"LMM + overlap correction","title":"4. Visualize results","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"LMM + overlap correction","title":"LMM + overlap correction","text":"plot_erp(results; mapping=(; col = :group))","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"EditURL = \"../../../literate/HowTo/unfold_io.jl\"","category":"page"},{"location":"generated/HowTo/unfold_io/#unfold_io","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"","category":"section"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"Unfold.jl allows storing Unfold models in a memory-efficient way using (compressed) .jld2 files.","category":"page"},{"location":"generated/HowTo/unfold_io/#Simulate-EEG-data-and-fit-an-Unfold-model","page":"Save and load Unfold models","title":"Simulate EEG data and fit an Unfold model","text":"","category":"section"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/HowTo/unfold_io/#Simulate-some-example-data-using-UnfoldSim.jl","page":"Save and load Unfold models","title":"Simulate some example data using UnfoldSim.jl","text":"","category":"section"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"using UnfoldSim\ndata, events = UnfoldSim.predef_eeg(; n_repeats = 10)\nfirst(events, 5)","category":"page"},{"location":"generated/HowTo/unfold_io/#Fit-an-Unfold-model","page":"Save and load Unfold models","title":"Fit an Unfold model","text":"","category":"section"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"using Unfold\nbasisfunction = firbasis(τ = (-0.5, 1.0), sfreq = 100, name = \"stimulus\")\nf = @formula 0 ~ 1 + condition + continuous\nbfDict = Dict(Any => (f, basisfunction))\nm = fit(UnfoldModel, bfDict, events, data);\nnothing #hide","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"</details >","category":"page"},{"location":"generated/HowTo/unfold_io/#Save-and-load-the-fitted-Unfold-model","page":"Save and load Unfold models","title":"Save and load the fitted Unfold model","text":"","category":"section"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"The following code saves the model in a compressed .jld2 file. The default option of the save function is compress=false. For memory efficiency the designmatrix is set to missing. If needed, it can be reconstructed when loading the model.","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"save_path = mktempdir(; cleanup = false) # create a temporary directory for the example\nsave(joinpath(save_path, \"m_compressed.jld2\"), m; compress = true);\nnothing #hide","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"The load function allows to retrieve the model again. By default, the designmatrix is reconstructed. If it is not needed set generate_Xs=false` which improves time-efficiency.","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"m_loaded = load(joinpath(save_path, \"m_compressed.jld2\"), UnfoldModel, generate_Xs = true);\nnothing #hide","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"explanations/basisfunctions/#Basis-Functions","page":"About basisfunctions","title":"Basis Functions","text":"","category":"section"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"using CairoMakie","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"This document will give you an explanation of basis functions. We start with basis functions for fMRI because they are very popular.","category":"page"},{"location":"explanations/basisfunctions/#HRF-/-BOLD","page":"About basisfunctions","title":"HRF / BOLD","text":"","category":"section"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"We want to define a basis function. There are currently only few basisfunctions implemented in Unfold.jl, but your imagination knows no borders!","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"We first have a look at the BOLD-HRF basisfunction aka Blood Oxygenation Level Dependent Hemodynamic Response Function:","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"using Unfold, DSP\n\nTR = 1.5 # the sampling rate\nbold = hrfbasis(TR) # using default SPM parameters\neventonset = 1.3\nbold_kernel = e -> Unfold.kernel(bold, e)\nlines(bold_kernel(eventonset)[:,1]) # returns a matrix, thus [:, 1]","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"This is the shape that is assumed to reflect the activity for an event. Generally, we would like to know how much to scale this response shape per condition, e.g. in condA we might scale it by 0.7, in condB by 1.2.","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"But let's start at the beginning and first simulate an fMRI signal. Then you will also appreciate why we need to deconvolve it later.","category":"page"},{"location":"explanations/basisfunctions/#Convolving-a-response-shape-to-get-a-\"recorded\"-fMRI-signal","page":"About basisfunctions","title":"Convolving a response shape to get a \"recorded\" fMRI signal","text":"","category":"section"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"We start by convolving this HRF function with an impulse vector at event onsets.","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"y = zeros(100) # signal length = 100\ny[[10, 30, 45]] .= 0.7 # 3 events at given for condition A\ny[[37]] .= 1.2 # 1 events at given for condition B\n\ny_conv = conv(y, bold_kernel(0)) # convolve!\nlines(y_conv[:,1])","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"Next, we would add some noise:","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"using Random\ny_conv += randn(size(y_conv))\nlines(y_conv[:,1])","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"🎉 - we did it, we simulated fMRI data.","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"Now you can see that the conditions overlap in time. To get back to the original amplitude values, we need to specify a basis function and use Unfold to deconvolve the signals.","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"note: Note\nEvents can fall between TR (the sampling rate). Some packages subsample the time signal, but in Unfold we can call the bold.kernel function directly at a given event time, which allows us to use non-TR multiples.","category":"page"},{"location":"explanations/basisfunctions/#FIR-Basis-Function","page":"About basisfunctions","title":"FIR Basis Function","text":"","category":"section"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"Okay, let's have a look at a different basis function: The FIR basisfunction. FIR stands for Finite-Impulse-Response and is a term taken from the filtering literature.","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"using Unfold #hide\n\nbasisfunction = firbasis(τ=(-0.4,.8), sfreq=50, name=\"myFIRbasis\")\nfir_kernel = e -> Unfold.kernel(basisfunction, e)\nm = fir_kernel(0)\nf = Figure()\nf[1,1] = Axis(f)\nfor col = 1:size(m, 2)\n    lines!(m[:,col])\nend\ncurrent_figure()","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"The first thing to notice is that it is not a single basisfunction, but a set of basisfunctions. So every condition is explained by several basis functions!","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"To make it clear better show it in 2D:","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"fir_kernel(0)[1:10,1:10]","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"(all . are 0's)","category":"page"},{"location":"explanations/basisfunctions/","page":"About basisfunctions","title":"About basisfunctions","text":"The FIR basis set consists of multiple basis functions. That is, each event is now time-expanded to multiple predictors, each with a certain time delay to the event onset. This allows us to model any linear overlap shape, and doesn't force us to make assumptions about the convolution kernel, as we had to do in the BOLD case.","category":"page"},{"location":"explanations/development/#Install-a-dev-version-of-Unfold","page":"Development environment","title":"Install a dev-version of Unfold","text":"","category":"section"},{"location":"explanations/development/","page":"Development environment","title":"Development environment","text":"In order to see and change the tutorials, you have to install a local dev-version of Unfold via:","category":"page"},{"location":"explanations/development/","page":"Development environment","title":"Development environment","text":"]dev --local Unfold ","category":"page"},{"location":"explanations/development/","page":"Development environment","title":"Development environment","text":"This clones the git#main into ./dev/Unfold","category":"page"},{"location":"explanations/development/#Instantiating-the-documentation-environment","page":"Development environment","title":"Instantiating the documentation environment","text":"","category":"section"},{"location":"explanations/development/","page":"Development environment","title":"Development environment","text":"To generate documentation, we recommend to install LiveServer.jl - then you can do:","category":"page"},{"location":"explanations/development/","page":"Development environment","title":"Development environment","text":"using LiveServer\nservedocs(skip_dirs=joinpath(\"docs\",\"src\",\"generated\"),literate_dir=joinpath(\"docs\",\"literate\"))","category":"page"},{"location":"explanations/development/","page":"Development environment","title":"Development environment","text":"If you prefer a one-off:","category":"page"},{"location":"explanations/development/","page":"Development environment","title":"Development environment","text":"activate the  ./docs folder (be sure to ]instantiate the first time!)\nrun include(\"docs/make.jl\")","category":"page"},{"location":"references/types/","page":"API: Types","title":"API: Types","text":"Modules = [Unfold]\nOrder   = [:type]","category":"page"},{"location":"references/types/#Unfold.AbstractModelFit","page":"API: Types","title":"Unfold.AbstractModelFit","text":"Abstract Type to report modelresults\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.BasisFunction","page":"API: Types","title":"Unfold.BasisFunction","text":"See FIRBasis for an examples\n\na BasisFunction should implement:\n\nkernel() # kernel(b::BasisFunction,sample) => returns the designmatrix for that event\nheight() # number of samples in continuous time\nwidth()  # number of coefficient columns (e.g. HRF 1 to 3, FIR=height(),except if interpolate=true )\ncolnames() # unique names of expanded columns\ntimes() # vector of times along expanded columns, length = height()\nname() # name of basisfunction\ncollabel() [default \"colname_basis\"] # name for coeftable\nshift_onset() [default 0]\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.DesignMatrixLinearModel","page":"API: Types","title":"Unfold.DesignMatrixLinearModel","text":"DesignMatrix\n\nType that keeps an Array of  formulas, designmatrices modelmatrix (Array or Array of Arrays in case of MixedModel) and events-dataframe \n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.FIRBasis","page":"API: Types","title":"Unfold.FIRBasis","text":"Defines a FIRBasisfunction which can be called for each event, defining the time-expanded basis kernel\n\nmutable struct FIRBasis <: Unfold.BasisFunction\n\ntimes: vector of times along rows of kernel-output (in seconds)\nname: name of the event, should be the actual eventName in eventcolumn of the dataframes later\nshift_onset: by how many samples do we need to shift the event onsets? This number is determined by how many 'negative' timepoints the basisfunction defines\ninterpolate: should we linearly interpolate events not on full samples?\n\n(tipp: most users would you want to call firbasis, not generate it manually)\n\nExamples\n\njulia>  b = FIRBasis(range(0,1,length=10),\"basisA\",-1)\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.LinearModelFit","page":"API: Types","title":"Unfold.LinearModelFit","text":"Contains the results of linearmodels (continuous and not)\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.TimeExpandedTerm","page":"API: Types","title":"Unfold.TimeExpandedTerm","text":"Object with a term and an applicable BasisFunction and a eventfield that are later passed to the basisfunction.\n\nstruct TimeExpandedTerm{T<:StatsModels.AbstractTerm} <: StatsModels.AbstractTerm\n\nterm: Term that the basis function is applied to. This is regularly called in other functions to get e.g. term-coefnames and timeexpand those\nbasisfunction: Kernel that determines what should happen to the designmatrix of the term\neventfields: Which fields of the event-table should be passed to the basisfunction.Important: The first entry has to be the event-latency in samples!\n\nExamples\n\njulia>  b = TimeExpandedTerm(term,kernel,[:latencyTR,:durationTR])\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.UnfoldLinearModel","page":"API: Types","title":"Unfold.UnfoldLinearModel","text":"Concrete type to implement an Mass-Univariate LinearModel. .design contains the formula + times dict .designmatrix contains a DesignMatrix modelfit is a Any container for the model results\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.UnfoldLinearModelContinuousTime","page":"API: Types","title":"Unfold.UnfoldLinearModelContinuousTime","text":"Concrete type to implement an deconvolution LinearModel. .design contains the formula + times dict .designmatrix contains a DesignMatrix modelfit is a Any container for the model results\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.UnfoldModel","page":"API: Types","title":"Unfold.UnfoldModel","text":"using Base: @deprecate_binding The main abstract model-type of the toolbox. E.g. UnfoldLinearModel is a concrete type of this\n\n\n\n\n\n","category":"type"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"EditURL = \"../../../literate/explanations/window_length.jl\"","category":"page"},{"location":"generated/explanations/window_length/#Window-length-effects","page":"Window Length Effect","title":"Window length effects","text":"","category":"section"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"using Unfold, UnfoldSim\nusing CairoMakie, AlgebraOfGraphics, MakieThemes\nusing Random\nusing DataFrames, DataFramesMeta\nusing ColorSchemes, Colors","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"important: Important\nFor analyzing real-world EEG data we recommend that researchers should — a priori — make an educated guess about the length of the underlying EEG activity and select this as their EW. This also suggests to use event windows with different sizes between events (as is possible with Unfold). Further, as can be seen below, when choosing longer time-windows the overfit is only of moderate size, thus we additionally recommend to generally err on the longer side, to not miss any important activity. \nFor a more in depth explanation on this, you can read our 2023 CCN paper: Skukies & Ehinger, 2023","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"set_theme!(theme_ggthemr(:fresh))","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"As opposed to classical averaged ERPs overlap corrected regression ERPs can be influenced by the chosen window length: Long estimation windows might capture all relevant event-related activity, but might introduce artifacts due to overfit, short estimation windows might not overfit, but also might not capture all (overlapping) activity, and thereby introduce bias.","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Thus a common question we get is, how to specify the length of the estimation windows.","category":"page"},{"location":"generated/explanations/window_length/#Init-functions","page":"Window Length Effect","title":"Init functions","text":"","category":"section"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"First we need a function that simulates some continous data; conviently we can use UnfoldSim for this","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"function gen_data(rng, noiselevel, sfreq)\n    noise = PinkNoise(; noiselevel = noiselevel)\n\n    dat, evts = UnfoldSim.predef_eeg(\n        rng;\n        sfreq = sfreq,\n        p1 = (p100(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5, 0], Dict()),\n        n1 = (n170(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5, 0], Dict()),\n        p3 = (p300(; sfreq = sfreq), @formula(0 ~ 1 + continuous), [5, 0], Dict()),\n        n_repeats = 20,\n        noise = noise,\n    )\n    return dat, evts\nend;\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Next a convience function to calculate the estimates","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"function calc_time_models(evts, dat, tWinList, sfreq)\n    mList = []\n    for twindow in tWinList\n        m = fit(\n            UnfoldModel,\n            [Any => (@formula(0 ~ 1), firbasis(twindow, sfreq))],\n            evts,\n            dat,\n        )\n        res = coeftable(m)\n        res.tWin .= string.(Ref(twindow[2]))\n        push!(mList, res)\n    end\n    return vcat(mList...)\nend;\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/#Init-variables","page":"Window Length Effect","title":"Init variables","text":"","category":"section"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"tWinList = [(-0.1, x) for x in [3, 2.5, 2, 1.5, 1, 0.5]]\nnoiselevel = 8.5\nsfreq = 250;\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/#Generate-data-and-calculate-estimates","page":"Window Length Effect","title":"Generate data and calculate estimates","text":"","category":"section"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"dat, evts = gen_data(MersenneTwister(2), noiselevel, sfreq);\n\nres = calc_time_models(evts, dat, tWinList, sfreq);\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"We also append some additional information to the results dataframe","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"For comparison lets also generate the ground truth of our data; this is a bit cumbersome and you don't have to care (too much) about it","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"dat_gt, evts_gt = UnfoldSim.predef_eeg(;\n    p1 = (p100(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()),\n    sfreq = sfreq,\n    n1 = (n170(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()),\n    p3 = (p300(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()),\n    n_repeats = 1,\n    noiselevel = 0,\n    return_epoched = true,\n);\ntime_gt = range(0, length = length(dat_gt[:, 1]), step = 1 / sfreq)\nunique_event = unique(res.tWin)\ndf_gt = DataFrame(\n    tWin = reduce(vcat, fill.(unique_event, length(dat_gt[:, 1]))),\n    eventname = Any,\n    channel = repeat([1], length(dat_gt[:, 1]) * length(unique_event)),\n    coefname = reduce(\n        vcat,\n        fill(\"GroundTruth\", length(dat_gt[:, 1]) * length(unique_event)),\n    ),\n    estimate = repeat(dat_gt[:, 1], length(unique_event)),\n    group = reduce(vcat, fill(nothing, length(dat_gt[:, 1]) * length(unique_event))),\n    stderror = reduce(vcat, fill(nothing, length(dat_gt[:, 1]) * length(unique_event))),\n    time = repeat(time_gt, length(unique_event)),\n);\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"And append ground truth to our results df","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"res_gt = vcat(res, df_gt);\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/#Plot-results","page":"Window Length Effect","title":"Plot results","text":"","category":"section"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Choose which data to plot","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"h_t =\n    AlgebraOfGraphics.data(res) * mapping(\n        :time,\n        :estimate,\n        color = :tWin,\n        group = (:tWin, :coefname) => (x, y) -> string(x[2]) * y,\n    );\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"We use the following to plot some length indicator lines","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"untWin = unique(res_gt.tWin)\nsegDF = DataFrame(\n    :x => hcat(repeat([-0.1], length(untWin)), parse.(Float64, untWin))[:],\n    :y => repeat(reverse(1:length(untWin)), outer = 2),\n)\nsegDF.tWin .= \"0.0\"\nsegDF.tWin .= segDF.x[reverse(segDF.y .+ 6)]\nsegDF.y = segDF.y .* 0.2 .+ 6;\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Layer for indicator lines","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"h_l =\n    AlgebraOfGraphics.data(@subset(segDF, :tWin .!= \"3.0\")) *\n    mapping(:x, :y, color = :tWin, group = :tWin => x -> string.(x));\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Ground truth Layer","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"h_gt =\n    AlgebraOfGraphics.data(df_gt) *\n    mapping(:time, :estimate, group = (:tWin, :coefname) => (x, y) -> string(x) * y) *\n    visual(Lines, linewidth = 5, color = Colors.Gray(0.6));\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Add all visuals together and draw","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"h1 =\n    h_gt + visual(Lines, colormap = get(ColorSchemes.Blues, 0.3:0.01:1.2)) * (h_l + h_t) |>\n    x -> draw(x, axis = (; xlabel = \"time [s]\", ylabel = \"estimate [a.u.]\"));\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Add zero grid lines","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"h1 = hlines!(current_axis(), [0], color = Colors.Gray(0.8));\nh2 = vlines!(current_axis(), [0], color = Colors.Gray(0.8));\ntranslate!(h1, 0, 0, -1);\ntranslate!(h2, 0, 0, -1);\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Plot figure","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"current_figure()","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Unfold-Documentation","page":"Unfold Documentation","title":"Unfold Documentation","text":"","category":"section"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"If you want to follow the tutorials, best to start with the mass-univariate approach, which should be familiar to you if you did ERPs before. Then the overlap-correction tutorial, mixed mass univariate, mixed overlap (tricky!). If you are then not satisfied, check out more advanced topics: effects-interface (aka what to do after fitting), or non-linear effects.","category":"page"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"In case you want to understand the tools better, check out our explanations.","category":"page"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"Once you are familiar with the tools, check out further how-to guides for specific applications.","category":"page"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"In case you want to understand the toolbox better, we plan to offer technical references. This includes Benchmarks & Explorations.","category":"page"},{"location":"#Quick-start","page":"Unfold Documentation","title":"Quick start","text":"","category":"section"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"There are four main model types ","category":"page"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"Timeexpansion No, Mixed No  : fit(UnfoldModel, [Any=>(f, -0.1:0.01:0.5)], evts, data_epoch)\nTimeexpansion Yes, Mixed No : fit(UnfoldModel, [Any=>(f, basisfunction)], evts, data)\nTimeexpansion No, Mixed Yes : fit(UnfoldModel, [Any=>(fLMM, -0.1:0.01:0.5)], evts, data_epoch)\nTimeexpansion Yes, Mixed Yes: fit(UnfoldModel, [Any=>(fLMM, basisfunction)], evts, data)","category":"page"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"f = @formula 0 ~ 1 + condition\nfLMM = @formula 0 ~ 1 + condition + (1|subject) + (1|item)\nbasisfunction = firbasis(τ = (-0.1,0.5), sfreq = 100))","category":"page"}]
}
