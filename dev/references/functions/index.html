<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API: Functions ¬∑ Unfold.jl Timeseries Analysis &amp; Deconvolution</title><meta name="title" content="API: Functions ¬∑ Unfold.jl Timeseries Analysis &amp; Deconvolution"/><meta property="og:title" content="API: Functions ¬∑ Unfold.jl Timeseries Analysis &amp; Deconvolution"/><meta property="twitter:title" content="API: Functions ¬∑ Unfold.jl Timeseries Analysis &amp; Deconvolution"/><meta name="description" content="Documentation for Unfold.jl Timeseries Analysis &amp; Deconvolution."/><meta property="og:description" content="Documentation for Unfold.jl Timeseries Analysis &amp; Deconvolution."/><meta property="twitter:description" content="Documentation for Unfold.jl Timeseries Analysis &amp; Deconvolution."/><meta property="og:url" content="https://unfoldtoolbox.github.io/Unfold.jl/references/functions/"/><meta property="twitter:url" content="https://unfoldtoolbox.github.io/Unfold.jl/references/functions/"/><link rel="canonical" href="https://unfoldtoolbox.github.io/Unfold.jl/references/functions/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Unfold.jl Timeseries Analysis &amp; Deconvolution logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Unfold.jl Documentation</a></li><li><a class="tocitem" href="../../installation/">Installing Julia + Unfold.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/lm_mu/">rERP (mass univariate)</a></li><li><a class="tocitem" href="../../tutorials/lm_overlap/">rERP (overlap correction)</a></li></ul></li><li><span class="tocitem">HowTo</span><ul><li><a class="tocitem" href="../../HowTo/multiple_events/">Multiple events</a></li><li><a class="tocitem" href="../../generated/HowTo/contrasts/">Change contrasts / coding schema</a></li><li><a class="tocitem" href="../../generated/HowTo/baddata/">Mark bad data segments</a></li><li><a class="tocitem" href="../../HowTo/standarderrors/">Standard errors</a></li><li><a class="tocitem" href="../../generated/HowTo/effects/">Marginal effects (must read re: splines)</a></li><li><a class="tocitem" href="../../generated/HowTo/circular_splines/">Circular splines</a></li><li><a class="tocitem" href="../../HowTo/custom_solvers/">Alternative Solvers (Robust, GPU, B2B)</a></li><li><a class="tocitem" href="../../generated/HowTo/unfold_io/">Save and load Unfold models</a></li><li><a class="tocitem" href="../../generated/HowTo/FIRduration/">Duration-scaled basisfunctions (Hassall-style)</a></li><li><a class="tocitem" href="../../generated/HowTo/eventhandling/">Tools to modify/transform/translate events</a></li><li><a class="tocitem" href="../../HowTo/pymne/">üêç Import EEG with PyMNE.jl</a></li><li><a class="tocitem" href="../../generated/HowTo/juliacall_unfold/">üêç Calling Unfold.jl directly from Python</a></li><li><a class="tocitem" href="../../HowTo/R/">R: Calling Unfold.jl directly from R</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../generated/explanations/nonlinear_effects/">Non-Linear effects</a></li><li><a class="tocitem" href="../../explanations/basisfunctions/">Basisfunctions</a></li><li><a class="tocitem" href="../../generated/explanations/predict/">Predictions</a></li><li><a class="tocitem" href="../../generated/explanations/window_length/">Window Length Effect</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../extensions/">Overview of package extensions</a></li><li><a class="tocitem" href="../../generated/references/solver/">Solver/optimizer implementations</a></li><li><a class="tocitem" href="../benchmarks/">Solver benchmarks</a></li><li><a class="tocitem" href="../types/">API: Types</a></li><li class="is-active"><a class="tocitem" href>API: Functions</a></li></ul></li><li><span class="tocitem">Contributing</span><ul><li><a class="tocitem" href="../../90-contributing/">Contributing guidelines</a></li></ul></li><li><span class="tocitem">Developer Guide</span><ul><li><a class="tocitem" href="../../91-developer/">Developer documentation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>API: Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API: Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/unfoldtoolbox/Unfold.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/main/docs/src/references/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article><details class="docstring" open="true"><summary id="Effects.effects-Union{Tuple{T}, Tuple{AbstractDict, T}} where T&lt;:UnfoldModel"><a class="docstring-binding" href="#Effects.effects-Union{Tuple{T}, Tuple{AbstractDict, T}} where T&lt;:UnfoldModel"><code>Effects.effects</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">effects(design::AbstractDict, model::UnfoldModel; typical = mean)</code></pre><p>Calculates marginal effects for all term combinations in <code>design</code>.</p><p>Implementation based on Effects.jl package; likely could repackage in UnfoldEffects.jl; somebody wants to do it? This would make it easier to cross-maintain it to changes/bug fixes in the Effects.jl package. <code>design</code> is a dictionary containing those predictors (as keys) with levels (as values), that you want to evaluate. The <code>typical</code> refers to the value, which other predictors that are not specified in the dictionary, should take on.</p><p>For MixedModels, the returned effects are based on the &quot;typical&quot; subject, i.e. all random effects are put to 0.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs"> julia&gt; f = @formula 0 ~ categoricalA + continuousA + continuousB
 julia&gt; uf = fit(UnfoldModel, (Any =&gt; (f, times)), data, events)
 julia&gt; d = Dict(:categorical =&gt; [&quot;levelA&quot;, &quot;levelB&quot;], :continuous =&gt; [-2, 0, 2])
 julia&gt; effects(d, uf)</code></pre><p>will result in 6 predicted values: A/-2, A/0, A/2, B/-2, B/0, B/2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/effects.jl#L11-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FileIO.load-Tuple{Any, Type{&lt;:UnfoldModel}}"><a class="docstring-binding" href="#FileIO.load-Tuple{Any, Type{&lt;:UnfoldModel}}"><code>FileIO.load</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FileIO.load(file, ::Type{&lt;:UnfoldModel}; generate_Xs=true)</code></pre><p>Load UnfoldModel from a .jld2 file.</p><p>By default, the designmatrix is reconstructed. If it is not needed set <code>generate_Xs=false</code> which improves time-efficiency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/io.jl#L55-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FileIO.save-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:UnfoldModel"><a class="docstring-binding" href="#FileIO.save-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:UnfoldModel"><code>FileIO.save</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FileIO.save(file, uf::T; compress=false) where {T&lt;:UnfoldModel}</code></pre><p>Save UnfoldModel in a (by default uncompressed) .jld2 file.</p><p>For memory efficiency the designmatrix is set to missing. If needed, it can be reconstructed when loading the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/io.jl#L22-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.coefnames-Tuple{Unfold.TimeExpandedTerm}"><a class="docstring-binding" href="#StatsAPI.coefnames-Tuple{Unfold.TimeExpandedTerm}"><code>StatsAPI.coefnames</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coefnames(term)
</code></pre><p>coefnames of a TimeExpandedTerm concatenates the basis-function name with the kronecker product of the term name and the basis-function colnames. Separator is &#39; : &#39; Some examples for a firbasis:         basis<em>313 : (Intercept) : 0.1         basis</em>313 : (Intercept) : 0.2         basis_313 : (Intercept) : 0.3         ...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L819">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.fit-Union{Tuple{T}, Tuple{Type{T}, StatsModels.FormulaTerm, DataFrames.AbstractDataFrame, AbstractArray, Union{Unfold.BasisFunction, AbstractArray}}} where T&lt;:UnfoldModel"><a class="docstring-binding" href="#StatsAPI.fit-Union{Tuple{T}, Tuple{Type{T}, StatsModels.FormulaTerm, DataFrames.AbstractDataFrame, AbstractArray, Union{Unfold.BasisFunction, AbstractArray}}} where T&lt;:UnfoldModel"><code>StatsAPI.fit</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fit(type::UnfoldModel,d::Vector{Pair},tbl::AbstractDataFrame,data::Array)
fit(type::UnfoldModel,f::FormulaTerm,tbl::AbstractDataFrame,data::Array{T,3},times)
fit(type::UnfoldModel,f::FormulaTerm,tbl::AbstractDataFrame,data::Array{T,2},basisfunction::BasisFunction)</code></pre><p>Generates Designmatrix &amp; fits model, either mass-univariate (one model per epoched-timepoint) or time-expanded (modeling linear overlap).</p><p><strong>keyword arguments</strong></p><ul><li><code>fit::Bool</code> (default: <code>true</code>) - fit the model after constructing the designmatrix. Setting this to <code>false</code> is sometimes helpful if you only want to inspect the designmatrix.</li><li><code>contrasts::Dict</code>: (default: <code>Dict()</code>) contrast to be applied to formula. Example: <code>Dict(:my_condition=&gt;EffectsCoding())</code>. More information here: https://juliastats.org/StatsModels.jl/stable/contrasts/</li><li><code>eventcolumn::Union{Symbol,String}</code> (default <code>:event</code>) - the column in <code>tbl</code> to differentiate the basisfunctions as defined in <code>d::Vector{Pair}</code></li><li><code>solver::function</code>: (default: <code>solver_default</code>). The solver used for <code>y=Xb</code>, e.g. <code>(X,y;kwargs...) -&gt; solver_default(X,y;kwargs...)</code>. There are faster &amp; alternative solvers available, see <code>solver_predefined</code> for a list of options, see <code>solver benchmark</code> in the online documentation. To use the GPU, you can provide the data as a <code>CuArray</code> after <code>using CUDA</code>. Please change the solver to e.g. <code>solver_predef(X,y;solver=:qr)</code> as lsmr+cuda =&gt; crash typically. It&#39;s worth though, speed increases &gt;100x possible</li><li><code>show_progress::Bool</code> (default <code>true</code>) - show progress via ProgressMeter - passed to <code>solver</code></li><li><code>eventfields::Array: (optional, default</code>[:latency]<code>) Array of symbols, representing column names in</code>tbl`, which are passed to basisfunction event-wise. First field of array always defines eventonset in samples.</li><li><code>show_warnings::Bool</code> (default <code>true</code>) - show some additional warnings; setting to false does deactivate some warnings but not all (use e.g. Suppressor.jl for this)</li></ul><p>If a <code>Vector[Pairs]</code> is provided, it has to have one of the following structures: For <strong>deconvolution</strong> analyses (use <code>Any=&gt;(f,bf)</code> to match all rows of <code>tbl</code> in one basis functions). Assumes <code>data</code> is a continuous EEG stream, either a <code>Vector</code> or a <code>ch x time</code> <code>Matrix</code></p><pre><code class="language-julia hljs">f1 = @formula(0~1+my_condition)
[
 :A=&gt;(f1,firbasis((-0.1,1),128), # sfreq = 128Hz
 :B=&gt;(f2,firbasis((-3,2),128)
]</code></pre><p>for <strong>mass-univariate</strong> analyses without deconvolution. Assumes <code>data</code> to be cut into epochs already (see <code>Unfold.epoch</code>). Follows <em>eeglab</em> standard <code>ch x time x trials</code>:</p><pre><code class="language-julia hljs">timesvector = range(-0.1,3,step=1/100)
[
 :A=&gt;(f1,timesvector),
 :B=&gt;(f2,timesvector)
]</code></pre><p><strong>Notes</strong></p><ul><li>The <code>type</code> can be specified directly as well e.g. <code>fit(type::UnfoldLinearModel)</code> instead of relying on the automatic inference</li><li>The data is reshaped if it is missing one dimension to have the first dimension then <code>1</code> &quot;Channel&quot;.</li></ul><p><strong>Examples</strong></p><p>Mass Univariate Linear</p><pre><code class="language-julia-repl hljs">julia&gt; data,evts = UnfoldSim.predef_eeg()
julia&gt; data_e,times = Unfold.epoch(data=data,tbl=evts,œÑ=(-1.,1.9),sfreq=100) # cut the data into epochs. data_e is now ch x times x epoch

julia&gt; f  = @formula 0~1+continuousA+continuousB
julia&gt; model = fit(UnfoldModel,f,evts,data_e,times)
# or:
julia&gt; model = fit(UnfoldModel,[Any=&gt;(f,times)],evts,data_e)</code></pre><p>Timexpanded Univariate Linear</p><pre><code class="language-julia-repl hljs">julia&gt; basisfunction = firbasis(œÑ=(-1,1),sfreq=10)
julia&gt; model = fit(UnfoldModel,f,evts,data,basisfunction)
# or
julia&gt; model = fit(UnfoldModel,[Any=&gt;(f,basisfunction],evts,data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/fit.jl#L2-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.modelmatrix"><a class="docstring-binding" href="#StatsAPI.modelmatrix"><code>StatsAPI.modelmatrix</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">StatsModels.modelmatrix(uf::UnfoldLinearModelContinuousTime, basisfunction = true)</code></pre><p>Setting the optional second args to false, will return the modelmatrix without the timeexpansion / basisfunction applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L348-L351">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.modelmatrix-Tuple{UnfoldLinearModel, Any}"><a class="docstring-binding" href="#StatsAPI.modelmatrix-Tuple{UnfoldLinearModel, Any}"><code>StatsAPI.modelmatrix</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">modelmatrix(uf::UnfoldLinearModel)</code></pre><p>returns the modelmatrix of the model. Concatenates them, except in the MassUnivariate cases, where a vector of modelmatrices is return</p><p>Compare with <code>modelmatrices</code> which returns a vector of modelmatrices, one per event</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L281-L287">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict-Tuple{Any, Vector{&lt;:StatsModels.FormulaTerm}, Vector{&lt;:DataFrames.DataFrame}}"><a class="docstring-binding" href="#StatsAPI.predict-Tuple{Any, Vector{&lt;:StatsModels.FormulaTerm}, Vector{&lt;:DataFrames.DataFrame}}"><code>StatsAPI.predict</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function predict(
    uf::UnfoldModel,
    f::Vector{&lt;:FormulaTerm},
    evts::Vector{&lt;:DataFrame};
    overlap::Bool = true,
    kwargs...
)</code></pre><p>Returns a predicted (&quot;y_hat = X*b&quot;) <code>Array</code>.</p><ul><li><code>uf</code> is an <code>&lt;:UnfoldModel</code></li><li><code>f</code> is a (vector of) formulas, typically <code>Unfold.formulas(uf)</code>, but formulas can be modified e.g. by <code>effects</code>.</li><li><code>evts</code> is a (vector of) events, can be <code>Unfold.events(uf)</code> to return the (possibly continuous-time) predictions of the model. Can be a custom even</li></ul><p><strong>kwargs:</strong></p><p>if <code>overlap = true</code> (default), overlap based on the <code>latency</code> column of <code>evts</code> will be simulated, or in the case of <code>!ContinuousTimeTrait</code> just X*coef is returned.</p><p>if <code>overlap = false</code>, returns predictions without overlap (models with <code>ContinuousTimeTrait</code> (=&gt; with basisfunction / deconvolution) only), via <code>predict_no_overlap</code></p><p>if <code>keep_basis</code> or <code>exclude_basis</code> is defined, then <code>predict_partial_overlap</code> is called, which allows to selective introduce overlap based on specified (or excluded respective) events/basisfunctions</p><p><code>epoch_to</code> and  <code>epoch_timewindow</code>: calculate (partial) overlap controlled predictions, but returns them at the specified <code>epoch_at</code> event, with the times <code>epoch_timewindow</code> (default is taken from the basisfunction) in samples.</p><p><code>eventcolumn</code> can be specified as well if different from the default <code>event</code>.</p><p>Hint: all <code>kwargs</code> can be <code>Vector</code>, or if e.g. <code>string</code> types are provided, will be put into a <code>length==1</code> vector.</p><p><strong>Output</strong></p><ul><li>If <code>overlap=false</code>, returns a 3D-Array</li><li>If <code>overlap=true</code> and <code>epoch_to = nothing</code> (default), returns a 2D-array</li><li>If <code>overlap=true</code> and <code>epoch_to != nothing</code>, returns a 3D array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/predict.jl#L160-L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.r2-Tuple{UnfoldModel, AbstractArray}"><a class="docstring-binding" href="#StatsAPI.r2-Tuple{UnfoldModel, AbstractArray}"><code>StatsAPI.r2</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">r2(model&lt;:UnfoldModel)</code></pre><p>returns the coeficient of determination</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/predict.jl#L506-L509">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsModels.modelcols-Tuple{Unfold.TimeExpandedTerm, Any}"><a class="docstring-binding" href="#StatsModels.modelcols-Tuple{Unfold.TimeExpandedTerm, Any}"><code>StatsModels.modelcols</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">modelcols(term, tbl)
</code></pre><p>calculates the actual designmatrix for a timeexpandedterm. Multiple dispatch on StatsModels.modelcols</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L433">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold._modelcols-Tuple{StatsModels.FormulaTerm, Any}"><a class="docstring-binding" href="#Unfold._modelcols-Tuple{StatsModels.FormulaTerm, Any}"><code>Unfold._modelcols</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_modelcols(form::FormulaTerm, events)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/io.jl#L16-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold._modelcols-Tuple{Vector, Vector}"><a class="docstring-binding" href="#Unfold._modelcols-Tuple{Vector, Vector}"><code>Unfold._modelcols</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_modelcols(forms::Vector,events::Vector)</code></pre><p>A wrapper around StatsModels.modelcols that is only needed for easy multiple dispatch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/io.jl#L6-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.apply_basisfunction-Tuple{Any, Unfold.BasisFunction, Any, Any}"><a class="docstring-binding" href="#Unfold.apply_basisfunction-Tuple{Any, Unfold.BasisFunction, Any, Any}"><code>Unfold.apply_basisfunction</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_basisfunction(
    form,
    basisfunction,
    eventfields,
    eventname
)
</code></pre><p>timeexpand the rhs-term of the formula with the basisfunction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L250">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.calc_epoch_timewindow-Tuple{Any, Any}"><a class="docstring-binding" href="#Unfold.calc_epoch_timewindow-Tuple{Any, Any}"><code>Unfold.calc_epoch_timewindow</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>returns an integer range with the samples around <code>epoch_event</code> as defined in the corresponding basisfunction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/predict.jl#L426-L429">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.combine_yhat!-Union{Tuple{T}, Tuple{Vector{&lt;:Array{T}}, Array{T}}} where T"><a class="docstring-binding" href="#Unfold.combine_yhat!-Union{Tuple{T}, Tuple{Vector{&lt;:Array{T}}, Array{T}}} where T"><code>Unfold.combine_yhat!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">combine_yhat(list,single)</code></pre><p>combines single into list, if either list or single contains missing, automatically casts the respective counter-part to allow missings as well</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/predict.jl#L397-L400">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.copy_eventinfo-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#Unfold.copy_eventinfo-Tuple{Any, Vararg{Any}}"><code>Unfold.copy_eventinfo</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>copy field-info from source to closest target</p><p><strong>Arguments</strong></p><ul><li><code>evts::DataFrame</code></li><li><code>from_to::Pair</code> specifies from which entry to which entry to copy, e.g. &quot;source&quot;=&gt;&quot;target&quot;</li><li><code>field::String</code> name of the column that contains the data to be copied to other events. Can be a <code>pair</code> in order to copy to a new column and thereby not replace any entries</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>search_fun::Symbol/Function</code> can be <code>:closest</code> (default), <code>:forward</code> or <code>:backward</code><code>or a custom function following the interface</code>search<em>fun(source</em>latency::Float64,target_latencies::Vector)` returning a single integer index</li><li><code>column::String</code> (default <code>&quot;event&quot;</code>) the column where the <code>from_to</code> source and target events can be found in</li></ul><p><strong>Example</strong></p><p>Copy reaction time values from button press to closest stimulus immediately before button press julia&gt; copy<em>eventinfo!(evts,&quot;button&quot;=&gt;&quot;stimulus&quot;,&quot;reaction</em>time&quot;;search_fun=&quot;s after t&quot;)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/eventhandling.jl#L2-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.design_to_modeltype-Tuple{Any, Unfold.BasisFunction}"><a class="docstring-binding" href="#Unfold.design_to_modeltype-Tuple{Any, Unfold.BasisFunction}"><code>Unfold.design_to_modeltype</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>!!! Important:    this is an ugly hack dating back to the time where UnfoldMixedModels was still an extension. We are overloading this function in UnfoldMixedModels.jl with a more specific type, to switch between MixedModels-Unfold types and not...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/fit.jl#L260-L263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.designmatrix-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Unfold.designmatrix-Tuple{Any, Any, Any}"><code>Unfold.designmatrix</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">designmatrix(type, f, tbl; kwargs...)</code></pre><p>call without basis function, continue with basisfunction = <code>nothing</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L122-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.designmatrix-Tuple{Type{&lt;:UnfoldModel}, Union{Tuple, StatsModels.FormulaTerm}, Any, Any}"><a class="docstring-binding" href="#Unfold.designmatrix-Tuple{Type{&lt;:UnfoldModel}, Union{Tuple, StatsModels.FormulaTerm}, Any, Any}"><code>Unfold.designmatrix</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">designmatrix(
    unfoldmodeltype,
    f,
    tbl,
    basisfunction;
    contrasts,
    eventname,
    show_warnings,
    kwargs...
)
</code></pre><p>designmatrix(type, f, tbl; kwargs...) Return a <em>DesignMatrix</em> used to fit the models.</p><p><strong>Arguments</strong></p><ul><li>type::UnfoldModel</li><li>f::FormulaTerm: Formula to be used in this designmatrix</li><li>tbl: Events (usually a data frame) to be modelled</li><li>basisfunction::BasisFunction: basisfunction to be used in modeling (if specified)</li><li>contrasts::Dict: (optional) contrast to be applied to formula</li><li>eventfields::Array: (optional) Array of symbols which are passed to basisfunction event-wise.</li></ul><p>First field of array always defines eventonset in samples. Default is [:latency]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt;  designmatrix(UnfoldLinearModelContinuousTime,Dict(Any=&gt;(f,basisfunction1),tbl)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.designmatrix-Tuple{Type{&lt;:UnfoldModel}, Vector{&lt;:Pair}, Any}"><a class="docstring-binding" href="#Unfold.designmatrix-Tuple{Type{&lt;:UnfoldModel}, Vector{&lt;:Pair}, Any}"><code>Unfold.designmatrix</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">designmatrix(
    T::Type{&lt;:UnfoldModel},
    design_array::Vector{&lt;:Pair},
    tbl;
    eventcolumn = :event,
    contrasts = Dict{Symbol,Any}(),
    kwargs...,</code></pre><p>iteratively calls <code>designmatrix</code> for each event in the design_array, and returns a list of <code>&lt;:AbstractDesignMatrix</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L161-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.designmatrix-Tuple{UnfoldModel, Any}"><a class="docstring-binding" href="#Unfold.designmatrix-Tuple{UnfoldModel, Any}"><code>Unfold.designmatrix</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">designmatrix(
    uf::UnfoldModel,
    tbl;
    eventcolumn = :event,
    contrasts = Dict{Symbol,Any}(),
    kwargs...,</code></pre><p>Main function called from <code>fit(UnfoldModel...)</code>, generates the designmatrix, returns a list of <code>&lt;:AbstractDesignMatrix</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L146-L156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.drop_missing_epochs-Union{Tuple{T}, Tuple{Any, AbstractArray{T, 3}}} where T"><a class="docstring-binding" href="#Unfold.drop_missing_epochs-Union{Tuple{T}, Tuple{Any, AbstractArray{T, 3}}} where T"><code>Unfold.drop_missing_epochs</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">[X,y] = drop_missing_epochs(X, y::Array)</code></pre><p>Helper function to remove epochs of <code>y</code> that contain missings. Drops them from both <code>X</code> and  <code>y</code>. Often used in combination with <code>Unfold.epoch</code></p><p>X can be anything that has two dimensions (Matrix, DataFrame etc)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/utilities.jl#L97-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.empty_modelmatrix-Tuple{AbstractDesignMatrix}"><a class="docstring-binding" href="#Unfold.empty_modelmatrix-Tuple{AbstractDesignMatrix}"><code>Unfold.empty_modelmatrix</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">empty_modelmatrix(d::AbstractDesignMatrix)</code></pre><p>returns an empty modelmatrix of the type DesignMatrix type of <code>d</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/io.jl#L46-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.epoch-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Any}} where T&lt;:Union{Missing, Number}"><a class="docstring-binding" href="#Unfold.epoch-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Any}} where T&lt;:Union{Missing, Number}"><code>Unfold.epoch</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">epoch(data::Array{T,1},evts::DataFrame,œÑ::Tuple/Vector,sfreq;kwargs...,</code></pre><p>Basic function to epoch data; all input also available as kwargs.</p><p>Additional kwarg: <code>eventtime</code>=:latency, which defines the column in <code>evts</code> that is used to cut the data (in samples). For uneven sample-times we use <code>round()</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/utilities.jl#L10-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.equalize_size-Union{Tuple{T}, Tuple{AbstractMatrix, AbstractVecOrMat{T}}} where T&lt;:(Union{Missing, var&quot;#s147&quot;} where var&quot;#s147&quot;&lt;:Number)"><a class="docstring-binding" href="#Unfold.equalize_size-Union{Tuple{T}, Tuple{AbstractMatrix, AbstractVecOrMat{T}}} where T&lt;:(Union{Missing, var&quot;#s147&quot;} where var&quot;#s147&quot;&lt;:Number)"><code>Unfold.equalize_size</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">equalize_size(X, data)
</code></pre><p>Equates the length of data and designmatrix by cutting the shorter one</p><p>The reason we need this is because when generating the designmatrix, we do not know how long the data actually are. We only assume that event-latencies are synchronized with the data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/utilities.jl#L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.firbasis"><a class="docstring-binding" href="#Unfold.firbasis"><code>Unfold.firbasis</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">firbasis(œÑ, sfreq; ...)
firbasis(œÑ, sfreq, name; interpolate, scale_duration)
</code></pre><p>Generate a sparse FIR basis around the <em>œÑ</em> timevector at sampling rate <em>sfreq</em>. This is useful if you cannot make any assumptions on the shape of the event responses. If unrounded events are supplied, they are split between samples. E.g. event-latency = 1.2 will result in a &quot;0.8&quot; and a &quot;0.2&quot; entry.</p><p>Advanced: second input can be duration in samples - careful: <code>times(firbasis)</code> always assumes duration = 1. Therefore, issues with LMM and predict will appear!</p><p><strong>keyword arguments</strong></p><p><code>interpolate</code> (Bool, default false): if true, interpolates events between samples linearly. This results in <code>predict</code> functions to return a trailling 0<code></code>scale_duration<code>(Union{Bool,Interpolations-Interpolator}, default false):     if true, scales the response by the fit-kwargs</code>eventfields<code>second entry. That is, the FIR becomes a stepfunction instead of a impulse response.     if Interpolations.interpolator, e.g.</code>Interpolations.Linear()<code>- uses the fit-kwargs</code>eventfields<code>second entry to stretch the FIR kernel based on</code>imresize`. This implements Hassall</p><p><strong>Examples</strong></p><p>Generate a FIR basis function from -0.1s to 0.3s at 100Hz</p><pre><code class="language-julia-repl hljs">julia&gt;  f = firbasis([-0.1,0.3],100)</code></pre><p>Evaluate at an event occuring at sample 103.3</p><pre><code class="language-julia-repl hljs">julia&gt;  f(103.3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/basisfunctions.jl#L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.firkernel-Tuple{Any, Any}"><a class="docstring-binding" href="#Unfold.firkernel-Tuple{Any, Any}"><code>Unfold.firkernel</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">firkernel(ev, times; interpolate, scale_duration)
</code></pre><p>Calculate a sparse firbasis</p><p>second input can be duration in samples - careful: <code>times(firbasis)</code> always assumes duration = 1. Therefore, issues with LMM and predict will appear!</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt;  f = firkernel(103.3,range(-0.1,step=0.01,stop=0.31))
julia&gt;  f_dur = firkernel([103.3 4],range(-0.1,step=0.01,stop=0.31))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/basisfunctions.jl#L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.formulas-Tuple{Vector{&lt;:Pair}}"><a class="docstring-binding" href="#Unfold.formulas-Tuple{Vector{&lt;:Pair}}"><code>Unfold.formulas</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">formulas(design::Vector{&lt;:Pair})</code></pre><p>returns vector of formulas, no schema has been applied (those formulas never saw the data). Also no timeexpansion has been applied (in the case of timecontinuous models)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L377-L380">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.get_basis_colnames-Tuple{AbstractArray{&lt;:StatsModels.FormulaTerm}}"><a class="docstring-binding" href="#Unfold.get_basis_colnames-Tuple{AbstractArray{&lt;:StatsModels.FormulaTerm}}"><code>Unfold.get_basis_colnames</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_basis_colnames(m)
get_basis_colnames(formulas)</code></pre><p>returns list of colnames - e.g. times for firbasis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/condense.jl#L208-L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.get_basis_indices-Tuple{Any, Vector}"><a class="docstring-binding" href="#Unfold.get_basis_indices-Tuple{Any, Vector}"><code>Unfold.get_basis_indices</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_basis_indices(uf, basisnames::Vector)</code></pre><p>returns a boolean vector with length spanning all coefficients, which coefficient is defined by <code>basisnames</code> (vector of names)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/predict.jl#L436-L439">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.get_basis_names-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T}} where T&lt;:UnfoldModel"><a class="docstring-binding" href="#Unfold.get_basis_names-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T}} where T&lt;:UnfoldModel"><code>Unfold.get_basis_names</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_basisnames(model::UnfoldModel)</code></pre><p>Return the basisnames for all predictor terms as a vector.</p><p>The returned vector contains the name of the event type/basis, repeated by their actual coefficient number (after StatsModels.apply_schema / timeexpansion). If a model has more than one event type (e.g. stimulus and fixation), the vectors are concatenated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/condense.jl#L176-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.hrfbasis-Tuple{Float64}"><a class="docstring-binding" href="#Unfold.hrfbasis-Tuple{Float64}"><code>Unfold.hrfbasis</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hrfbasis(TR; parameters, name)
</code></pre><p>Generate a Hemodynamic-Response-Functio (HRF) basis with inverse-samplingrate &quot;TR&quot; (=1/FS)</p><p>Optional Parameters p:                                                            defaults                                                           {seconds}         p(1) - delay of response (relative to onset)          6         p(2) - delay of undershoot (relative to onset)       16         p(3) - dispersion of response                         1         p(4) - dispersion of undershoot                       1         p(5) - ratio of response to undershoot                6         p(6) - onset {seconds}                                0         p(7) - length of kernel {seconds}                    32</p><p><strong>Examples</strong></p><p>Generate a HRF basis function object with Sampling rate 1/TR. And evaluate it at an event occuring at TR 103.3 with duration of 4.1 TRs</p><pre><code class="language-julia-repl hljs">julia&gt;  f = hrfbasis(2.3)
julia&gt;  f(103.3,4.1)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/basisfunctions.jl#L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.hrfkernel-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Unfold.hrfkernel-Tuple{Any, Any, Any}"><code>Unfold.hrfkernel</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hrfkernel(e, TR, p)
</code></pre><p>Calculate a HRF kernel. Input e can be [onset duration]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt;  f = hrfkernel(103.3,2.3,[6. 16. 1. 1. 6. 0. 32.])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/basisfunctions.jl#L304">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.linearize-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><a class="docstring-binding" href="#Unfold.linearize-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>Unfold.linearize</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linearize(x)
</code></pre><p>Flatten a 1D array from of a 2D/3D array. Also drops the empty dimension</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/utilities.jl#L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.matrix_by_basisname-Tuple{AbstractMatrix, Any, Vector}"><a class="docstring-binding" href="#Unfold.matrix_by_basisname-Tuple{AbstractMatrix, Any, Vector}"><code>Unfold.matrix_by_basisname</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Returns a view of the Matrix <code>y</code>, according to the indices of the timeexpanded <code>basisname</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/predict.jl#L418-L420">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.modelmatrices-Tuple{AbstractDesignMatrix}"><a class="docstring-binding" href="#Unfold.modelmatrices-Tuple{AbstractDesignMatrix}"><code>Unfold.modelmatrices</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">modelmatrices(X::AbstractDesignMatrix)
modelmatrices(X::Vector{&lt;:AbstractDesignMatrix})
modelmatrices(modelmatrix::AbstractMatrix)</code></pre><p>Returns the modelmatrices (also called designmatrices) separately for the events. This is similar to <code>StatsModels.modelcols</code>, but merely access the precomputed designmatrix. If the designmatrix needs to be computed, please use <code>modelcols</code></p><p>Compare to <code>modelmatrix</code> which further concatenates the designmatrices (in the ContinuousTime case).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L32-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.predict_no_overlap-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T, Any, Vector, Vector}} where T&lt;:UnfoldModel"><a class="docstring-binding" href="#Unfold.predict_no_overlap-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T, Any, Vector, Vector}} where T&lt;:UnfoldModel"><code>Unfold.predict_no_overlap</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">predict_no_overlap(, uf, coefs, f, evts)
</code></pre><p>in ContinuousTime case (typically the deconvolution model), we return idealized predictions without overlap between events.</p><p>in the Not-ContinuousTime case (typically the MassUnivariate model), we return predictions for each event independently. In that case, the function is unfortunately a missnomer, as overlap cannot be removed from mass-univariate models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/predict.jl#L322-L328">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.predict_partial_overlap-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T, Any}} where T&lt;:UnfoldModel"><a class="docstring-binding" href="#Unfold.predict_partial_overlap-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T, Any}} where T&lt;:UnfoldModel"><code>Unfold.predict_partial_overlap</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">predict_partial_overlap(, uf, args; kwargs...)
</code></pre><p>Returns predicted time-continuous values, but only for a subset of events. This is achieved by excluding the part of the designmatrix that belongs to the basisfunctions/events you do not want to have in your model.</p><p>Typically called via <code>predict</code>, for configuration, keyword-arguments and usage see there.</p><p>One difference is, that we require the <code>coefs(uf::UnfoldModel)</code> already exctracted.</p><p>Due to the time-continuous nature, running it with a model not containing the <code>ContinuousTimeTrait</code> it will throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/predict.jl#L252-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.predicttable"><a class="docstring-binding" href="#Unfold.predicttable"><code>Unfold.predicttable</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">predicttable(model&lt;:UnfoldModel,events=Unfold.events(model),args...;kwargs...)</code></pre><p>Shortcut to call efficiently call (pseudocode) <code>result_to_table(predict(...))</code>.</p><p>Returns a tidy DataFrame with the predicted results. Loops all input to <code>predict</code>, but really only makes sense to use if you specify either:</p><p><code>overlap = false</code> (the default) or <code>epoch_to = &quot;eventname&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/predict.jl#L444-L452">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.prepare-Union{Tuple{T}, Tuple{Any, AbstractMatrix{&lt;:Union{Missing, T}}}} where T&lt;:Number"><a class="docstring-binding" href="#Unfold.prepare-Union{Tuple{T}, Tuple{Any, AbstractMatrix{&lt;:Union{Missing, T}}}} where T&lt;:Number"><code>Unfold.prepare</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prepare(X, data)
</code></pre><p>convert and permutedim input to follow the following output:</p><pre><code class="language-julia hljs">HÃÇ, Y, X = prepare(X, data)</code></pre><p>where <code>HÃÇ</code> is used to save the beta, <code>Y</code> is the data in format ch x repeat x time (with size(time) = 1 if data is a Matrix), and <code>X</code>.</p><ul><li>if data is a CuArray, everything is transformed to CuArrays as well (via UnfoldCUDAExt.jl, CUDA needs to be loaded)</li><li>same datatype between X and data is enforced</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/solver/prepare.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.prepare_XTX-Tuple{Tuple}"><a class="docstring-binding" href="#Unfold.prepare_XTX-Tuple{Tuple}"><code>Unfold.prepare_XTX</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prepare_XTX(all)
</code></pre><p>instead of solving y = Xb, we solve X&#39;Xb = X&#39;y. This function calculates X&#39;X and instantiates X&#39;y to be used in the solver-step, to facilitate X&#39;y calculations later, X&#39; is also calculated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/solver/prepare.jl#L34-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.prepare_pinv-Tuple{Tuple}"><a class="docstring-binding" href="#Unfold.prepare_pinv-Tuple{Tuple}"><code>Unfold.prepare_pinv</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prepare_pinv(all)
</code></pre><p>calculates pinv of the designmatrix for later use in the solver-step. This is helpful in case you have many chanels</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/solver/solvers.jl#L3-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.result_to_table-Tuple{Any, Any, Vector{&lt;:DataFrames.DataFrame}}"><a class="docstring-binding" href="#Unfold.result_to_table-Tuple{Any, Any, Vector{&lt;:DataFrames.DataFrame}}"><code>Unfold.result_to_table</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">result_to_table(model&lt;:UnfoldModel, eff::AbstractArray, events::Vector{&lt;:DataFrame})
result_to_table(
    eff::AbstractArray,
    events::Vector{&lt;:DataFrame},
    times::Vector{&lt;:Vector{&lt;:Number}},
    eventnames::Vector)
result_to_table(
    eff::Vector{&lt;:AbstractArray},
    events::Vector{&lt;:DataFrame},
    times::Vector,
    eventnames::Vector,
)</code></pre><p>Converts an array-result (prediction or coefficient) together with the events, to a tidy dataframe.</p><p>To support multi-event models, we expect everything to be put into <code>Vectors</code> - this should be refactored at some point to be compatible with broadcasting, but it is not right now.</p><p><strong>args</strong></p><p><code>eff</code>: A vector that contains the array(s) to be converted to a tidy dataframe. Each event in your events dataframe your have it&#39;s own array (i.e. the array should have <code>length(eff) == length(unique(events.event))</code>). Each array should be 3D, with channel x time x predictor <code>events</code>: A vector of event-dataframes, each need to match <code>size(eff,3)</code>. Each individual event (<code>unique(events.event)</code>) should have it&#39;s own dataframe. E.g. <code>[[df_event1::DataFrame], [df_event1::DataFrame]]</code>times<code>: A vector of time-vectors with</code>length(eff)<code>, each time-vector needs to match</code>size.(eff,2)<code></code>eventnames`: A vector of eventnames, either symbols or strings, should be a single entry per event</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/condense.jl#L218-L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.solver_default-Tuple{Any, AbstractMatrix}"><a class="docstring-binding" href="#Unfold.solver_default-Tuple{Any, AbstractMatrix}"><code>Unfold.solver_default</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solver_default(X, y; kwargs...)
</code></pre><p>default solvers.</p><ul><li>If data is continuous (2D), we solve Xb = y via lsmr</li><li>If data is epoched (3D) we solve Xb = y via pinv</li></ul><p>We highly recommend to check out <code>solver_predefined</code> for faster options by rather solving X&#39;Xb = X&#39;y via QR, cholesky, pinv or ``-solver. A benchmark is available in the online documentation.</p><p>Please see <code>?solver_main</code> for keyword arguments of the solver (like <code>stderror</code>, <code>multithreading</code>, <code>show_time</code>, <code>show_progress</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/solver/main.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.solver_predefined-Tuple{Any, AbstractMatrix}"><a class="docstring-binding" href="#Unfold.solver_predefined-Tuple{Any, AbstractMatrix}"><code>Unfold.solver_predefined</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solver_predefined(X, y_in; solver, kwargs...)
</code></pre><p>helper function that returns solver with appropriate prepare-pipelines and fitting solver-functions. X is a (typically sparse) designmatrix, y is a 2D or 3D array.</p><p><code>solver</code> : one of <code>:cg</code>, <code>:pinv</code>, <code>:intern</code>, <code>:qr</code>, <code>:cholesky</code>, <code>:lsmr</code> (default)</p><p>Only <code>lsmr</code> solves Xb = y via an iterative solver and should be more accurate in principle.</p><p>The other predefined-solvers solve X&#39;Xb = X&#39;y which is often computationally much cheaper, and because X&#39;X can be precalculated, it should be cheaper to apply.</p><p>Testing this empirically is somewhat complicated, as depending on your sparsity structure (‚âà your design) and the size of your data (sfreq &amp; minutes) the best solver and the reached accuracy can change quite a bit.</p><p><strong>GPU</strong></p><p>All solvers except :lsmr support GPU calculations. For lsmr on the GPU try <code>solver_krylov</code> instead</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/solver/main.jl#L24-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.spdiagm_diag-Union{Tuple{T}, Tuple{Any, Vararg{Pair{&lt;:Integer, T}}}} where T"><a class="docstring-binding" href="#Unfold.spdiagm_diag-Union{Tuple{T}, Tuple{Any, Vararg{Pair{&lt;:Integer, T}}}} where T"><code>Unfold.spdiagm_diag</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Speed improved version of spdiagm, takes a single float value instead of a vector, like a version of spdiagm that takes in a UniformScaling</p><p>e.g.</p><blockquote><p>sz = 5 ix = [1,3,10] spdiagm_diag(sz,(.-ix.=&gt;1)...)</p></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L725-L733">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.time_expand_allBasesSameCols-Tuple{FIRBasis, Any, Any}"><a class="docstring-binding" href="#Unfold.time_expand_allBasesSameCols-Tuple{FIRBasis, Any, Any}"><code>Unfold.time_expand_allBasesSameCols</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Helper function to decide whether all bases have the same number of columns per event</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L803-L805">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.timeexpand_cols-NTuple{4, Any}"><a class="docstring-binding" href="#Unfold.timeexpand_cols-NTuple{4, Any}"><code>Unfold.timeexpand_cols</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">timeexpand_cols(basisfunction, bases, ncolsBasis, ncolsX)
</code></pre><p>calculates in which rows the individual event-basisfunctions should go in Xdc</p><p>see also timeexpand<em>rows timeexpand</em>vals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L470">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.timeexpand_rows-NTuple{4, Any}"><a class="docstring-binding" href="#Unfold.timeexpand_rows-NTuple{4, Any}"><code>Unfold.timeexpand_rows</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">timeexpand_rows(onsets, bases, shift, ncolsX)
</code></pre><p>calculates in which rows the individual event-basisfunctions should go in Xdc</p><p>timeexpand<em>rows timeexpand</em>vals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L411">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.times-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T}} where T&lt;:UnfoldModel"><a class="docstring-binding" href="#Unfold.times-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T}} where T&lt;:UnfoldModel"><code>Unfold.times</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">times(model&lt;:UnfoldModel)</code></pre><p>returns arrays of time-vectors, one for each basisfunction / parallel-fitted-model (MassUnivarite case)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/predict.jl#L476-L479">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Unfold.unfold_apply_schema-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Unfold.unfold_apply_schema-Tuple{Any, Any, Any}"><code>Unfold.unfold_apply_schema</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>wrapper to make apply_schema mixed models as extension possible</p><p>Note: type is not necessary here, but for LMM it is for multiple dispatch reasons!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/Unfold.jl/blob/ec45fd18bb76c82569c23fab5b3d8be19413a3c8/src/designmatrix.jl#L133-L137">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">¬´ API: Types</a><a class="docs-footer-nextpage" href="../../90-contributing/">Contributing guidelines ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 11 December 2025 12:47">Thursday 11 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
