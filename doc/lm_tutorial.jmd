---
title: "Overlap Correction with Linear Models (aka unfold.jl)"
author: "Benedikt Ehinger, Dave Kleinschmidt"
date: 2020-02-17
options:
    line_width: 92
---


```julia;label=packages;
using Revise
using CSV
using StatsModels
using MixedModels
using DataFrames
using DataFramesMeta
import DSP
import Plots
import unfold
Plots.gr()
```
```julia
testCase = "testCase15"
#testCase = "testCaseMultisubject"
data = CSV.read("test\\"*testCase*"_data.csv", header=0)
data = convert(Matrix,data)
data = dropdims(data,dims=1) # convert to vector
evts = CSV.read("test\\"*testCase*"_events.csv");
```
For now we have to subset the data to contain only event-type. (limitation: We also have to remove some missings)
```julia
evts_subset = evts[evts.type.=="stimulus2",:]

# Is it possible to pass Missing Type through? That would be fantastic
evts_subset.continuousA = Missings.disallowmissing(evts_subset.continuousA)
evts_subset.conditionA  = Missings.disallowmissing(evts_subset.conditionA);
```
```julia
showall(first(evts_subset,6,))
```
The data has little noise and the underlying signal is a pos-neg spike pattern
```julia
Plots.plot(data[1:300])
```

## Basis Functions
### HRF / BOLD
We are now ready to define a basisfunction. There are currently only two basisfunction implemented, so not much choice.
We first have a look at the BOLD-HRF basisfunction:

```julia
TR = 1.5
bold = unfold.hrfbasis(TR) # using default SPM parameters
eventonset = 1.3
Plots.plot(bold.kernel(eventonset))
```
Classically, we would convolve this HRF function with a impulse-vector, with impulse at the event onsets
```julia
y = zeros(100)
y[[10,30,37,45]] .=1
y_conv = DSP.conv(y,bold.kernel(0))
Plots.plot(y_conv)
```
Which one would use as a regressor against the recorded BOLD timecourse.

Note that events could fall inbetween TR (the sampling rate). Some packages subsample the time signal, but in `unfold` we can directly call the `bold.kernel` function at a given event-time, which allows for non-TR-multiples to be used.

### FIR Basis Function

Okay, let's have a look at a different basis function: The FIR basisfunction.

```julia
basisfunction = unfold.firbasis(Ï„=(-0.2,.4),sfreq=50)
Plots.plot(basisfunction.kernel(0))
```

Not very clear, better show it in 2D
```julia
basisfunction.kernel(0)[1:10,1:10]
```
The FIR basisset consists of multiple basisfunctions. That is, each event will now be *timeexpanded* to multiple predictors, each with a certain time-delay to the event onset.
This allows to model any arbitrary linear overlap shape, and doesn't force us to make assumptions on the convolution kernel (like we had to do in the BOLD case)


## Single Subject ModelFit
We can now define a formula
```julia
f  = @formula 0~1+conditionA*continuousA#+(1|subject)
```

And fit a `UnfoldLinearModel`
```julia
# TODO write the converter to the UnfoldObject
#beta,history =
m = unfold.fit(unfold.UnfoldLinearModel,f,evts_subset,data,basisfunction)
```

```julia
using Gadfly
using DataFramesMeta
Gadfly.push_theme(:dark)

d = @linq m.results |> where(:group.=="fixed")
plot(d,x=:time,y=:estimate,color=:term,Geom.LineGeometry)

```

# TODO plotting
```julia;eval=false
using Weave

# convert to html
weave("doc\\lm_tutorial.jmd")

# convert to a python notebook
convert_doc("doc\\lm_tutorial.jmd", "doc\\lm_tutorial.ipynb")

# convert to md for README
weave("doc\\lm_tutorial.jmd", doctype="pandoc", out_path = "README.md")
```
