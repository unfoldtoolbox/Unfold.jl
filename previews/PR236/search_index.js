var documenterSearchIndex = {"docs":
[{"location":"HowTo/multiple_events/#How-to-model-multiple-events","page":"Multiple events","title":"How to model multiple events","text":"","category":"section"},{"location":"HowTo/multiple_events/","page":"Multiple events","title":"Multiple events","text":"When dealing with overlapping data, it is often necessary to model multiple eventtypes (e.g. fixations, stimuli, responses).","category":"page"},{"location":"HowTo/multiple_events/#Load-Example-Data","page":"Multiple events","title":"Load Example Data","text":"","category":"section"},{"location":"HowTo/multiple_events/","page":"Multiple events","title":"Multiple events","text":"using Unfold\nusing UnfoldMakie, CairoMakie\nusing DataFrames\nusing StatsModels\nusing MixedModels\nusing DisplayAs # hide\n\ninclude(joinpath(dirname(pathof(Unfold)), \"../test/test_utilities.jl\")) # to load data\ndat, evts = loadtestdata(\"test_case_4b\");\n\nevts[1:5,:]","category":"page"},{"location":"HowTo/multiple_events/","page":"Multiple events","title":"Multiple events","text":"The type column of table evts contains two conditions: eventAandeventB(if your eventstypes are specified in a different column, you need to define the keywordargumenteventcolumnin thefit` command below)","category":"page"},{"location":"HowTo/multiple_events/#Specify-formulas-and-basisfunctions","page":"Multiple events","title":"Specify formulas and basisfunctions","text":"","category":"section"},{"location":"HowTo/multiple_events/","page":"Multiple events","title":"Multiple events","text":"\nbf1 = firbasis(τ = (-0.4, 0.8), sfreq = 50)\nbf2 = firbasis(τ = (-0.2, 1.2), sfreq = 50)\nbf2|> DisplayAs.withcontext(:is_pluto=>true) # hide","category":"page"},{"location":"HowTo/multiple_events/","page":"Multiple events","title":"Multiple events","text":"For each event, a basis function and formula must be specified. The same basis and formulas may be used.","category":"page"},{"location":"HowTo/multiple_events/","page":"Multiple events","title":"Multiple events","text":"f  = @formula 0 ~ 1","category":"page"},{"location":"HowTo/multiple_events/","page":"Multiple events","title":"Multiple events","text":"For each event, we must specify the formula and basis function to be used.","category":"page"},{"location":"HowTo/multiple_events/","page":"Multiple events","title":"Multiple events","text":"\nbfDict = [ \"eventA\" => (f, bf1),\n           \"eventB\" => (f, bf2) ]\n\nbfDict |> DisplayAs.withcontext(:is_pluto=>true) # hide","category":"page"},{"location":"HowTo/multiple_events/","page":"Multiple events","title":"Multiple events","text":"Finally, fitting & plotting works the same way as always","category":"page"},{"location":"HowTo/multiple_events/","page":"Multiple events","title":"Multiple events","text":"m = Unfold.fit(\n    UnfoldModel,\n    bfDict,\n    evts,\n    dat,\n    solver = (x, y) -> Unfold.solver_default(x, y; stderror = true),\n    eventcolumn = \"type\",\n)\nresults = coeftable(m)\nplot_erp(results; stderror = true, mapping = (; col = :eventname))","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"EditURL = \"../../../literate/HowTo/FIRduration.jl\"","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"using Unfold\nusing Interpolations\n\nusing UnfoldSim\nusing UnfoldMakie, CairoMakie\nusing DataFrames\nusing DisplayAs # hide\n\ndata, evts = UnfoldSim.predef_eeg(sfreq = 10, n_repeats = 1)\n\nevts.duration = 5:24","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"putting scale_duration = Interpolation.Linear() will introduce a Cameron-Hassall 2022 PNAS- Style basisfunction, that scales with the :duration column","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"basisfunction = firbasis(τ = (-1, 2), sfreq = 5, scale_duration = Interpolations.Linear())","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"Two examples with duration = 10","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"Unfold.kernel(basisfunction, [0, 10])","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"and duration = 20","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"Unfold.kernel(basisfunction, [0, 20])","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"let's fit a model","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"f = @formula 0 ~ 1 + condition\nbf_vec = [Any => (f, basisfunction)]\nm = fit(UnfoldModel, bf_vec, evts, data; eventfields = [:latency, :duration]);\n\n\n# currently bugged for small matrices\n# plot_designmatrix(designmatrix(m))\n# thus using\nheatmap(Matrix(modelmatrix(m))')","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"As one can see, the designmatrix is nicely scaled","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"We can predict overlap-corrected results","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"p = predict(m; overlap = false)[1]\nheatmap(p[1, :, :])","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"note the missings which are displayed as white pixels.","category":"page"},{"location":"generated/HowTo/FIRduration/#Block-design-predictors","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Block-design predictors","text":"","category":"section"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"In contrast, it is also possible to put scale_duration = true - which wil not scale the matrix as before, but introduce a step-function.","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"putting scale_duration = Interpolation.Linear() will introduce a Cameron-Hassall 2022 PNAS- Style basisfunction, that scales with the :duration column","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"basisfunction = firbasis(τ = (-1, 2), sfreq = 5, scale_duration = true)","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"Two examples with duration = 10","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"Unfold.kernel(basisfunction, [0, 10])","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"and duration = 20","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"Unfold.kernel(basisfunction, [0, 20])","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"let's fit a model","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"f = @formula 0 ~ 1 + condition\nbf_vec = [Any => (f, basisfunction)]\nm = fit(UnfoldModel, bf_vec, evts, data; eventfields = [:latency, :duration]);\n\n\nheatmap(Matrix(modelmatrix(m))')","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"as one can see, now the designmatrix is not stretched - but rather \"block\"-ed","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"p = predict(m; overlap = false)[1]\nheatmap(p[1, :, :])","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"","category":"page"},{"location":"generated/HowTo/FIRduration/","page":"Duration-scaled basisfunctions (Hassall-style)","title":"Duration-scaled basisfunctions (Hassall-style)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"91-developer/#dev_docs","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"note: Contributing guidelines\nIf you haven't, please read the Contributing guidelines first.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"If you want to make contributions to this package that involves code, then this guide is for you.","category":"page"},{"location":"91-developer/#First-time-clone","page":"Developer documentation","title":"First time clone","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"tip: If you have writing rights\nIf you have writing rights, you don't have to fork. Instead, simply clone and skip ahead. Whenever upstream is mentioned, use origin instead.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"If this is the first time you work with this repository, follow the instructions below to clone the repository.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Fork this repo\nClone your repo (this will create a git remote called origin)\nAdd this repo as a remote:\ngit remote add upstream https://github.com/unfoldtoolbox/Unfold.jl","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"This will ensure that you have two remotes in your git: origin and upstream. You will create branches and push to origin, and you will fetch and update your local main branch from upstream.","category":"page"},{"location":"91-developer/#Linting-and-formatting","page":"Developer documentation","title":"Linting and formatting","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Install a plugin on your editor to use EditorConfig. This will ensure that your editor is configured with important formatting settings.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"We use https://pre-commit.com to run the linters and formatters. In particular, the Julia code is formatted using JuliaFormatter.jl, so please install it globally first:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"julia> # Press ]\npkg> activate\npkg> add JuliaFormatter","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"To install pre-commit, we recommend using pipx as follows:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"# Install pipx following the link\npipx install pre-commit","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"With pre-commit installed, activate it as a pre-commit hook:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"pre-commit install","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"To run the linting and formatting manually, enter the command below:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"pre-commit run -a","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Now, you can only commit if all the pre-commit tests pass.","category":"page"},{"location":"91-developer/#Testing","page":"Developer documentation","title":"Testing","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"As with most Julia packages, you can just open Julia in the repository folder, activate the environment, and run test:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"julia> # press ]\npkg> activate .\npkg> test","category":"page"},{"location":"91-developer/#Working-on-a-new-issue","page":"Developer documentation","title":"Working on a new issue","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"We try to keep a linear history in this repo, so it is important to keep your branches up-to-date.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Fetch from the remote and fast-forward your local main\ngit fetch upstream\ngit switch main\ngit merge --ff-only upstream/main\nBranch from main to address the issue (see below for naming)\ngit switch -c 42-add-answer-universe\nPush the new local branch to your personal remote repository\ngit push -u origin 42-add-answer-universe\nCreate a pull request to merge your remote branch into the org main.","category":"page"},{"location":"91-developer/#Branch-naming","page":"Developer documentation","title":"Branch naming","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"If there is an associated issue, add the issue number.\nIf there is no associated issue, and the changes are small, add a prefix such as \"typo\", \"hotfix\", \"small-refactor\", according to the type of update.\nIf the changes are not small and there is no associated issue, then create the issue first, so we can properly discuss the changes.\nUse dash separated imperative wording related to the issue (e.g., 14-add-tests, 15-fix-model, 16-remove-obsolete-files).","category":"page"},{"location":"91-developer/#Commit-message","page":"Developer documentation","title":"Commit message","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Use imperative or present tense, for instance: Add feature or Fix bug.\nHave informative titles.\nWhen necessary, add a body with details.\nIf there are breaking changes, add the information to the commit message.","category":"page"},{"location":"91-developer/#Before-creating-a-pull-request","page":"Developer documentation","title":"Before creating a pull request","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"tip: Atomic git commits\nTry to create \"atomic git commits\" (recommended reading: The Utopic Git History).","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Make sure the tests pass.\nMake sure the pre-commit tests pass.\nFetch any main updates from upstream and rebase your branch, if necessary:\ngit fetch upstream\ngit rebase upstream/main BRANCH_NAME\nThen you can open a pull request and work with the reviewer to address any issues.","category":"page"},{"location":"91-developer/#Building-and-viewing-the-documentation-locally","page":"Developer documentation","title":"Building and viewing the documentation locally","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Following the latest suggestions, we recommend using LiveServer to build the documentation. Here is how you do it:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Run julia --project=docs to open Julia in the environment of the docs.\nIf this is the first time building the docs\nPress ] to enter pkg mode\nRun pkg> dev . to use the development version of your package\nPress backspace to leave pkg mode\nRun julia> using LiveServer\nRun julia> servedocs()","category":"page"},{"location":"HowTo/pymne/#Loading-Data-into-Unfold","page":"🐍 Import EEG with PyMNE.jl","title":"Loading Data into Unfold","text":"","category":"section"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"Unfold is generally agnostic to how you load your data. You only require a Matrix (channel x time) or 3D-Array(channel x time x epochs) and an event-dataframe.","category":"page"},{"location":"HowTo/pymne/#Setup","page":"🐍 Import EEG with PyMNE.jl","title":"Setup","text":"","category":"section"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"using Unfold\nusing UnfoldMakie,CairoMakie\nusing PyMNE\nusing DataFrames","category":"page"},{"location":"HowTo/pymne/#MNE-Demo-Dataset","page":"🐍 Import EEG with PyMNE.jl","title":"MNE Demo Dataset","text":"","category":"section"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"The easiest way to showcase this is to simply use a demo-dataset from MNE.","category":"page"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"limo_epochs = PyMNE.datasets.limo.load_data(subject=1,path=\"~/MNE/DATA\",update_path=false)\nlimo_epochs","category":"page"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"Now we can fit a simple Unfold model to it.","category":"page"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"First extract the data & convert it to Julia/Unfold requirements","category":"page"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"data = limo_epochs.get_data(picks=\"B11\")\ndata  = permutedims(data,[2,3,1]) # get into ch x times x epochs\n\nfunction convert_pandas(df_pd)\n      df= DataFrame()\n    for col in df_pd.columns\n        df[!, col] = getproperty(df_pd, col).values\n    end\n    return df\nend\nevents = convert_pandas(limo_epochs.metadata)\nrename!(events,2=>:coherence) # negative signs in formulas are not good ;)\nevents.face = string.(events.face) # ugly names, but fast\n","category":"page"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"Next fit an Unfold Model","category":"page"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"uf = fit(UnfoldModel,[Any=>(@formula(0~face+coherence),Float64.(limo_epochs.times))],events,data)\nresults = coeftable(uf)","category":"page"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"plot_results(results)","category":"page"},{"location":"HowTo/pymne/#Read-some-of-your-own-data","page":"🐍 Import EEG with PyMNE.jl","title":"Read some of your own data","text":"","category":"section"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"We can make use of all PyMNE importer functions to load the data. Try it for your own data! Get starting with Unfold in no-time!","category":"page"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"#eeglabdata = PyMNE.io.read_raw_eeglab(\"pathToEEGLabSet.set\")","category":"page"},{"location":"HowTo/pymne/#Contribute?","page":"🐍 Import EEG with PyMNE.jl","title":"Contribute?","text":"","category":"section"},{"location":"HowTo/pymne/","page":"🐍 Import EEG with PyMNE.jl","title":"🐍 Import EEG with PyMNE.jl","text":"Some extra conversions are needed to import the data from PyMNE to Unfold (as shown above). We could try putting these in a wrapper function - do you want to tackle this challenge? Would be a great first contribution to the toolbox :-)","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"EditURL = \"../../../literate/HowTo/juliacall_unfold.jl\"","category":"page"},{"location":"generated/HowTo/juliacall_unfold/#Using-Unfold.jl-from-Python","page":"🐍 Calling Unfold.jl directly from Python","title":"Using Unfold.jl from Python","text":"","category":"section"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"it is straight forward to call Unfold from Python using JuliaCall.","category":"page"},{"location":"generated/HowTo/juliacall_unfold/#Quick-start","page":"🐍 Calling Unfold.jl directly from Python","title":"Quick start","text":"","category":"section"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Create a Python environment and install JuliaCall.","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"pip install juliacall","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Create a Julia environment and install Unfold","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"# Import the Julia package manager\nfrom juliacall import Pkg as jlPkg\n\n# Activate the environment in the current folder\njlPkg.activate(\".\")\n\n# Install Unfold (in the activated environment)\njlPkg.add(\"Unfold\")","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Import Julia's main module and Unfold","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"# Import Julia's Main module\nfrom juliacall import Main as jl\n\n# Import Unfold\n# The function seval() can be used to evaluate a piece of Julia code given as a string\njl.seval(\"using Unfold\")\nUnfold = jl.Unfold # simplify name","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Now you can use all Unfold functions as for example","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"dummy_model = Unfold.UnfoldLinearModel(jl.Dict())","category":"page"},{"location":"generated/HowTo/juliacall_unfold/#Example:-Unfold-model-fitting-from-Python","page":"🐍 Calling Unfold.jl directly from Python","title":"Example: Unfold model fitting from Python","text":"","category":"section"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"In this notebook, you can find a more detailed example of how to use Unfold from Python to load data, fit an Unfold model and visualise the results in Python.","category":"page"},{"location":"generated/HowTo/juliacall_unfold/#Important-limitations","page":"🐍 Calling Unfold.jl directly from Python","title":"Important limitations","text":"","category":"section"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Python doesnt not offer the full expressions that are available in Julia. So there are some things you need to give special attention:","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"@formula: we havent found a way to call macros yet, even though we think it should be possible. For now please use f = jl.seval(\"@formula(0~1+my+cool+design)\"). Later versions might support something like f = @formula(\"0~1+my+cool+design)\" directly","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Specifying the design: Since Unfold 0.7 we officially switched to the","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"[\"eventtypeA\"=>(formula,basisfunction),\n\"eventtypeB\"=>(otherformula,otherbasisfunction)]","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"Array-based syntax, from a Dict-based syntax. Unfortunately, => (a pair) is not supported in Python and one needs to do some rewriting:","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"jl.convert(jl.Pair,(formula,basisfunction))","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"which makes the code less readable. We are thinking of ways to remedy this - but right now there is now way around. For now, it is also possible to use the old syntax e.g. in python","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"{\"eventtypeA\"=>(formula,basisfunction),\"eventtypeB\"=>(otherformula,otherbasisfunction)}","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"which is clearly easier to read :)","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"UnfoldSim.design: we need a Dict with a Symbol , one has to do something like condition_dict_jl = {convert(jl.Symbol,\"condA\"):[\"car\", \"face\"]} to do so. We will [try to allow strings}(https://github.com/unfoldtoolbox/UnfoldSim.jl/issues/96) here as well, removing this constraint.","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"When preprocessing your raw data through MNE Python, take the following into consideration: The Raw object contains the first_samp attribute which is an integer representing the number of time samples that passed between the onset of the hardware acquisition system and the time when data recording started. The Raw data doesn't include these time samples, meaning that the first sample is the beginning of the data aquisition. From the Raw object you can obtain an events array from the annotations through mne.eventsfromannotations(). The events array, however, does include firstsamp, meaning that the annotated events in events array don't match the Raw object anymore. Alternatively, it might be easier to convert the annotations to a pandas dataframe directly (`todataframe()`), or even better, load the \"*events.tsv\" from a BIDS dataset. In the latter case, all columns will be preserved, which MNE's read_annotation drops.","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"","category":"page"},{"location":"generated/HowTo/juliacall_unfold/","page":"🐍 Calling Unfold.jl directly from Python","title":"🐍 Calling Unfold.jl directly from Python","text":"This page was generated using Literate.jl.","category":"page"},{"location":"references/functions/","page":"API: Functions","title":"API: Functions","text":"Modules = [Unfold]\nOrder   = [:function]","category":"page"},{"location":"references/functions/#Effects.effects-Union{Tuple{T}, Tuple{AbstractDict, T}} where T<:UnfoldModel","page":"API: Functions","title":"Effects.effects","text":"effects(design::AbstractDict, model::UnfoldModel; typical = mean)\n\nCalculates marginal effects for all term combinations in design.\n\nImplementation based on Effects.jl package; likely could repackage in UnfoldEffects.jl; somebody wants to do it? This would make it easier to cross-maintain it to changes/bug fixes in the Effects.jl package. design is a dictionary containing those predictors (as keys) with levels (as values), that you want to evaluate. The typical refers to the value, which other predictors that are not specified in the dictionary, should take on.\n\nFor MixedModels, the returned effects are based on the \"typical\" subject, i.e. all random effects are put to 0.\n\nExample\n\n julia> f = @formula 0 ~ categoricalA + continuousA + continuousB\n julia> uf = fit(UnfoldModel, (Any => (f, times)), data, events)\n julia> d = Dict(:categorical => [\"levelA\", \"levelB\"], :continuous => [-2, 0, 2])\n julia> effects(d, uf)\n\nwill result in 6 predicted values: A/-2, A/0, A/2, B/-2, B/0, B/2.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#FileIO.load-Tuple{Any, Type{<:UnfoldModel}}","page":"API: Functions","title":"FileIO.load","text":"FileIO.load(file, ::Type{<:UnfoldModel}; generate_Xs=true)\n\nLoad UnfoldModel from a .jld2 file.\n\nBy default, the designmatrix is reconstructed. If it is not needed set generate_Xs=false which improves time-efficiency.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#FileIO.save-Union{Tuple{T}, Tuple{Any, T}} where T<:UnfoldModel","page":"API: Functions","title":"FileIO.save","text":"FileIO.save(file, uf::T; compress=false) where {T<:UnfoldModel}\n\nSave UnfoldModel in a (by default uncompressed) .jld2 file.\n\nFor memory efficiency the designmatrix is set to missing. If needed, it can be reconstructed when loading the model.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.coefnames-Tuple{Unfold.TimeExpandedTerm}","page":"API: Functions","title":"StatsAPI.coefnames","text":"coefnames(term)\n\n\ncoefnames of a TimeExpandedTerm concatenates the basis-function name with the kronecker product of the term name and the basis-function colnames. Separator is ' : ' Some examples for a firbasis:         basis313 : (Intercept) : 0.1         basis313 : (Intercept) : 0.2         basis_313 : (Intercept) : 0.3         ...\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.fit-Union{Tuple{T}, Tuple{Type{T}, StatsModels.FormulaTerm, DataFrames.AbstractDataFrame, AbstractArray, Union{Unfold.BasisFunction, AbstractArray}}} where T<:UnfoldModel","page":"API: Functions","title":"StatsAPI.fit","text":"fit(type::UnfoldModel,d::Vector{Pair},tbl::AbstractDataFrame,data::Array)\nfit(type::UnfoldModel,f::FormulaTerm,tbl::AbstractDataFrame,data::Array{T,3},times)\nfit(type::UnfoldModel,f::FormulaTerm,tbl::AbstractDataFrame,data::Array{T,2},basisfunction::BasisFunction)\n\nGenerates Designmatrix & fits model, either mass-univariate (one model per epoched-timepoint) or time-expanded (modeling linear overlap).\n\nkeyword arguments\n\nfit::Bool (default: true) - fit the model after constructing the designmatrix. Setting this to false is sometimes helpful if you only want to inspect the designmatrix.\ncontrasts::Dict: (default: Dict()) contrast to be applied to formula. Example: Dict(:my_condition=>EffectsCoding()). More information here: https://juliastats.org/StatsModels.jl/stable/contrasts/\neventcolumn::Union{Symbol,String} (default :event) - the column in tbl to differentiate the basisfunctions as defined in d::Vector{Pair}\nsolver::function: (default: solver_default). The solver used for y=Xb, e.g. (X,y;kwargs...) -> solver_default(X,y;kwargs...). There are faster & alternative solvers available, see solver_predefined for a list of options, see solver benchmark in the online documentation. To use the GPU, you can provide the data as a CuArray after using CUDA. Please change the solver to e.g. solver_predef(X,y;solver=:qr) as lsmr+cuda => crash typically. It's worth though, speed increases >100x possible\nshow_progress::Bool (default true) - show progress via ProgressMeter - passed to solver\neventfields::Array: (optional, default[:latency]) Array of symbols, representing column names intbl`, which are passed to basisfunction event-wise. First field of array always defines eventonset in samples.\n\nIf a Vector[Pairs] is provided, it has to have one of the following structures: For deconvolution analyses (use Any=>(f,bf) to match all rows of tbl in one basis functions). Assumes data is a continuous EEG stream, either a Vector or a ch x time Matrix\n\nf1 = @formula(0~1+my_condition)\n[\n :A=>(f1,firbasis((-0.1,1),128), # sfreq = 128Hz\n :B=>(f2,firbasis((-3,2),128)\n]\n\nfor mass-univariate analyses without deconvolution. Assumes data to be cut into epochs already (see Unfold.epoch). Follows eeglab standard ch x time x trials:\n\ntimesvector = range(-0.1,3,step=1/100)\n[\n :A=>(f1,timesvector),\n :B=>(f2,timesvector)\n]\n\nNotes\n\nThe type can be specified directly as well e.g. fit(type::UnfoldLinearModel) instead of relying on the automatic inference\nThe data is reshaped if it is missing one dimension to have the first dimension then 1 \"Channel\".\n\nExamples\n\nMass Univariate Linear\n\njulia> data,evts = UnfoldSim.predef_eeg()\njulia> data_e,times = Unfold.epoch(data=data,tbl=evts,τ=(-1.,1.9),sfreq=100) # cut the data into epochs. data_e is now ch x times x epoch\n\njulia> f  = @formula 0~1+continuousA+continuousB\njulia> model = fit(UnfoldModel,f,evts,data_e,times)\n# or:\njulia> model = fit(UnfoldModel,[Any=>(f,times)],evts,data_e)\n\nTimexpanded Univariate Linear\n\njulia> basisfunction = firbasis(τ=(-1,1),sfreq=10)\njulia> model = fit(UnfoldModel,f,evts,data,basisfunction)\n# or\njulia> model = fit(UnfoldModel,[Any=>(f,basisfunction],evts,data)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.modelmatrix","page":"API: Functions","title":"StatsAPI.modelmatrix","text":"StatsModels.modelmatrix(uf::UnfoldLinearModelContinuousTime, basisfunction = true)\n\nSetting the optional second args to false, will return the modelmatrix without the timeexpansion / basisfunction applied.\n\n\n\n\n\n","category":"function"},{"location":"references/functions/#StatsAPI.modelmatrix-Tuple{UnfoldLinearModel, Any}","page":"API: Functions","title":"StatsAPI.modelmatrix","text":"modelmatrix(uf::UnfoldLinearModel)\n\nreturns the modelmatrix of the model. Concatenates them, except in the MassUnivariate cases, where a vector of modelmatrices is return\n\nCompare with modelmatrices which returns a vector of modelmatrices, one per event\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsAPI.predict-Tuple{Any, Vector{<:StatsModels.FormulaTerm}, Vector{<:DataFrames.DataFrame}}","page":"API: Functions","title":"StatsAPI.predict","text":"function predict(\n    uf::UnfoldModel,\n    f::Vector{<:FormulaTerm},\n    evts::Vector{<:DataFrame};\n    overlap::Bool = true,\n    kwargs...\n)\n\nReturns a predicted (\"y_hat = X*b\") Array.\n\nuf is an <:UnfoldModel\nf is a (vector of) formulas, typically Unfold.formulas(uf), but formulas can be modified e.g. by effects.\nevts is a (vector of) events, can be Unfold.events(uf) to return the (possibly continuous-time) predictions of the model. Can be a custom even\n\nkwargs:\n\nif overlap = true (default), overlap based on the latency column of evts will be simulated, or in the case of !ContinuousTimeTrait just X*coef is returned.\n\nif overlap = false, returns predictions without overlap (models with ContinuousTimeTrait (=> with basisfunction / deconvolution) only), via predict_no_overlap\n\nif keep_basis or exclude_basis is defined, then predict_partial_overlap is called, which allows to selective introduce overlap based on specified (or excluded respective) events/basisfunctions\n\nepoch_to and  epoch_timewindow: calculate (partial) overlap controlled predictions, but returns them at the specified epoch_at event, with the times epoch_timewindow (default is taken from the basisfunction) in samples.\n\neventcolumn can be specified as well if different from the default event.\n\nHint: all kwargs can be Vector, or if e.g. string types are provided, will be put into a length==1 vector.\n\nOutput\n\nIf overlap=false, returns a 3D-Array\nIf overlap=true and epoch_to = nothing (default), returns a 2D-array\nIf overlap=true and epoch_to != nothing, returns a 3D array\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#StatsModels.modelcols-Tuple{Unfold.TimeExpandedTerm, Any}","page":"API: Functions","title":"StatsModels.modelcols","text":"modelcols(term, tbl)\n\n\ncalculates the actual designmatrix for a timeexpandedterm. Multiple dispatch on StatsModels.modelcols\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold._modelcols-Tuple{StatsModels.FormulaTerm, Any}","page":"API: Functions","title":"Unfold._modelcols","text":"_modelcols(form::FormulaTerm, events)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold._modelcols-Tuple{Vector, Vector}","page":"API: Functions","title":"Unfold._modelcols","text":"_modelcols(forms::Vector,events::Vector)\n\nA wrapper around StatsModels.modelcols that is only needed for easy multiple dispatch\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.apply_basisfunction-Tuple{Any, Unfold.BasisFunction, Any, Any}","page":"API: Functions","title":"Unfold.apply_basisfunction","text":"apply_basisfunction(\n    form,\n    basisfunction,\n    eventfields,\n    eventname\n)\n\n\ntimeexpand the rhs-term of the formula with the basisfunction\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.combine_yhat!-Union{Tuple{T}, Tuple{Vector{<:Array{T}}, Array{T}}} where T","page":"API: Functions","title":"Unfold.combine_yhat!","text":"combine_yhat(list,single)\n\ncombines single into list, if either list or single contains missing, automatically casts the respective counter-part to allow missings as well\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.designmatrix-Tuple{Any, Any, Any}","page":"API: Functions","title":"Unfold.designmatrix","text":"designmatrix(type, f, tbl; kwargs...)\n\ncall without basis function, continue with basisfunction = nothing\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.designmatrix-Tuple{Type{<:UnfoldModel}, Union{Tuple, StatsModels.FormulaTerm}, Any, Any}","page":"API: Functions","title":"Unfold.designmatrix","text":"designmatrix(\n    unfoldmodeltype,\n    f,\n    tbl,\n    basisfunction;\n    contrasts,\n    eventname,\n    kwargs...\n)\n\n\ndesignmatrix(type, f, tbl; kwargs...) Return a DesignMatrix used to fit the models.\n\nArguments\n\ntype::UnfoldModel\nf::FormulaTerm: Formula to be used in this designmatrix\ntbl: Events (usually a data frame) to be modelled\nbasisfunction::BasisFunction: basisfunction to be used in modeling (if specified)\ncontrasts::Dict: (optional) contrast to be applied to formula\neventfields::Array: (optional) Array of symbols which are passed to basisfunction event-wise.\n\nFirst field of array always defines eventonset in samples. Default is [:latency]\n\nExamples\n\njulia>  designmatrix(UnfoldLinearModelContinuousTime,Dict(Any=>(f,basisfunction1),tbl)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.designmatrix-Tuple{Type{<:UnfoldModel}, Vector{<:Pair}, Any}","page":"API: Functions","title":"Unfold.designmatrix","text":"designmatrix(\n    T::Type{<:UnfoldModel},\n    design_array::Vector{<:Pair},\n    tbl;\n    eventcolumn = :event,\n    contrasts = Dict{Symbol,Any}(),\n    kwargs...,\n\niteratively calls designmatrix for each event in the design_array, and returns a list of <:AbstractDesignMatrix\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.designmatrix-Tuple{UnfoldModel, Any}","page":"API: Functions","title":"Unfold.designmatrix","text":"designmatrix(\n    uf::UnfoldModel,\n    tbl;\n    eventcolumn = :event,\n    contrasts = Dict{Symbol,Any}(),\n    kwargs...,\n\nMain function called from fit(UnfoldModel...), generates the designmatrix, returns a list of <:AbstractDesignMatrix\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.drop_missing_epochs-Union{Tuple{T}, Tuple{Any, AbstractArray{T, 3}}} where T","page":"API: Functions","title":"Unfold.drop_missing_epochs","text":"[X,y] = drop_missing_epochs(X, y::Array)\n\nHelper function to remove epochs of y that contain missings. Drops them from both X and  y. Often used in combination with Unfold.epoch\n\nX can be anything that has two dimensions (Matrix, DataFrame etc)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.empty_modelmatrix-Tuple{AbstractDesignMatrix}","page":"API: Functions","title":"Unfold.empty_modelmatrix","text":"empty_modelmatrix(d::AbstractDesignMatrix)\n\nreturns an empty modelmatrix of the type DesignMatrix type of d\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.epoch-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Any}} where T<:Union{Missing, Number}","page":"API: Functions","title":"Unfold.epoch","text":"epoch(data::Array{T,1},evts::DataFrame,τ::Tuple/Vector,sfreq;kwargs...,\n\nBasic function to epoch data; all input also available as kwargs.\n\nAdditional kwarg: eventtime=:latency, which defines the column in evts that is used to cut the data (in samples). For uneven sample-times we use round()`\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.equalize_size-Union{Tuple{T}, Tuple{AbstractMatrix, AbstractMatrix{T}}} where T<:(Union{Missing, var\"#s132\"} where var\"#s132\"<:Number)","page":"API: Functions","title":"Unfold.equalize_size","text":"equalize_size(X, data)\n\n\nEquates the length of data and designmatrix by cutting the shorter one\n\nThe reason we need this is because when generating the designmatrix, we do not know how long the data actually are. We only assume that event-latencies are synchronized with the data\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.firbasis","page":"API: Functions","title":"Unfold.firbasis","text":"firbasis(τ, sfreq; ...)\nfirbasis(τ, sfreq, name; interpolate, scale_duration)\n\n\nGenerate a sparse FIR basis around the τ timevector at sampling rate sfreq. This is useful if you cannot make any assumptions on the shape of the event responses. If unrounded events are supplied, they are split between samples. E.g. event-latency = 1.2 will result in a \"0.8\" and a \"0.2\" entry.\n\nAdvanced: second input can be duration in samples - careful: times(firbasis) always assumes duration = 1. Therefore, issues with LMM and predict will appear!\n\nkeyword arguments\n\ninterpolate (Bool, default false): if true, interpolates events between samples linearly. This results in predict functions to return a trailling 0scale_duration(Union{Bool,Interpolations-Interpolator}, default false):     if true, scales the response by the fit-kwargseventfieldssecond entry. That is, the FIR becomes a stepfunction instead of a impulse response.     if Interpolations.interpolator, e.g.Interpolations.Linear()- uses the fit-kwargseventfieldssecond entry to stretch the FIR kernel based onimresize`. This implements Hassall\n\nExamples\n\nGenerate a FIR basis function from -0.1s to 0.3s at 100Hz\n\njulia>  f = firbasis([-0.1,0.3],100)\n\nEvaluate at an event occuring at sample 103.3\n\njulia>  f(103.3)\n\n\n\n\n\n","category":"function"},{"location":"references/functions/#Unfold.firkernel-Tuple{Any, Any}","page":"API: Functions","title":"Unfold.firkernel","text":"firkernel(ev, times; interpolate, scale_duration)\n\n\nCalculate a sparse firbasis\n\nsecond input can be duration in samples - careful: times(firbasis) always assumes duration = 1. Therefore, issues with LMM and predict will appear!\n\nExamples\n\njulia>  f = firkernel(103.3,range(-0.1,step=0.01,stop=0.31))\njulia>  f_dur = firkernel([103.3 4],range(-0.1,step=0.01,stop=0.31))\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.formulas-Tuple{Vector{<:Pair}}","page":"API: Functions","title":"Unfold.formulas","text":"formulas(design::Vector{<:Pair})\n\nreturns vector of formulas, no schema has been applied (those formulas never saw the data). Also no timeexpansion has been applied (in the case of timecontinuous models)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.get_basis_colnames-Tuple{AbstractArray{<:StatsModels.FormulaTerm}}","page":"API: Functions","title":"Unfold.get_basis_colnames","text":"get_basis_colnames(m)\nget_basis_colnames(formulas)\n\nreturns list of colnames - e.g. times for firbasis.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.get_basis_indices-Tuple{Any, Vector}","page":"API: Functions","title":"Unfold.get_basis_indices","text":"get_basis_indices(uf, basisnames::Vector)\n\nreturns a boolean vector with length spanning all coefficients, which coefficient is defined by basisnames (vector of names)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.get_basis_names-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T}} where T<:UnfoldModel","page":"API: Functions","title":"Unfold.get_basis_names","text":"get_basisnames(model::UnfoldModel)\n\nReturn the basisnames for all predictor terms as a vector.\n\nThe returned vector contains the name of the event type/basis, repeated by their actual coefficient number (after StatsModels.apply_schema / timeexpansion). If a model has more than one event type (e.g. stimulus and fixation), the vectors are concatenated.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.hrfbasis-Tuple{Float64}","page":"API: Functions","title":"Unfold.hrfbasis","text":"hrfbasis(TR; parameters, name)\n\n\nGenerate a Hemodynamic-Response-Functio (HRF) basis with inverse-samplingrate \"TR\" (=1/FS)\n\nOptional Parameters p:                                                            defaults                                                           {seconds}         p(1) - delay of response (relative to onset)          6         p(2) - delay of undershoot (relative to onset)       16         p(3) - dispersion of response                         1         p(4) - dispersion of undershoot                       1         p(5) - ratio of response to undershoot                6         p(6) - onset {seconds}                                0         p(7) - length of kernel {seconds}                    32\n\nExamples\n\nGenerate a HRF basis function object with Sampling rate 1/TR. And evaluate it at an event occuring at TR 103.3 with duration of 4.1 TRs\n\njulia>  f = hrfbasis(2.3)\njulia>  f(103.3,4.1)\n\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.hrfkernel-Tuple{Any, Any, Any}","page":"API: Functions","title":"Unfold.hrfkernel","text":"hrfkernel(e, TR, p)\n\n\nCalculate a HRF kernel. Input e can be [onset duration]\n\nExamples\n\njulia>  f = hrfkernel(103.3,2.3,[6. 16. 1. 1. 6. 0. 32.])\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.linearize-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"API: Functions","title":"Unfold.linearize","text":"linearize(x)\n\n\nFlatten a 1D array from of a 2D/3D array. Also drops the empty dimension\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.matrix_by_basisname-Tuple{AbstractMatrix, Any, Vector}","page":"API: Functions","title":"Unfold.matrix_by_basisname","text":"Returns a view of the Matrix y, according to the indices of the timeexpanded basisname\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.modelmatrices-Tuple{AbstractDesignMatrix}","page":"API: Functions","title":"Unfold.modelmatrices","text":"modelmatrices(X::AbstractDesignMatrix)\nmodelmatrices(X::Vector{<:AbstractDesignMatrix})\nmodelmatrices(modelmatrix::AbstractMatrix)\n\nReturns the modelmatrices (also called designmatrices) separately for the events. This is similar to StatsModels.modelcols, but merely access the precomputed designmatrix. If the designmatrix needs to be computed, please use modelcols\n\nCompare to modelmatrix which further concatenates the designmatrices (in the ContinuousTime case).\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.predict_no_overlap-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T, Any, Vector, Vector}} where T<:UnfoldModel","page":"API: Functions","title":"Unfold.predict_no_overlap","text":"predict_no_overlap(, uf, coefs, f, evts)\n\n\nin ContinuousTime case (typically the deconvolution model), we return idealized predictions without overlap between events.\n\nin the Not-ContinuousTime case (typically the MassUnivariate model), we return predictions for each event independently. In that case, the function is unfortunately a missnomer, as overlap cannot be removed from mass-univariate models.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.predict_partial_overlap-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T, Any}} where T<:UnfoldModel","page":"API: Functions","title":"Unfold.predict_partial_overlap","text":"predict_partial_overlap(, uf, args; kwargs...)\n\n\nReturns predicted time-continuous values, but only for a subset of events. This is achieved by excluding the part of the designmatrix that belongs to the basisfunctions/events you do not want to have in your model.\n\nTypically called via predict, for configuration, keyword-arguments and usage see there.\n\nOne difference is, that we require the coefs(uf::UnfoldModel) already exctracted.\n\nDue to the time-continuous nature, running it with a model not containing the ContinuousTimeTrait it will throw an error.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.predicttable","page":"API: Functions","title":"Unfold.predicttable","text":"predicttable(model<:UnfoldModel,events=Unfold.events(model),args...;kwargs...)\n\nShortcut to call efficiently call (pseudocode) result_to_table(predict(...)).\n\nReturns a tidy DataFrame with the predicted results. Loops all input to predict, but really only makes sense to use if you specify either:\n\noverlap = false (the default) or epoch_to = \"eventname\".\n\n\n\n\n\n","category":"function"},{"location":"references/functions/#Unfold.prepare-Union{Tuple{T}, Tuple{Any, AbstractMatrix{<:Union{Missing, T}}}} where T<:Number","page":"API: Functions","title":"Unfold.prepare","text":"prepare(X, data)\n\n\nconvert and permutedim input to follow the following output:\n\nĤ, Y, X = prepare(X, data)\n\nwhere Ĥ is used to save the beta, Y is the data in format ch x repeat x time (with size(time) = 1 if data is a Matrix), and X.\n\nif data is a CuArray, everything is transformed to CuArrays as well (via UnfoldCUDAExt.jl, CUDA needs to be loaded)\nsame datatype between X and data is enforced\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.prepare_XTX-Tuple{Tuple}","page":"API: Functions","title":"Unfold.prepare_XTX","text":"prepare_XTX(all)\n\n\ninstead of solving y = Xb, we solve X'Xb = X'y. This function calculates X'X and instantiates X'y to be used in the solver-step, to facilitate X'y calculations later, X' is also calculated.\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.prepare_pinv-Tuple{Tuple}","page":"API: Functions","title":"Unfold.prepare_pinv","text":"prepare_pinv(all)\n\n\ncalculates pinv of the designmatrix for later use in the solver-step. This is helpful in case you have many chanels\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.result_to_table-Tuple{Any, Any, Vector{<:DataFrames.DataFrame}}","page":"API: Functions","title":"Unfold.result_to_table","text":"result_to_table(model<:UnfoldModel, eff::AbstractArray, events::Vector{<:DataFrame})\nresult_to_table(\n    eff::AbstractArray,\n    events::Vector{<:DataFrame},\n    times::Vector{<:Vector{<:Number}},\n    eventnames::Vector)\nresult_to_table(\n    eff::Vector{<:AbstractArray},\n    events::Vector{<:DataFrame},\n    times::Vector,\n    eventnames::Vector,\n)\n\nConverts an array-result (prediction or coefficient) together with the events, to a tidy dataframe.\n\nTo support multi-event models, we expect everything to be put into Vectors - this should be refactored at some point to be compatible with broadcasting, but it is not right now.\n\nargs\n\neff: Contains the array(s) to be converted to a tidy dataframe. Should be 3D, with channel x time x predictor events: A vector of event-dataframes, each need to match size(eff,3) times: A vector of time-vectors, each need to match size(eff,2) eventnames: A vector of eventnames, either symbols or strings, should be a single entry per event\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.solver_default-Tuple{Any, AbstractMatrix}","page":"API: Functions","title":"Unfold.solver_default","text":"solver_default(X, y; kwargs...)\n\n\ndefault solvers.\n\nIf data is continuous (2D), we solve Xb = y via lsmr\nIf data is epoched (3D) we solve Xb = y via pinv\n\nWe highly recommend to check out solver_predefined for faster options by rather solving X'Xb = X'y via QR, cholesky, pinv or ``-solver. A benchmark is available in the online documentation.\n\nPlease see ?solver_main for keyword arguments of the solver (like stderror, multithreading, show_time, show_progress)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.solver_predefined-Tuple{Any, AbstractMatrix}","page":"API: Functions","title":"Unfold.solver_predefined","text":"solver_predefined(X, y_in; solver, kwargs...)\n\n\nhelper function that returns solver with appropriate prepare-pipelines and fitting solver-functions. X is a (typically sparse) designmatrix, y is a 2D or 3D array.\n\nsolver : one of :cg, :pinv, :intern, :qr, :cholesky, :lsmr (default)\n\nOnly lsmr solves Xb = y via an iterative solver and should be more accurate in principle.\n\nThe other predefined-solvers solve X'Xb = X'y which is often computationally much cheaper, and because X'X can be precalculated, it should be cheaper to apply.\n\nTesting this empirically is somewhat complicated, as depending on your sparsity structure (≈ your design) and the size of your data (sfreq & minutes) the best solver and the reached accuracy can change quite a bit.\n\nGPU\n\nAll solvers except :lsmr support GPU calculations. For lsmr on the GPU try solver_krylov instead\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.spdiagm_diag-Union{Tuple{T}, Tuple{Any, Vararg{Pair{<:Integer, T}}}} where T","page":"API: Functions","title":"Unfold.spdiagm_diag","text":"Speed improved version of spdiagm, takes a single float value instead of a vector, like a version of spdiagm that takes in a UniformScaling\n\ne.g.\n\nsz = 5 ix = [1,3,10] spdiagm_diag(sz,(.-ix.=>1)...)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.time_expand_allBasesSameCols-Tuple{FIRBasis, Any, Any}","page":"API: Functions","title":"Unfold.time_expand_allBasesSameCols","text":"Helper function to decide whether all bases have the same number of columns per event\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.timeexpand_cols-NTuple{4, Any}","page":"API: Functions","title":"Unfold.timeexpand_cols","text":"timeexpand_cols(basisfunction, bases, ncolsBasis, ncolsX)\n\n\ncalculates in which rows the individual event-basisfunctions should go in Xdc\n\nsee also timeexpandrows timeexpandvals\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.timeexpand_rows-NTuple{4, Any}","page":"API: Functions","title":"Unfold.timeexpand_rows","text":"timeexpand_rows(onsets, bases, shift, ncolsX)\n\n\ncalculates in which rows the individual event-basisfunctions should go in Xdc\n\ntimeexpandrows timeexpandvals\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.times-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T}} where T<:UnfoldModel","page":"API: Functions","title":"Unfold.times","text":"times(model<:UnfoldModel)\n\nreturns arrays of time-vectors, one for each basisfunction / parallel-fitted-model (MassUnivarite case)\n\n\n\n\n\n","category":"method"},{"location":"references/functions/#Unfold.unfold_apply_schema-Tuple{Any, Any, Any}","page":"API: Functions","title":"Unfold.unfold_apply_schema","text":"wrapper to make apply_schema mixed models as extension possible\n\nNote: type is not necessary here, but for LMM it is for multiple dispatch reasons!\n\n\n\n\n\n","category":"method"},{"location":"tutorials/lm_overlap/#lm_overlap","page":"rERP (overlap correction)","title":"Linear Model with Overlap Correction","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"note: Note\nWe recommend you briefly go over the mass-univariate linear modelling tutorial","category":"page"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"In this notebook we will fit regression models to (simulated) EEG data. We will see that we need some type of overlap correction, as the events are close in time to each other, so that the respective brain responses overlap. If you want more detailed introduction to this topic check out our paper.","category":"page"},{"location":"tutorials/lm_overlap/#Setting-up-and-loading-the-data","page":"rERP (overlap correction)","title":"Setting up & loading the data","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"using Unfold\nusing UnfoldSim\nusing UnfoldMakie,CairoMakie\nusing DataFrames\nusing DisplayAs # hide\n\ndata, evts = UnfoldSim.predef_eeg()\nnothing # hide","category":"page"},{"location":"tutorials/lm_overlap/#Overlap-Correction","page":"rERP (overlap correction)","title":"Overlap Correction","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"For an overlap correction analysis we will do one additional step: define a temporal basisfunction. The steps are as following:","category":"page"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"specify a temporal basisfunction\nspecify a formula\nfit a linear model for each channel (one for all timepoints!)\nvisualize the results.","category":"page"},{"location":"tutorials/lm_overlap/#Timeexpanded-/-Deconvolved-ModelFit","page":"rERP (overlap correction)","title":"Timeexpanded / Deconvolved ModelFit","text":"","category":"section"},{"location":"tutorials/lm_overlap/#1.-specify-a-temporal-basisfunction","page":"rERP (overlap correction)","title":"1. specify a temporal basisfunction","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"By default, we would want to use a FIR basisfunction. See Basis Functions for more details.","category":"page"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"basisfunction = firbasis(τ=(-0.4,.8),sfreq=100)\nnothing #hide","category":"page"},{"location":"tutorials/lm_overlap/#2.-specify-a-formula","page":"rERP (overlap correction)","title":"2. specify a formula","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"We specify the same formula as before","category":"page"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"f  = @formula 0~1+condition+continuous\nnothing #hide","category":"page"},{"location":"tutorials/lm_overlap/#3.-fit-the-linear-model","page":"rERP (overlap correction)","title":"3. fit the linear model","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"The formula and basisfunction is not enough on their own. We also need to specify which event and which formula matches - this is important in cases where there are multiple events with different formulas","category":"page"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"bf_vec = [Any=>(f,basisfunction)]\nbf_vec|> DisplayAs.withcontext(:is_pluto=>true) # hide","category":"page"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"note: Note\nThe Any means to use all rows in evts. In case you have multiple events, you'd want to specify multiple basisfunctions e.g.   bfDict = [\"stimulus\"=>(f1,basisfunction1),                 \"response\"=>(f2,basisfunction2)]   You likely have to specify a further argument to fit: eventcolumn=\"type\" with type being the column in evts that codes for the event (stimulus / response in this case)","category":"page"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"Now we are ready to fit a UnfoldLinearModel. Not that instead of times as in the mass-univariate case, we have to provide the BasisFunction type now.","category":"page"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"m = fit(UnfoldModel,bf_vec,evts,data);\nnothing #hide","category":"page"},{"location":"tutorials/lm_overlap/#4.-Visualize-the-model","page":"rERP (overlap correction)","title":"4. Visualize the model","text":"","category":"section"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"Similarly to the previous tutorial, we can visualize the model","category":"page"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"results = coeftable(m)\nplot_erp(results)","category":"page"},{"location":"tutorials/lm_overlap/","page":"rERP (overlap correction)","title":"rERP (overlap correction)","text":"Cool! All overlapping activity has been removed and we recovered the simulated underlying signal.","category":"page"},{"location":"installation/#install_instruct","page":"Installing Julia + Unfold.jl","title":"Installation","text":"","category":"section"},{"location":"installation/#Installing-Julia","page":"Installing Julia + Unfold.jl","title":"Installing Julia","text":"","category":"section"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"The easiest way to install julia is using juliaup","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"TLDR;","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"Windows: winget install julia -s msstore\nMac/Linux: curl -fsSL https://install.julialang.org | sh","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"We further recommend to use VSCode. Make sure to install the Julia-Plugin, and install Revise.jl - a tutorial with screenshots can be found here","category":"page"},{"location":"installation/#Installing-Unfold.jl","page":"Installing Julia + Unfold.jl","title":"Installing Unfold.jl","text":"","category":"section"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"You can enter the package manager (similar to conda) using ] in the REPL (\"julia-commandline\").","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"This should result in (currentFolder) pkg> (with currentFolder being the project you currently work in)","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"hint: Hint\nif you see (@v1.9) pkg> instead, you still have to activate your environment. This can be done using:cd(\"/path/to/your/project\")  and ]activate .or alternatively ]activate /path/to/your/project/","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"Now you can do pkg> add Unfold","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"and after some installation:","category":"page"},{"location":"installation/","page":"Installing Julia + Unfold.jl","title":"Installing Julia + Unfold.jl","text":"julia> using Unfold in the REPL","category":"page"},{"location":"tutorials/lm_mu/#lm_massunivariate","page":"rERP (mass univariate)","title":"Mass Univariate Linear Models (no overlap correction)","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"In this notebook we will fit regression models to simulated EEG data. We will see that we need some type of overlap correction, as the events are close in time to each other, so that the respective brain responses overlap. If you want more detailed introduction to this topic check out our paper.","category":"page"},{"location":"tutorials/lm_mu/#Setting-up-and-loading-the-data","page":"rERP (mass univariate)","title":"Setting up & loading the data","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"using DataFrames\nusing Unfold\nusing UnfoldMakie, CairoMakie # for plotting\nusing UnfoldSim\nusing DisplayAs # hide\n\nnothing # hide","category":"page"},{"location":"tutorials/lm_mu/#Load-Data","page":"rERP (mass univariate)","title":"Load Data","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"We'll start with some predefined simulated continuos EEG data. We have 2000 events, 1 channel and one condition with two levels","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"data, evts = UnfoldSim.predef_eeg()\nnothing # hide","category":"page"},{"location":"tutorials/lm_mu/#Inspection","page":"rERP (mass univariate)","title":"Inspection","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"The data has only little noise. The underlying signal pattern is a positive-negative-positive spike.","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"times_cont = range(0,length=200,step=1/100) # we simulated with 100hz for 0.5 seconds\n\nf,ax,h = plot(times_cont,data[1:200])\nvlines!(evts[evts.latency .<= 200, :latency] ./ 100;color=:black) # show events, latency in samples!\nax.xlabel = \"time [s]\"\nax.ylabel = \"voltage [µV]\"\nf","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"To inspect the event dataframe we use","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"show(first(evts, 6), allcols = true)","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"Every row is an experimental event. Note that :latency refers to time in samples, (in BIDS-specification,  :onset would typically refer to seconds).","category":"page"},{"location":"tutorials/lm_mu/#Traditional-Mass-Univariate-Analysis","page":"rERP (mass univariate)","title":"Traditional Mass Univariate Analysis","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"To perform a mass univariate analysis, you must complete the following steps:","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"Split data into epochs\nSpecify a formula\nFit a linear model to each time point & channel\nVisualize the results.","category":"page"},{"location":"tutorials/lm_mu/#1.-Split-data-into-epochs","page":"rERP (mass univariate)","title":"1. Split data into epochs","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"Initially, you have data with a duration that represents the whole experimental trial. You need to cut the data into small regular epochs related to the some event, e.g. start of fixation.","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"# Unfold supports multi-channel, so we could provide matrix ch x time, which we can create like this from a vector:\ndata_r = reshape(data, (1,:))\n# cut the data into epochs\ndata_epochs, times = Unfold.epoch(data = data, tbl = evts, τ = (-0.4, 0.8), sfreq = 100); # channel x timesteps x trials\nsize(data_epochs)","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"τ specifies the epoch size.\nsfreq - sampling rate, converts τ to samples.","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"typeof(data_epochs)","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"note: Note\nIn julia, missing is supported throughout the ecosystem. Thus, we can have partial trials and they will be incorporated / ignored at the respective functions. Helpful functions are the julia-base disallowmissing and the internal Unfold.drop_missing_epochs functions","category":"page"},{"location":"tutorials/lm_mu/#2.-Specify-a-formula","page":"rERP (mass univariate)","title":"2. Specify a formula","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"Define a formula to be applied to each time point (and each channel) relative to the event. condition and continuous are the names of the event-describing columns in evts that we want to use for modelling.","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"f = @formula 0 ~ 1 + condition + continuous # note the formulas left side is `0 ~ ` for technical reasons`\nnothing # hide","category":"page"},{"location":"tutorials/lm_mu/#3.-Fit-a-linear-model-to-each-time-point-and-channel","page":"rERP (mass univariate)","title":"3. Fit a linear model to each time point & channel","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"Fit the \"UnfoldModel\" (the fit syntax is used throughout the Julia ecosystem, with the first element indicating what kind of model to fit)","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"m = fit(UnfoldModel, f, evts, data_epochs, times);\nnothing #hide","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"Alternative way to call this model is below. This syntax allows you to fit multiple events at once. For example, replacing Any with :fixation =>... will fit this model specifically to the fixation event type.","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"m = fit(UnfoldModel, [Any=>(f, times)], evts, data_epochs);\nnothing #hide","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"Inspect the fitted model:","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"m\nm|> DisplayAs.withcontext(:is_pluto=>true) # hide","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"Note these functions to discover the model: design, designmatrix, modelfit and most importantly, coeftable.","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"info: Info\nThere are of course further methods, e.g. `coef`, `ranef`, `Unfold.formula`, `modelmatrix` which might be helpful at some point, but not important now.","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"Using coeftable, we can get a tidy DataFrames, very useful for your further analysis.","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"first(coeftable(m), 6)","category":"page"},{"location":"tutorials/lm_mu/#4.-Visualize-the-results","page":"rERP (mass univariate)","title":"4. Visualize the results","text":"","category":"section"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"Tidy DataFrames are easy to visualize using e.g. AlgebraOfGraphics.jl. Function plot_erp from UnfoldMakiemakes it even easier.","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"results = coeftable(m)\nplot_erp(results)","category":"page"},{"location":"tutorials/lm_mu/","page":"rERP (mass univariate)","title":"rERP (mass univariate)","text":"As you can see, there is a lot going on, even in the baseline period! This is because the signal was simulated with overlapping events. In the next tutorial you will learn how to fix this.","category":"page"},{"location":"references/extensions/#Package-extensions","page":"Overview of package extensions","title":"Package-extensions","text":"","category":"section"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"In  Julia 1.9 Package Extensions were introduced. Unfold.jl is making use of them in four ways. Prior to using some functionality, you have to add + load specific package(s) for the functionality to be available. The reason for this is, that if you don't need e.g. GPU-support, you also will not need to install it.","category":"page"},{"location":"references/extensions/#MixedModels","page":"Overview of package extensions","title":"MixedModels","text":"","category":"section"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"To use formulas like @formula(0~1+condition+(1+condition|subject)) you have to load MixedModels. e.g.","category":"page"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"using MixedModels\nusing Unfold","category":"page"},{"location":"references/extensions/#GPU:-Krylov,CUDA","page":"Overview of package extensions","title":"GPU: Krylov,CUDA","text":"","category":"section"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"To use gpu support as described in @Ref(custom_solvers) you have to:","category":"page"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"using Krylov,CUDA\nusing Unfold","category":"page"},{"location":"references/extensions/#RobustSolvers.jl","page":"Overview of package extensions","title":"RobustSolvers.jl","text":"","category":"section"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"To use robust (outlier-\"safe\") solvers support as described in @Ref(custom_solvers) you have to:","category":"page"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"using RobustSolvers\nusing Unfold","category":"page"},{"location":"references/extensions/#Non-linear-effects:-BSplineKit.jl","page":"Overview of package extensions","title":"Non-linear effects: BSplineKit.jl","text":"","category":"section"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"Finally to use non-linear effects/splines like in @formula 0~1+spl(continuous,5) you have to use:","category":"page"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"using BSplineKit\nusing Unfold","category":"page"},{"location":"references/extensions/","page":"Overview of package extensions","title":"Overview of package extensions","text":"note: Note\nIn principle you should be able to load the package after loading Unfold. But sometimes this doesnt work, a Base.retry_load_extensions() call might help in these situations.","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"EditURL = \"../../../literate/HowTo/contrasts.jl\"","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"using CairoMakie\nusing Unfold\nusing UnfoldMakie\nusing UnfoldSim\n\n\n# Contrast coding","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"Unfold.jl uses the StatsModels package for the formula interface. This allows for a wide range of contrast coding schemes. For a full tutorial, please see the StatsModels docs. Please read their tutorial, as a motivation of why one would change the contrast coding scheme is outside of the realms of this package and more a basic linear regression question.","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"hint: Hint\nGiven we have a nice effects implementation (mimicking emmeans and similar packages), coding schema is typically less important.","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"Here we will show a simple example of how to change the contrast coding scheme. We will use the condition variable, which has two levels, A and B. We will change the contrast coding from Dummy aka Reference aka 0/1 coding to Sum coding, which is the default in R.","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"eeg, evts = UnfoldSim.predef_eeg(noiselevel = 0)\nf = @formula 0 ~ 1 + condition\nbasis = firbasis((-0.1, 0.6), 100)\nm_dummy = fit(UnfoldModel, f, evts, eeg, basis)\nm_effec =\n    fit(UnfoldModel, f, evts, eeg, basis; contrasts = Dict(:condition => EffectsCoding()))","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"we could directly inspect the designmatrix","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"modelmatrix(m_dummy, false)[1][1:5, :]","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"and the effects coding","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"modelmatrix(m_effec, false)[1][1:5, :]","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"To confirm the difference in the actual fit, let's visualize them","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"c_d = coeftable(m_dummy)\nc_e = coeftable(m_effec)\nc_d.group .= \"Dummy Coding\"\nc_e.group .= \"Effects Coding\"\nc = vcat(c_d, c_e)\n\nplot_erp(c; mapping = (; color = :coefname, col = :group))","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"As expected, the effects-coding slope of condition: face is half the size of the dummy-coding one (because -1/1 coding was used).","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"","category":"page"},{"location":"generated/HowTo/contrasts/","page":"Change contrasts / coding schema","title":"Change contrasts / coding schema","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/lmm_mu/#lmm_massunivariate","page":"lmmERP (mass univariate)","title":"Mass Univariate Linear Mixed Models","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"\nusing Unfold\nusing UnfoldSim\nusing MixedModels # important to load to activate the UnfoldMixedModelsExtension\nusing UnfoldMakie, CairoMakie # plotting\nusing DataFrames\nusing CategoricalArrays\nnothing;#hide","category":"page"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"important: Important\nYou have to run using MixedModels before or after loading Unfold to activate the MixedModels abilities!","category":"page"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"This notebook is similar to the Mass Univariate Linear Models (no overlap correction) tutorial, but fits mass-univariate mixed models - that is, one model over all subjects, instead of one model per subject. This allows to include item effects, for example.","category":"page"},{"location":"tutorials/lmm_mu/#Mass-Univariate-**Mixed**-Models","page":"lmmERP (mass univariate)","title":"Mass Univariate Mixed Models","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"Again we have 4 steps:","category":"page"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"Split data into epochs\nSpecify a formula\nFit a linear model to each time point & channel\nVisualize the results.","category":"page"},{"location":"tutorials/lmm_mu/#1.-Epoching","page":"lmmERP (mass univariate)","title":"1. Epoching","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"data, evts = UnfoldSim.predef_eeg(10; return_epoched = true) # simulate 10 subjects\ndata = reshape(data, 1, size(data, 1), :) # concatenate the data into a long EEG dataset\ntimes = range(0, length = size(data, 2), step = 1 / 100)\ntransform!(evts, :subject => categorical => :subject); # :subject must be categorical, otherwise MixedModels.jl complains\nnothing #hide","category":"page"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"The events dataFrame has an additional column (besides being much taller): subject","category":"page"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"first(evts, 6)","category":"page"},{"location":"tutorials/lmm_mu/#2.-Formula-specification","page":"lmmERP (mass univariate)","title":"2. Formula specification","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"We define the formula. Importantly, we need to specify a random effect. We use zerocorr to speed up the calculation.","category":"page"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"f = @formula 0 ~ 1 + condition * continuous + zerocorr(1 + condition * continuous | subject);\nnothing #hide","category":"page"},{"location":"tutorials/lmm_mu/#3.-Model-fitting","page":"lmmERP (mass univariate)","title":"3. Model fitting","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"We can now run the LinearMixedModel at each time point.","category":"page"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"m = fit(UnfoldModel, f, evts, data, times)\nnothing #hide","category":"page"},{"location":"tutorials/lmm_mu/#4.-Visualization-of-results","page":"lmmERP (mass univariate)","title":"4. Visualization of results","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"Let's start with the fixed effects. We see the condition effects and some residual overlap activity in the fixed effects.","category":"page"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"results = coeftable(m)\n\nres_fixef = results[isnothing.(results.group), :]\nplot_erp(res_fixef)","category":"page"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"And now comes the random effect:","category":"page"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"res_ranef = results[results.group .== :subject, :]\nplot_erp(res_ranef)","category":"page"},{"location":"tutorials/lmm_mu/#Statistics","page":"lmmERP (mass univariate)","title":"Statistics","text":"","category":"section"},{"location":"tutorials/lmm_mu/","page":"lmmERP (mass univariate)","title":"lmmERP (mass univariate)","text":"Check out the LMM p-value tutorial","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"EditURL = \"../../../literate/explanations/nonlinear_effects.jl\"","category":"page"},{"location":"generated/explanations/nonlinear_effects/#[Non-linear-effects]](@id-nonlinear)","page":"Non-Linear effects","title":"[Non-linear effects]](@id nonlinear)","text":"","category":"section"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"using BSplineKit, Unfold\nusing CairoMakie\nusing DataFrames\nusing Random\nusing Colors\nusing Missings","category":"page"},{"location":"generated/explanations/nonlinear_effects/#Generating-a-non-linear-signal","page":"Non-Linear effects","title":"Generating a non-linear signal","text":"","category":"section"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"We start with generating data variables","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"rng = MersenneTwister(2) # make repeatable\nn = 20 # number of datapoints\nevts = DataFrame(:x => rand(rng, n))\nsignal = -(3 * (evts.x .- 0.5)) .^ 2 .+ 0.5 .* rand(rng, n)\n\nplot(evts.x, signal)","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Looks perfectly non-linear. Great!","category":"page"},{"location":"generated/explanations/nonlinear_effects/#Compare-linear-and-non-linear-fit","page":"Non-Linear effects","title":"Compare linear & non-linear fit","text":"","category":"section"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"First, we have to reshape signal data to a 3d array, so it will fit to Unfold format:  1 channel x 1 timepoint x 20 datapoints.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"signal = reshape(signal, length(signal), 1, 1)\nsignal = permutedims(signal, [3, 2, 1])\nsize(signal)","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Next we define three different models: linear, 4 splines and 10 splines. Note difference in formulas: one x, the other spl(x, 4).","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"design_linear = [Any => (@formula(0 ~ 1 + x), [0])];\ndesign_spl3 = [Any => (@formula(0 ~ 1 + spl(x, 4)), [0])];\ndesign_spl10 = [Any => (@formula(0 ~ 1 + spl(x, 10)), [0])];\nnothing #hide","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Next, fit the parameters.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"uf_linear = fit(UnfoldModel, design_linear, evts, signal);\nuf_spl3 = fit(UnfoldModel, design_spl3, evts, signal);\nuf_spl10 = fit(UnfoldModel, design_spl10, evts, signal); #hide\nnothing #hide","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Extract the fitted values using Unfold.effects.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"p_linear = Unfold.effects(Dict(:x => range(0, stop = 1, length = 100)), uf_linear);\np_spl3 = Unfold.effects(Dict(:x => range(0, stop = 1, length = 100)), uf_spl3);\np_spl10 = Unfold.effects(Dict(:x => range(0, stop = 1, length = 100)), uf_spl10);\nfirst(p_linear, 5)","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Plot them.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"pl = plot(evts.x, signal[1, 1, :])\nlines!(p_linear.x, p_linear.yhat)\nlines!(p_spl3.x, coalesce.(p_spl3.yhat, NaN))\nlines!(p_spl10.x, coalesce.(p_spl10.yhat, NaN))\npl","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"We see here, that the linear effect (blue line) underfits the data, the yellow spl(x, 10) overfits it, but the green spl(x, 4) fits it perfectly.","category":"page"},{"location":"generated/explanations/nonlinear_effects/#Looking-under-the-hood","page":"Non-Linear effects","title":"Looking under the hood","text":"","category":"section"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Let's have a brief look how the splines manage what they are managing.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"The most important bit to understand is, that we are replacing x by a set of coefficients spl(x). These new coefficients each tile the range of x (in our case, from [0-1]) in overlapping areas, while each will be fit by one coefficient. Because the ranges are overlapping, we get a smooth function.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Maybe this becomes clear after looking at a basisfunction:","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"term_spl = Unfold.formulas(uf_spl10)[1].rhs.terms[2]","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"This is the spline term. Note, this is a special type available in the BSplineKit.jl extension in Unfold.jl. It's abstract type is AbstractSplineTerm defined in Unfold.jl","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"typeof(term_spl)","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"const splFunction = Base.get_extension(Unfold, :UnfoldBSplineKitExt).splFunction\nsplFunction([0.2], term_spl)","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Each column of this 1-row matrix is a coefficient for our regression model.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"lines(disallowmissing(splFunction([0.2], term_spl))[1, :])","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Note: We have to use disallowmissing, because our splines return a missing whenever we ask it to return a value outside its defined range, e.g.:","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"splFunction([-0.2], term_spl)","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Because it never has seen any data outside and can't extrapolate!","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Back to our main issue. Let's plot the whole basis set","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"basisSet = splFunction(0.0:0.01:1, term_spl)\nbasisSet = disallowmissing(basisSet[.!any(ismissing.(basisSet), dims = 2)[:, 1], :]) # remove missings\nax = Axis(Figure()[1, 1])\n[lines!(ax, basisSet[:, k]) for k = 1:size(basisSet, 2)]\ncurrent_figure()","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Notice how we flipped the plot around, i.e. now on the x-axis we do not plot the coefficients, but the x-values. Now each line is one basis-function of the spline.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Unfold returns us one coefficient per basis-function","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"β = coef(uf_spl10)[1, 1, :]\nβ = Float64.(disallowmissing(β))","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"But because we used an intercept, we have to do some remodelling in the basisSet.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"X = hcat(ones(size(basisSet, 1)), basisSet[:, 1:5], basisSet[:, 7:end])","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Now we can weight the spline by the basisfunction.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"weighted = (β .* X')","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Plotting them creates a nice looking plot!","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"ax = Axis(Figure()[1, 1])\n[lines!(weighted[k, :]) for k = 1:10]\ncurrent_figure()","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"Now sum them up.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"lines(sum(weighted, dims = 1)[1, :])\nplot!(X * β, color = \"gray\") #(same as matrixproduct X*β directly!)\ncurrent_figure()","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"And this is how you can think about splines.","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"","category":"page"},{"location":"generated/explanations/nonlinear_effects/","page":"Non-Linear effects","title":"Non-Linear effects","text":"This page was generated using Literate.jl.","category":"page"},{"location":"HowTo/lmm_pvalues/#lmm_pvalues","page":"P-values for mixedModels","title":"How To get P-Values for Mass-Univariate LMM","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"There are currently two ways to obtain p-values for LMMs: Wald's t-test and likelihood ratio tests (mass univariate only).","category":"page"},{"location":"HowTo/lmm_pvalues/#Setup","page":"P-values for mixedModels","title":"Setup","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"using MixedModels, Unfold # we require to load MixedModels to load the PackageExtension\nusing DataFrames\nusing UnfoldSim\nusing CairoMakie\nusing DisplayAs # hide\ndata_epoch, evts =\n    UnfoldSim.predef_2x2(; n_items = 52, n_subjects = 40, return_epoched = true)\ndata_epoch = reshape(data_epoch, size(data_epoch, 1), :) #\ntimes = range(0, 1, length = size(data_epoch, 1))","category":"page"},{"location":"HowTo/lmm_pvalues/#Define-f0-and-f1-and-fit","page":"P-values for mixedModels","title":"Define f0 & f1 and fit","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"\nf0 = @formula 0 ~ 1 + A + (1 + A | subject);\nf1 = @formula 0 ~ 1 + A + B + (1 + A | subject); # could also differ in random effects\n\nm0 = fit(UnfoldModel,[Any=>(f0,times)],evts,data_epoch);\nm1 = fit(UnfoldModel,[Any=>(f1,times)],evts,data_epoch);\n\nm1|> DisplayAs.withcontext(:is_pluto=>true) # hide","category":"page"},{"location":"HowTo/lmm_pvalues/#Likelihood-ratio","page":"P-values for mixedModels","title":"Likelihood ratio","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"uf_lrt = likelihoodratiotest(data_epoch, m0, m1)\nuf_lrt[1]","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"As you can see, we have some likelihood ratio outcomes, exciting!","category":"page"},{"location":"HowTo/lmm_pvalues/#Extract-p-values","page":"P-values for mixedModels","title":"Extract p-values","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"pvalues(uf_lrt)","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"We have extracted the p-values and now need to make them usable.     The solution can be found in the documentation under ?pvalues.","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"pvals_lrt = vcat(pvalues(uf_lrt)...)\nnchan = 1\nntime = length(times)\nreshape(pvals_lrt, ntime, nchan)' # note the last transpose via ' !","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"Perfecto, these are the LRT p-values of a model condA vs. condA+condB with same random effect structure.","category":"page"},{"location":"HowTo/lmm_pvalues/#Walds-T-Test","page":"P-values for mixedModels","title":"Walds T-Test","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"This method is easier to calculate but has limitations in accuracy and scope. It may also be less accurate due to the liberal estimation of degrees of freedom. Testing is limited in this case, as random effects cannot be tested and only single predictors can be used, which may not be appropriate for spline effects. It is important to note that this discussion is beyond the scope of this LMM package.","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"res = coeftable(m1)\n# only fixed effects: what is not in a ranef group is a fixef.\nres = res[isnothing.(res.group), :]\n# calculate t-value\nres[:, :tvalue] = res.estimate ./ res.stderror","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"We obtained Walds t, but how to translate them to a p-value?","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"Determining the necessary degrees of freedom for the t-distribution is a complex issue with much debate surrounding it. One approach is to use the number of subjects as an upper bound for the p-value (your df will be between n_subject and sumn_trials).","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"df = length(unique(evts.subject))","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"Plug it into the t-distribution.","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"using Distributions\nres.pvalue = pdf.(TDist(df),res.tvalue)","category":"page"},{"location":"HowTo/lmm_pvalues/#Comparison-of-methods","page":"P-values for mixedModels","title":"Comparison of methods","text":"","category":"section"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"Cool! Let's compare both methods of p-value calculation!","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"df = DataFrame(:walds => res[res.coefname.==\"B: b_tiny\", :pvalue], :lrt => pvals_lrt)\nf = Figure()\n\nscatter(f[1,1],times,res[res.coefname .== \"B: b_tiny\",:estimate],axis=(;xlabel=\"time\",title=\"coef: B:b_tiny\"))\nscatter(f[1,2],df.walds,df.lrt,axis=(;title=\"walds-t pvalue\",ylabel=\"LRT pvalue\"))\nscatter(f[2,1],times,df.walds,axis=(;title=\"walds-t pvalue\",xlabel=\"time\"))\nscatter(f[2,2],times,df.lrt,axis=(;title=\"lrt pvalue\",xlabel=\"time\"))\n\nf","category":"page"},{"location":"HowTo/lmm_pvalues/","page":"P-values for mixedModels","title":"P-values for mixedModels","text":"Look pretty similar! Note that the Walds-T is typically too liberal (LRT also, but to a lesser exted). Best is to use the forthcoming MixedModelsPermutations.jl or go the route via R and use KenwardRoger (data not yet published)","category":"page"},{"location":"HowTo/custom_solvers/#custom_solvers","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers","text":"","category":"section"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"A solver takes an Unfold-specified DesignMatrix and the data, and typically solves the equation system y = Xb (in the case of Linear Models). There are many different ways how one can approach this problem, depending if the matrix is sparse, if it is 2D or 3D, if one wants to use GPU etc.","category":"page"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"Most implemented solvers ultimately make use of solver_main for their main loop. See the reference tutorial for more information if that is interesting to you.","category":"page"},{"location":"HowTo/custom_solvers/#Setup-some-data","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Setup some data","text":"","category":"section"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"using Unfold\nusing UnfoldMakie, CairoMakie\nusing UnfoldSim\ndat, evts = UnfoldSim.predef_eeg(; noiselevel = 10, return_epoched = true)\n\nf = @formula 0 ~ 1 + condition + continuous\ndesignDict = Dict(Any => (f, range(0, 1, length = size(dat, 1))))","category":"page"},{"location":"HowTo/custom_solvers/#GPU-Solvers","page":"Alternative Solvers (Robust, GPU, B2B)","title":"GPU Solvers","text":"","category":"section"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"GPU solvers can significantly speed up your model fitting, with observed improvements of up to a factor of 30-100!","category":"page"},{"location":"HowTo/custom_solvers/#fastest-GPU-solver","page":"Alternative Solvers (Robust, GPU, B2B)","title":"fastest GPU solver","text":"","category":"section"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"Empirically we found that solving X'Xb = X'y is the fastest way to solve for b. To achieve this, you can run:","category":"page"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"using CUDA\ngpu_solver =(x, y) -> Unfold.solver_predefined(x, y; solver=:qr)\nm = Unfold.fit(UnfoldModel, designDict, evts, cu(dat), solver = gpu_solver)","category":"page"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"Where the cu is the magic that moves the data to the GPU. Internatlly, the solver function will move the matrix as well and pre-calculate some matrices (especially X'X, X' and allocate X'y).","category":"page"},{"location":"HowTo/custom_solvers/#lsmr-GPU-solver","page":"Alternative Solvers (Robust, GPU, B2B)","title":"lsmr GPU solver","text":"","category":"section"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"the Krylov.lsmr implementation directly solves y = Xb, but allows for running on the GPU.","category":"page"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"using Krylov, CUDA # necessary to load the right package extension\ngpu_solver =(x, y) -> Unfold.solver_krylov(x, y; GPU = true)\nm = Unfold.fit(UnfoldModel, designDict, evts, dat, solver = gpu_solver)","category":"page"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"To test it, you will need to run it yourself as we cannot run it on the docs. If you require a different graphicscard vendor than NVIDA/CUDA, please create an issue. Currently, we are unable to test it due to lack of hardware.","category":"page"},{"location":"HowTo/custom_solvers/#Robust-Solvers","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Robust Solvers","text":"","category":"section"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"Robust solvers automatically adjust for outlier trials, but they come at a significant computational cost.","category":"page"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"using RobustModels # necessary to load the Unfold package extension\nse_solver = (x, y) -> Unfold.solver_robust(x, y)\nm = Unfold.fit(UnfoldModel, designDict, evts, dat, solver = se_solver)\nresults = coeftable(m)\nplot_erp(results; stderror = true)","category":"page"},{"location":"HowTo/custom_solvers/#Back2Back-regression","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Back2Back regression","text":"","category":"section"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"b2b_solver = (x, y) -> Unfold.solver_b2b(x, y; ross_val_reps = 5)\ndat_3d = permutedims(repeat(dat, 1, 1, 20), [3 1 2])\nm = Unfold.fit(UnfoldModel, designDict, evts, dat_3d; solver = b2b_solver)\nresults = coeftable(m)\n\nplot_erp(results)","category":"page"},{"location":"HowTo/custom_solvers/","page":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers (Robust, GPU, B2B)","text":"These are the decoding results for conditionA while considering conditionB, and vice versa.","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"EditURL = \"../../../literate/explanations/predict.jl\"","category":"page"},{"location":"generated/explanations/predict/#The-predict-family","page":"Predictions","title":"The predict-family","text":"","category":"section"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"# Setup\nusing Unfold\nusing UnfoldSim\nusing CairoMakie\n\ndat, evts = UnfoldSim.predef_eeg(noiselevel = 5)\ndesign = [\n    \"car\" => (@formula(0 ~ 1 + continuous), firbasis(τ = (-0.5, 1), sfreq = 100)),\n    \"face\" => (@formula(0 ~ 1 + continuous), firbasis(τ = (-0.3, 0.5), sfreq = 100)),\n]\n\nm = fit(UnfoldModel, design, evts, dat; eventcolumn = :condition);\nnothing #hide","category":"page"},{"location":"generated/explanations/predict/#Overview","page":"Predictions","title":"Overview","text":"","category":"section"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"In a linear model EEG = Xβ + e, predictions boil down to finding hatEEG = Xβ, thus EEG data without any error term. Different types of predictions can be generated by modifying the X accordingly.","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"note: Note\nWe simulated only a single channel, all results generalize to the multi channel case","category":"page"},{"location":"generated/explanations/predict/#Different-types-of-predictions","page":"Predictions","title":"Different types of predictions","text":"","category":"section"},{"location":"generated/explanations/predict/#Time-Continuous-case","page":"Predictions","title":"Time-Continuous case","text":"","category":"section"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"Let's start with the cases, where the EEG was not epoched before using Unfold, i.e. the EEG was analysed with e.g. FIR-deconvolution","category":"page"},{"location":"generated/explanations/predict/#Continuous-EEG","page":"Predictions","title":"Continuous EEG","text":"","category":"section"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"In the most simple case, we can predict the continuously modelled EEG - This returns EEG = Xβ","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"p = predict(m) # same as predict(m, overlap = true)\nlines(p[1, 1:1000])","category":"page"},{"location":"generated/explanations/predict/#No-overlap","page":"Predictions","title":"No-overlap","text":"","category":"section"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"We can also predict each epoch without any overlap - This results in one prediction Array per event (in our case we have two events \"car\" and \"face\", thus size(p[1]) = 2","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"p = predict(m, overlap = false)\nsize(p)","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"Each Array has the size (1, samples, epochs):","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"size(p[1])","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"Visualizing the 1000 events","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"series(range(-0.5, 1, step = 1 / 100), p[1][1, :, :]', solid_color = :orange)\nseries!(range(-0.3, 0.5, step = 1 / 100), p[2][1, :, :]', solid_color = :teal)\ncurrent_figure()","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"note: Note\nAt ~0.3s we can see a split between the predicted EEG single trials into 10 \"strands\" - this is the granularity of our continuous predictor. You could use effects to improve upon this granularity / customize it.","category":"page"},{"location":"generated/explanations/predict/#With-overlap,-epoched","page":"Predictions","title":"With-overlap, epoched","text":"","category":"section"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"Sometimes helpful is to add in the overlap we removed via the deconvolution.","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"p = predict(m, epoch_to = [\"car\"], eventcolumn = :condition)\nseries(range(-0.5, 1, step = 1 / 100), p[1, :, 1:3]', solid_color = :orange)","category":"page"},{"location":"generated/explanations/predict/#Partial-overlap","page":"Predictions","title":"Partial-overlap","text":"","category":"section"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"We can also include/exclude certain events with \"partial-overlap\", i.e. only overlap with kept events.","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"p_car = predict(m, keep_basis = [\"car\"], eventcolumn = :condition)\np_face = predict(m, exclude_basis = [\"car\"], eventcolumn = :condition) # same as keep_basis=[\"face\"]\nf = lines(p_car[1, 1:1000])\nlines!(p_face[1, 1:1000])\nf","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"In the plot, we see the two partial predictions for car and face. They are respectively \"0\" outside the basisfunction windows","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"note: Note\nThe above options can be combined as well, e.g. to get an epoch_to, exclude_basis version. epoch_timewindow can be specified as well.","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"","category":"page"},{"location":"generated/explanations/predict/","page":"Predictions","title":"Predictions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"EditURL = \"../../../literate/references/solver.jl\"","category":"page"},{"location":"generated/references/solver/#Solver-implementation","page":"Solver/optimizer implementations","title":"Solver implementation","text":"","category":"section"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"This document describes how the solver_main is implemented and how to add custom solvers.","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"some setup","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"using Unfold, UnfoldSim, CairoMakie\nusing LinearAlgebra: cholesky","category":"page"},{"location":"generated/references/solver/#Solver-main","page":"Solver/optimizer implementations","title":"Solver main","text":"","category":"section"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"This function gis a eneral purpose solver-wrapper function. It calls  prepare_fun and iterates over the first dimension of data, repeatedly calling the solver_fun.","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"Without any bells and whistles (progress, history etc.) the function roughly looks like this:","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"function _solver_min(X, data; prepare_fun, solver_fun!, stderror = false)\n    Ĥ, dataP, prepared = prepare_fun(X, data)\n    for ch = 1:size(dataP, 2)\n        for t = 1:size(dataP, 3)\n            ch == 1 || copyto!(view(Ĥ, ch, :, t), view(Ĥ, ch - 1, :, t))\n            solver_fun!(view(Ĥ, ch, :, t), view(dataP, :, ch, t), prepared...)\n        end\n    end\n    modelfit = stderror ? calculate_stderror(X, data, Ĥ) : nothing\n\n    return modelfit\n\nend","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"Before diving into the prepare_fun and solver_fun! functions, let's discuss first the inner loop t=1:size(dataP,3). This loop really only comes alife (that is size(dataP,3)!=1) if a mass-univariate model is fitted, that is, when ndims(data)==3`. We still have it around for 2D, un-epoched data, to have exactly the same code in both cases.","category":"page"},{"location":"generated/references/solver/#prepare_fun","page":"Solver/optimizer implementations","title":"prepare_fun`","text":"","category":"section"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"This function is the setup / prepare function. It is typically a chain of functions with similar input / output characteristica. The first fuction of the chain/pipeline should be a function taking (X,data)and returning (Ĥ::AbstractArray, dataP::AbstractArray, prepared::Tuple).","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"Ĥ is used to save the beta/parameters inplace\ndataP is the data in format ch x repeat x time (with size(time) = 1 if data initially was a Matrix/2D-array)\nprepared is a tuple of all the other variables needed in the solver-step, e.g. the pinv(X) or X'X or simply X","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"The prepare function which is typiclly the first, just permutes the data & converts everything to GPU in case data::CuArray.","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"The next function in a pipeline then would take this (Ĥ::AbstractArray, dataP::AbstractArray, prepared::Tuple) inputs and process it further.`","category":"page"},{"location":"generated/references/solver/#solver_fun!","page":"Solver/optimizer implementations","title":"solver_fun!","text":"","category":"section"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"This function actually performs the fitting. It takes the inputs (Ĥ::view(Matrix),data::view(Array),prepared::Tuple)","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"Ĥ is the current beta/parameters view, a vector/slice for one channel and one timepoint\ndata is similarly the current data view, a vector/slice for one channel and one timepoint\nprepared is the tuple-output of the prepare function.","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"The solver_fun! can output some history of the solver, e.g. a log for iterative solvers.","category":"page"},{"location":"generated/references/solver/#Example-(simple)","page":"Solver/optimizer implementations","title":"Example (simple)","text":"","category":"section"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"let's setup our own solver:","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"_my_solver!(Ĥ, data, X) = Ĥ .= Matrix(X) \\ data","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"let's simulate some data and see this in action","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"data, evts = UnfoldSim.predef_eeg()\nm = fit(\n    UnfoldModel,\n    @formula(0 ~ 1 + condition),\n    evts,\n    data,\n    firbasis((-0.1, 0.5), 100);\n    solver = (x, y) ->\n        Unfold.solver_main(x, y; solver_fun! = _my_solver!, show_time = true),\n)","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"Remember from this table the time for one solve (~700ms on my test-computer) this is the time per channel.","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"series(coef(m))","category":"page"},{"location":"generated/references/solver/#Cholesky-Example","page":"Solver/optimizer implementations","title":"Cholesky Example","text":"","category":"section"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"note: Note\nthe following function is already implemented in Unfold.jl as well. See ?Unfold.solver_predefined","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"Given that the prepare function returns all necessary ingredients, this is a bit simple. So let's make it more complex","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"for nicety, we need some unpacking wrappers","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"_prepare_cholesky(all::Tuple) = _prepare_cholesky(all...)\n_prepare_cholesky(Ĥ, data, all::Tuple) = _prepare_cholesky(Ĥ, data, all...)","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"this function effectively only pre-calculates the cholesky decomposition","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"_prepare_cholesky(Ĥ, data, Xt, R_xx, R_xy) = (Ĥ, data, (Xt, cholesky(R_xx), R_xy))","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"now we have everything to put together our solver-pipeline","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"_my_prepare =\n    (x, y) -> Unfold.prepare(collect(x), y) |> Unfold.prepare_XTX |> _prepare_cholesky","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"let's test (note we have to reshape the data)","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"@time _my_prepare(modelmatrix(m), reshape(data, 1, :))","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"finally, we need a solver this is how we solve the single-channel equation","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"function _my_cholesky!(beta, data, Xt, XtX_cholesky, R_xy)\n    @time Unfold.calc_Rxy!(R_xy, Xt, data)\n    @time beta .= XtX_cholesky \\ R_xy\nend\n\nm = fit(\n    UnfoldModel,\n    @formula(0 ~ 1 + condition),\n    evts,\n    data,\n    firbasis((-0.1, 0.5), 100);\n    solver = (x, y) -> Unfold.solver_main(\n        x,\n        y;\n        prepare_fun = _my_prepare,\n        solver_fun! = _my_cholesky!,\n        show_time = true,\n    ),\n)","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"This (on my test-computer) took only 97ms per channel, so it is ~7x faster per channel.","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"series(coef(m))","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"","category":"page"},{"location":"generated/references/solver/","page":"Solver/optimizer implementations","title":"Solver/optimizer implementations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"HowTo/standarderrors/#standard_errors","page":"Standard errors","title":"Standard Errors","text":"","category":"section"},{"location":"HowTo/standarderrors/#Setup-some-data","page":"Standard errors","title":"Setup some data","text":"","category":"section"},{"location":"HowTo/standarderrors/","page":"Standard errors","title":"Standard errors","text":"using Unfold\nusing UnfoldMakie, CairoMakie\nusing UnfoldSim\ndat, evts = UnfoldSim.predef_eeg(; noiselevel = 10, return_epoched = true)\n\nf = @formula 0 ~ 1 + condition + continuous\ndesignDict = Dict(Any => (f, range(0, 1, length = size(dat, 1))))","category":"page"},{"location":"HowTo/standarderrors/","page":"Standard errors","title":"Standard errors","text":"It is possible to specify a solver that calculates the standard errors of the estimates for a single subject as it possible for custom solvers.","category":"page"},{"location":"HowTo/standarderrors/","page":"Standard errors","title":"Standard errors","text":"se_solver = (x, y) -> Unfold.solver_default(x, y, stderror = true)\nm = Unfold.fit(UnfoldModel, designDict, evts, dat, solver = se_solver)\nresults = coeftable(m)\nplot_erp(results; stderror = true)","category":"page"},{"location":"HowTo/standarderrors/","page":"Standard errors","title":"Standard errors","text":"warning: Warning\nIn case of overlap-correction: Use single-subject standard errors on your own risk. EEG data is autocorrelated, which means that standard errors are typically too small.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"EditURL = \"../../../literate/HowTo/effects.jl\"","category":"page"},{"location":"generated/HowTo/effects/#effects","page":"Marginal effects (must read re: splines)","title":"Marginal effects","text":"","category":"section"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"Marginal effect plots are useful for understanding model fits.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"If you are an EEG researcher, you can think of the coefficients as the 'difference waves' and the (marginal) effects as the 'modelled ERP evaluated at a certain predictor value combination'. In some way, we are fitting a model with coefficients, receiving intercepts and slopes, and then try to recover the 'classical' ERPs in their \"data-domain\", typically with some effect adjustment, overlap removal, or similar.","category":"page"},{"location":"generated/HowTo/effects/#Setup-things","page":"Marginal effects (must read re: splines)","title":"Setup things","text":"","category":"section"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"Setup some packages","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"using Unfold\nusing DataFrames\nusing Random\nusing CSV\nusing UnfoldMakie\nusing UnfoldSim\nusing UnfoldMakie\nusing DisplayAs # hide","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"Generate data and fit a model with a 2-level categorical predictor and a continuous predictor without interaction.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"data, evts = UnfoldSim.predef_eeg(; noiselevel = 8)\n\nbasisfunction = firbasis(τ = (-0.1, 0.5), sfreq = 100; interpolate = false)\n\nf = @formula 0 ~ 1 + condition + continuous # 1\n\nm = fit(UnfoldModel, [Any => (f, basisfunction)], evts, data, eventcolumn = \"type\")\nm |> DisplayAs.withcontext(:is_pluto => true) # hide","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"Plot the results","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"plot_erp(coeftable(m))","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"The coefficients are represented by three lines on a figure:","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"the intercept showing the reference category for a typical p1/n1/p3 ERP components;\nthe slope of continuous variables with 1µV range;\nthe effect of categorical variabe with 3µV range.","category":"page"},{"location":"generated/HowTo/effects/#Effects-function","page":"Marginal effects (must read re: splines)","title":"Effects function","text":"","category":"section"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"In order to better understand the actual predicted ERP curves, often researchers had to do manual contrasts. Remember that a linear model is y = X * b, which allows (after b was estimated) to input a so-called contrast vector for X. You might know this in the form of [1, 0, -1, 1] or similar form. However, for larger models, this method can be prone to errors.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"The effects function is a convenient way to specify contrast vectors by providing the actual levels of the experimental design. It can be used to calculate all possible combinations of multiple variables.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"If a predictor-variable is not specified here, the function will automatically set it to its typical value. This value is usually the mean, but for categorical variables, it could be something else. The R package emmeans has a lot of discussion on this topic.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"eff = effects(Dict(:condition => [\"car\", \"face\"]), m)\nplot_erp(eff; mapping = (; color = :condition,))","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"We can also generate continuous predictions:","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"eff = effects(Dict(:continuous => -5:0.5:5), m)\nplot_erp(\n    eff;\n    mapping = (; color = :continuous, group = :continuous => nonnumeric),\n    categorical_color = false,\n    categorical_group = false,\n)","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"Or we can split our marginal effects by condition and calculate all combinations \"automagically\".","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"eff = effects(Dict(:condition => [\"car\", \"face\"], :continuous => -5:2:5), m)\nplot_erp(eff; mapping = (; color = :condition, col = :continuous))","category":"page"},{"location":"generated/HowTo/effects/#What-is-typical-anyway?","page":"Marginal effects (must read re: splines)","title":"What is typical anyway?","text":"","category":"section"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"The effects function includes an argument called typical, which specifies the function applied to the marginalized covariates/factors. The default value is mean, which is usually sufficient for analysis.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"However, for skewed distributions, it may be more appropriate to use the mode, while for outliers, the median or winsor mean may be more appropriate.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"To illustrate, we will use the maximum function on the continuous predictor.","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"eff_max = effects(Dict(:condition => [\"car\", \"face\"]), m; typical = maximum)\neff_max.typical .= :maximum\neff = effects(Dict(:condition => [\"car\", \"face\"]), m)\neff.typical .= :mean # mean is the default\n\nplot_erp(vcat(eff, eff_max); mapping = (; color = :condition, col = :typical))","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"","category":"page"},{"location":"generated/HowTo/effects/","page":"Marginal effects (must read re: splines)","title":"Marginal effects (must read re: splines)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"90-contributing/#contributing","page":"Contributing guidelines","title":"Contributing guidelines","text":"","category":"section"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"First of all, thanks for the interest!","category":"page"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"We welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc.","category":"page"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"Be polite and respectful, and follow the code of conduct.","category":"page"},{"location":"90-contributing/#Bug-reports-and-discussions","page":"Contributing guidelines","title":"Bug reports and discussions","text":"","category":"section"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you think you found a bug, feel free to open an issue. Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please.","category":"page"},{"location":"90-contributing/#Working-on-an-issue","page":"Contributing guidelines","title":"Working on an issue","text":"","category":"section"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below). Otherwise, say what your proposed solution is and wait for a discussion around it.","category":"page"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"tip: Tip\nFeel free to ping us after a few days if there are no responses.","category":"page"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If your solution involves code (or something that requires running the package locally), check the developer documentation. Otherwise, you can use the GitHub interface directly to create your pull request.","category":"page"},{"location":"tutorials/lmm_overlap/#lmm_overlap","page":"lmmERP (overlap correction)","title":"Overlap Correction with Linear Mixed Models","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"\nusing Unfold\nusing UnfoldSim\n\nusing CategoricalArrays\nusing MixedModels\nusing UnfoldMakie, CairoMakie\nusing DataFrames\n\nnothing;#hide","category":"page"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"This notebook is similar to the Linear Model with Overlap Correction tutorial, but fits mixed models with overlap correction","category":"page"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"warning: Warning\nLimitation: This functionality is not ready for general use. There are still a lot of things to find out and tinker with. Don't use this if you haven't looked under the hood of the toolbox! Be aware of crashes / timeouts for non-trivial problems","category":"page"},{"location":"tutorials/lmm_overlap/#Get-some-data","page":"lmmERP (overlap correction)","title":"Get some data","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"dat, evts = UnfoldSim.predef_2x2(; signalsize=20, n_items=16, n_subjects=16)\n\n# We also need to fix the latencies, they are now relative to 1:size(data, 1), but we want a continuous long EEG.\nsubj_idx = [parse(Int, split(string(s), 'S')[2]) for s in evts.subject]\nevts.latency .+= size(dat, 1) .* (subj_idx .- 1)\n\ndat = dat[:] # we need all data concatenated over subjects\nevts.subject  = categorical(Array(evts.subject))\nnothing #hide","category":"page"},{"location":"tutorials/lmm_overlap/#Linear-**Mixed**-Model-Continuous-Time","page":"lmmERP (overlap correction)","title":"Linear Mixed Model Continuous Time","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"Again we have 4 steps:","category":"page"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"Specify a temporal basisfunction\nSpecify a formula\nFit a linear model for each channel (one model for all timepoints!)\nVisualize the results.","category":"page"},{"location":"tutorials/lmm_overlap/#1.-Specify-a-temporal-basisfunction","page":"lmmERP (overlap correction)","title":"1. Specify a temporal basisfunction","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"By default, we would want to use a FIR basis function. See Basis Functions for more details.","category":"page"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"basisfunction = firbasis(τ=(-0.4, .8), sfreq=20, name=\"stimulus\")\nnothing #hide","category":"page"},{"location":"tutorials/lmm_overlap/#2.-Specify-the-formula","page":"lmmERP (overlap correction)","title":"2. Specify the formula","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"Define the formula and specify a random effect.","category":"page"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"note: Note\nWe use zerocorr to prevent the model from computing all correlations between all timepoints and factors.","category":"page"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"f  = @formula 0 ~ 1 + A  *B + zerocorr(1 + A*B|subject);","category":"page"},{"location":"tutorials/lmm_overlap/#3.-Fit-the-model","page":"lmmERP (overlap correction)","title":"3. Fit the model","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"bfDict = Dict(Any=>(f, basisfunction))\n# Skipping this tutorial for now due to a significant error.\nm = fit(UnfoldModel, bfDict, evts, dat)\n\nresults = coeftable(m)\nfirst(results, 6)","category":"page"},{"location":"tutorials/lmm_overlap/#4.-Visualize-results","page":"lmmERP (overlap correction)","title":"4. Visualize results","text":"","category":"section"},{"location":"tutorials/lmm_overlap/","page":"lmmERP (overlap correction)","title":"lmmERP (overlap correction)","text":"plot_erp(results; mapping=(; col = :group))","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"EditURL = \"../../../literate/HowTo/unfold_io.jl\"","category":"page"},{"location":"generated/HowTo/unfold_io/#unfold_io","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"","category":"section"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"Unfold.jl allows storing Unfold models in a memory-efficient way using (compressed) .jld2 files.","category":"page"},{"location":"generated/HowTo/unfold_io/#Simulate-EEG-data-and-fit-an-Unfold-model","page":"Save and load Unfold models","title":"Simulate EEG data and fit an Unfold model","text":"","category":"section"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/HowTo/unfold_io/#Simulate-some-example-data-using-UnfoldSim.jl","page":"Save and load Unfold models","title":"Simulate some example data using UnfoldSim.jl","text":"","category":"section"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"using UnfoldSim\ndata, events = UnfoldSim.predef_eeg(; n_repeats = 10)\nfirst(events, 5)","category":"page"},{"location":"generated/HowTo/unfold_io/#Fit-an-Unfold-model","page":"Save and load Unfold models","title":"Fit an Unfold model","text":"","category":"section"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"using Unfold\nbasisfunction = firbasis(τ = (-0.5, 1.0), sfreq = 100, name = \"stimulus\")\nf = @formula 0 ~ 1 + condition + continuous\nbfDict = Dict(Any => (f, basisfunction))\nm = fit(UnfoldModel, bfDict, events, data);\nnothing #hide","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"</details >","category":"page"},{"location":"generated/HowTo/unfold_io/#Save-and-load-the-fitted-Unfold-model","page":"Save and load Unfold models","title":"Save and load the fitted Unfold model","text":"","category":"section"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"The following code saves the model in a compressed .jld2 file. The default option of the save function is compress=false. For memory efficiency the designmatrix is set to missing. If needed, it can be reconstructed when loading the model.","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"save_path = mktempdir(; cleanup = false) # create a temporary directory for the example\nsave(joinpath(save_path, \"m_compressed.jld2\"), m; compress = true);\nnothing #hide","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"The load function allows to retrieve the model again. By default, the designmatrix is reconstructed. If it is not needed set generate_Xs=false` which improves time-efficiency.","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"m_loaded = load(joinpath(save_path, \"m_compressed.jld2\"), UnfoldModel, generate_Xs = true);\nnothing #hide","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"","category":"page"},{"location":"generated/HowTo/unfold_io/","page":"Save and load Unfold models","title":"Save and load Unfold models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"explanations/basisfunctions/#Basis-Functions","page":"Basisfunctions","title":"Basis Functions","text":"","category":"section"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"using CairoMakie","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"This document will give you an explanation of basis functions. We start with basis functions for fMRI because they are very popular.","category":"page"},{"location":"explanations/basisfunctions/#HRF-/-BOLD","page":"Basisfunctions","title":"HRF / BOLD","text":"","category":"section"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"We want to define a basis function. There are currently only few basisfunctions implemented in Unfold.jl, but your imagination knows no borders!","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"We first have a look at the BOLD-HRF basisfunction aka Blood Oxygenation Level Dependent Hemodynamic Response Function:","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"using Unfold, DSP\n\nTR = 1.5 # the sampling rate\nbold = hrfbasis(TR) # using default SPM parameters\neventonset = 1.3\nbold_kernel = e -> Unfold.kernel(bold, e)\nlines(bold_kernel(eventonset)[:,1]) # returns a matrix, thus [:, 1]","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"This is the shape that is assumed to reflect the activity for an event. Generally, we would like to know how much to scale this response shape per condition, e.g. in condA we might scale it by 0.7, in condB by 1.2.","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"But let's start at the beginning and first simulate an fMRI signal. Then you will also appreciate why we need to deconvolve it later.","category":"page"},{"location":"explanations/basisfunctions/#Convolving-a-response-shape-to-get-a-\"recorded\"-fMRI-signal","page":"Basisfunctions","title":"Convolving a response shape to get a \"recorded\" fMRI signal","text":"","category":"section"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"We start by convolving this HRF function with an impulse vector at event onsets.","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"y = zeros(100) # signal length = 100\ny[[10, 30, 45]] .= 0.7 # 3 events at given for condition A\ny[[37]] .= 1.2 # 1 events at given for condition B\n\ny_conv = conv(y, bold_kernel(0)) # convolve!\nlines(y_conv[:,1])","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"Next, we would add some noise:","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"using Random\ny_conv += randn(size(y_conv))\nlines(y_conv[:,1])","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"🎉 - we did it, we simulated fMRI data.","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"Now you can see that the conditions overlap in time. To get back to the original amplitude values, we need to specify a basis function and use Unfold to deconvolve the signals.","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"note: Note\nEvents can fall between TR (the sampling rate). Some packages subsample the time signal, but in Unfold we can call the bold.kernel function directly at a given event time, which allows us to use non-TR multiples.","category":"page"},{"location":"explanations/basisfunctions/#FIR-Basis-Function","page":"Basisfunctions","title":"FIR Basis Function","text":"","category":"section"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"Okay, let's have a look at a different basis function: The FIR basisfunction. FIR stands for Finite-Impulse-Response and is a term taken from the filtering literature.","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"using Unfold #hide\n\nbasisfunction = firbasis(τ=(-0.4,.8), sfreq=50, name=\"myFIRbasis\")\nfir_kernel = e -> Unfold.kernel(basisfunction, e)\nm = fir_kernel(0)\nf = Figure()\nf[1,1] = Axis(f)\nfor col = 1:size(m, 2)\n    lines!(m[:,col])\nend\ncurrent_figure()","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"The first thing to notice is that it is not a single basisfunction, but a set of basisfunctions. So every condition is explained by several basis functions!","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"To make it clear better show it in 2D:","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"fir_kernel(0)[1:10,1:10]","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"(all . are 0's)","category":"page"},{"location":"explanations/basisfunctions/","page":"Basisfunctions","title":"Basisfunctions","text":"The FIR basis set consists of multiple basis functions. That is, each event is now time-expanded to multiple predictors, each with a certain time delay to the event onset. This allows us to model any linear overlap shape, and doesn't force us to make assumptions about the convolution kernel, as we had to do in the BOLD case.","category":"page"},{"location":"explanations/development/#Install-a-dev-version-of-Unfold","page":"-","title":"Install a dev-version of Unfold","text":"","category":"section"},{"location":"explanations/development/","page":"-","title":"-","text":"In order to see and change the tutorials, you have to install a local dev-version of Unfold via:","category":"page"},{"location":"explanations/development/","page":"-","title":"-","text":"]dev --local Unfold","category":"page"},{"location":"explanations/development/","page":"-","title":"-","text":"This clones the git#main into ./dev/Unfold","category":"page"},{"location":"explanations/development/#Instantiating-the-documentation-environment","page":"-","title":"Instantiating the documentation environment","text":"","category":"section"},{"location":"explanations/development/","page":"-","title":"-","text":"To generate documentation, we recommend to install LiveServer.jl - then you can do:","category":"page"},{"location":"explanations/development/","page":"-","title":"-","text":"using LiveServer\nservedocs(skip_dirs=joinpath(\"docs\",\"src\",\"generated\"),literate_dir=joinpath(\"docs\",\"literate\"))","category":"page"},{"location":"explanations/development/","page":"-","title":"-","text":"If you prefer a one-off:","category":"page"},{"location":"explanations/development/","page":"-","title":"-","text":"activate the  ./docs folder (be sure to ]instantiate the first time!)\nrun include(\"docs/make.jl\")","category":"page"},{"location":"references/types/","page":"API: Types","title":"API: Types","text":"Modules = [Unfold]\nOrder   = [:type]","category":"page"},{"location":"references/types/#Unfold.AbstractModelFit","page":"API: Types","title":"Unfold.AbstractModelFit","text":"Abstract Type to report modelresults\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.BasisFunction","page":"API: Types","title":"Unfold.BasisFunction","text":"See FIRBasis for an examples\n\na BasisFunction should implement:\n\nkernel() # kernel(b::BasisFunction,sample) => returns the designmatrix for that event\nheight() # number of samples in continuous time, NaN if not defined\nwidth()  # number of coefficient columns (e.g. HRF 1 to 3, FIR=height(),except if interpolate=true )\ncolnames() # unique names of expanded columns\ntimes() # vector of times along expanded columns, length = height()\nname() # name of basisfunction\ncollabel() [default \"colname_basis\"] # name for coeftable\nshift_onset() [default 0]\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.DesignMatrixLinearModel","page":"API: Types","title":"Unfold.DesignMatrixLinearModel","text":"DesignMatrix\n\nType that keeps an Array of  formulas, designmatrices modelmatrix (Array or Array of Arrays in case of MixedModel) and events-dataframe\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.FIRBasis","page":"API: Types","title":"Unfold.FIRBasis","text":"Defines a FIRBasisfunction which can be called for each event, defining the time-expanded basis kernel\n\nmutable struct FIRBasis <: Unfold.BasisFunction\n\ntimes: vector of times along rows of kernel-output (in seconds)\nname: name of the event, should be the actual eventName in eventcolumn of the dataframes later\nshift_onset: by how many samples do we need to shift the event onsets? This number is determined by how many 'negative' timepoints the basisfunction defines\ninterpolate: should we linearly interpolate events not on full samples?\nscale_duration: should we scale kernel to the duration? If yes, with which method\n\n(tipp: most users would you want to call firbasis, not generate it manually)\n\nExamples\n\njulia>  b = FIRBasis(range(0,1,length=10),\"basisA\",-1)\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.LinearModelFit","page":"API: Types","title":"Unfold.LinearModelFit","text":"Contains the results of linearmodels (continuous and not)\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.TimeExpandedTerm","page":"API: Types","title":"Unfold.TimeExpandedTerm","text":"Object with a term and an applicable BasisFunction and a eventfield that are later passed to the basisfunction.\n\nstruct TimeExpandedTerm{T<:StatsModels.AbstractTerm} <: StatsModels.AbstractTerm\n\nterm: Term that the basis function is applied to. This is regularly called in other functions to get e.g. term-coefnames and timeexpand those\nbasisfunction: Kernel that determines what should happen to the designmatrix of the term\neventfields: Which fields of the event-table should be passed to the basisfunction.Important: The first entry has to be the event-latency in samples!\n\nExamples\n\njulia>  b = TimeExpandedTerm(term,kernel,[:latencyTR,:durationTR])\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.UnfoldLinearModel","page":"API: Types","title":"Unfold.UnfoldLinearModel","text":"Concrete type to implement an Mass-Univariate LinearModel. .design contains the formula + times dict .designmatrix contains a DesignMatrix modelfit is a Any container for the model results\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.UnfoldLinearModelContinuousTime","page":"API: Types","title":"Unfold.UnfoldLinearModelContinuousTime","text":"Concrete type to implement an deconvolution LinearModel. .design contains the formula + times dict .designmatrix contains a DesignMatrix modelfit is a Any container for the model results\n\n\n\n\n\n","category":"type"},{"location":"references/types/#Unfold.UnfoldModel","page":"API: Types","title":"Unfold.UnfoldModel","text":"using Base: @deprecate_binding The main abstract model-type of the toolbox. E.g. UnfoldLinearModel is a concrete type of this\n\n\n\n\n\n","category":"type"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"EditURL = \"../../../literate/explanations/window_length.jl\"","category":"page"},{"location":"generated/explanations/window_length/#Window-length-effects","page":"Window Length Effect","title":"Window length effects","text":"","category":"section"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"using Unfold, UnfoldSim\nusing CairoMakie, AlgebraOfGraphics, MakieThemes\nusing Random\nusing DataFrames, DataFramesMeta\nusing ColorSchemes, Colors","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"important: Important\nFor analyzing real-world EEG data we recommend that researchers should — a priori — make an educated guess about the length of the underlying EEG activity and select this as their EW. This also suggests to use event windows with different sizes between events (as is possible with Unfold). Further, as can be seen below, when choosing longer time-windows the overfit is only of moderate size, thus we additionally recommend to generally err on the longer side, to not miss any important activity. \nFor a more in depth explanation on this, you can read our 2023 CCN paper: Skukies & Ehinger, 2023","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"set_theme!(theme_ggthemr(:fresh))","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"As opposed to classical averaged ERPs overlap corrected regression ERPs can be influenced by the chosen window length: Long estimation windows might capture all relevant event-related activity, but might introduce artifacts due to overfit, short estimation windows might not overfit, but also might not capture all (overlapping) activity, and thereby introduce bias.","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Thus a common question we get is, how to specify the length of the estimation windows.","category":"page"},{"location":"generated/explanations/window_length/#Init-functions","page":"Window Length Effect","title":"Init functions","text":"","category":"section"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"First we need a function that simulates some continous data; conviently we can use UnfoldSim for this","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"function gen_data(rng, noiselevel, sfreq)\n    noise = PinkNoise(; noiselevel = noiselevel)\n\n    dat, evts = UnfoldSim.predef_eeg(\n        rng;\n        sfreq = sfreq,\n        p1 = (p100(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5, 0], Dict()),\n        n1 = (n170(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5, 0], Dict()),\n        p3 = (p300(; sfreq = sfreq), @formula(0 ~ 1 + continuous), [5, 0], Dict()),\n        n_repeats = 20,\n        noise = noise,\n    )\n    return dat, evts\nend;\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Next a convience function to calculate the estimates","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"function calc_time_models(evts, dat, tWinList, sfreq)\n    mList = []\n    for twindow in tWinList\n        m = fit(\n            UnfoldModel,\n            [Any => (@formula(0 ~ 1), firbasis(twindow, sfreq))],\n            evts,\n            dat,\n        )\n        res = coeftable(m)\n        res.tWin .= string.(Ref(twindow[2]))\n        push!(mList, res)\n    end\n    return vcat(mList...)\nend;\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/#Init-variables","page":"Window Length Effect","title":"Init variables","text":"","category":"section"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"tWinList = [(-0.1, x) for x in [3, 2.5, 2, 1.5, 1, 0.5]]\nnoiselevel = 8.5\nsfreq = 250;\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/#Generate-data-and-calculate-estimates","page":"Window Length Effect","title":"Generate data and calculate estimates","text":"","category":"section"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"dat, evts = gen_data(MersenneTwister(2), noiselevel, sfreq);\n\nres = calc_time_models(evts, dat, tWinList, sfreq);\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"We also append some additional information to the results dataframe","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"For comparison lets also generate the ground truth of our data; this is a bit cumbersome and you don't have to care (too much) about it","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"dat_gt, evts_gt = UnfoldSim.predef_eeg(;\n    p1 = (p100(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()),\n    sfreq = sfreq,\n    n1 = (n170(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()),\n    p3 = (p300(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()),\n    n_repeats = 1,\n    noiselevel = 0,\n    return_epoched = true,\n);\ntime_gt = range(0, length = length(dat_gt[:, 1]), step = 1 / sfreq)\nunique_event = unique(res.tWin)\ndf_gt = DataFrame(\n    tWin = reduce(vcat, fill.(unique_event, length(dat_gt[:, 1]))),\n    eventname = Any,\n    channel = repeat([1], length(dat_gt[:, 1]) * length(unique_event)),\n    coefname = reduce(\n        vcat,\n        fill(\"GroundTruth\", length(dat_gt[:, 1]) * length(unique_event)),\n    ),\n    estimate = repeat(dat_gt[:, 1], length(unique_event)),\n    group = reduce(vcat, fill(nothing, length(dat_gt[:, 1]) * length(unique_event))),\n    stderror = reduce(vcat, fill(nothing, length(dat_gt[:, 1]) * length(unique_event))),\n    time = repeat(time_gt, length(unique_event)),\n);\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"And append ground truth to our results df","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"res_gt = vcat(res, df_gt);\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/#Plot-results","page":"Window Length Effect","title":"Plot results","text":"","category":"section"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Choose which data to plot","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"h_t =\n    AlgebraOfGraphics.data(res) * mapping(\n        :time,\n        :estimate,\n        color = :tWin,\n        group = (:tWin, :coefname) => (x, y) -> string(x[2]) * y,\n    );\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"We use the following to plot some length indicator lines","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"untWin = unique(res_gt.tWin)\nsegDF = DataFrame(\n    :x => hcat(repeat([-0.1], length(untWin)), parse.(Float64, untWin))[:],\n    :y => repeat(reverse(1:length(untWin)), outer = 2),\n)\nsegDF.tWin .= \"0.0\"\nsegDF.tWin .= segDF.x[reverse(segDF.y .+ 6)]\nsegDF.y = segDF.y .* 0.2 .+ 6;\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Layer for indicator lines","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"h_l =\n    AlgebraOfGraphics.data(@subset(segDF, :tWin .!= \"3.0\")) *\n    mapping(:x, :y, color = :tWin, group = :tWin => x -> string.(x));\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Ground truth Layer","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"h_gt =\n    AlgebraOfGraphics.data(df_gt) *\n    mapping(:time, :estimate, group = (:tWin, :coefname) => (x, y) -> string(x) * y) *\n    visual(Lines, linewidth = 5, color = Colors.Gray(0.6));\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Add all visuals together and draw","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"h1 =\n    h_gt + visual(Lines, colormap = get(ColorSchemes.Blues, 0.3:0.01:1.2)) * (h_l + h_t) |>\n    x -> draw(x, axis = (; xlabel = \"time [s]\", ylabel = \"estimate [a.u.]\"));\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Add zero grid lines","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"h1 = hlines!(current_axis(), [0], color = Colors.Gray(0.8));\nh2 = vlines!(current_axis(), [0], color = Colors.Gray(0.8));\ntranslate!(h1, 0, 0, -1);\ntranslate!(h2, 0, 0, -1);\nnothing #hide","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"Plot figure","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"current_figure()","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"","category":"page"},{"location":"generated/explanations/window_length/","page":"Window Length Effect","title":"Window Length Effect","text":"This page was generated using Literate.jl.","category":"page"},{"location":"references/benchmarks/#Benchmarks","page":"Solver benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"references/benchmarks/","page":"Solver benchmarks","title":"Solver benchmarks","text":"We ran benchmarks on 2024-11-07 as described in ./benchmark/cuda/solver_comparison.jl. Given that some were run on a GPU, we cannot run them on continuous-integration online.","category":"page"},{"location":"references/benchmarks/","page":"Solver benchmarks","title":"Solver benchmarks","text":"important: Important\nAllocations are only CPU allocations - GPU allocations were not counted.\nSolvers other than default_multi are currently NOT multi-threaded\nSolvers other than default_multi and krylov_gpu solve XXb = Xy instead of Xb=y directly. They are likely less accurate, but should be faster for multi-channel data, as we can precalulate cholesky, qr or similar & the to-be-inverted matrix is much smaller.","category":"page"},{"location":"references/benchmarks/#Small-Model","page":"Solver benchmarks","title":"Small Model","text":"","category":"section"},{"location":"references/benchmarks/","page":"Solver benchmarks","title":"Solver benchmarks","text":"n_channels = 1,\nsfreq = 10,\nn_splines = 4,\nn_repeats = 10;","category":"page"},{"location":"references/benchmarks/","page":"Solver benchmarks","title":"Solver benchmarks","text":"gpu method el_type time GB percent_X_filled sizeDesign n_channels overlap comment\ntrue cholesky Float64   0.068 (1190, 130) 1 (0.2, 0.2) PosDefException(-1)\nfalse cholesky Float64 0.00056 0.00069 0.068 (1190, 130) 1 (0.2, 0.2) \ntrue intern Float64 0.00088 0.00017 0.068 (1190, 130) 1 (0.2, 0.2) \nfalse intern Float64 0.0011 0.00069 0.068 (1190, 130) 1 (0.2, 0.2) \ntrue qr Float64 0.0013 0.00019 0.068 (1190, 130) 1 (0.2, 0.2) \nfalse cg Float64 0.0015 0.00057 0.068 (1190, 130) 1 (0.2, 0.2) \nfalse default_multi Float64 0.0017 0.00016 0.068 (1190, 130) 1 (0.2, 0.2) \nfalse qr Float64 0.002 0.00076 0.068 (1190, 130) 1 (0.2, 0.2) \ntrue cg Float64 0.0054 0.00056 0.068 (1190, 130) 1 (0.2, 0.2) \ntrue pinv Float64 0.0054 0.00032 0.068 (1190, 130) 1 (0.2, 0.2) \nfalse pinv Float64 0.016 0.0016 0.068 (1190, 130) 1 (0.2, 0.2) \ntrue krylov_gpu Float64 0.032 0.0013 0.068 (1190, 130) 1 (0.2, 0.2) ","category":"page"},{"location":"references/benchmarks/#small-to-midsize:-multi-channel","page":"Solver benchmarks","title":"small-to-midsize: multi-channel","text":"","category":"section"},{"location":"references/benchmarks/","page":"Solver benchmarks","title":"Solver benchmarks","text":"n_channels = 128,\nsfreq = 100,\nn_splines = 4,\nn_repeats = 200;","category":"page"},{"location":"references/benchmarks/#Float64","page":"Solver benchmarks","title":"Float64","text":"","category":"section"},{"location":"references/benchmarks/","page":"Solver benchmarks","title":"Solver benchmarks","text":"gpu method el_type time GB percent_X_filled sizeDesign n_channels overlap comment\ntrue cholesky Float64   0.0068 (239522, 1210) 128 (0.2, 0.2) PosDefException(-1)\ntrue qr Float64 0.38 0.25 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue pinv Float64 0.42 0.26 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue intern Float64 0.7 0.25 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue cg Float64 1.2 0.32 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse cholesky Float64 1.5 0.31 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse qr Float64 1.7 0.31 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse cg Float64 2.0 0.3 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse pinv Float64 2.1 0.38 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue krylov_gpu Float64 5.9 0.4 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse default_multi Float64 13.0 1.2 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse intern Float64 13.0 1.7 0.0068 (239522, 1210) 128 (0.2, 0.2) ","category":"page"},{"location":"references/benchmarks/#Float32","page":"Solver benchmarks","title":"Float32","text":"","category":"section"},{"location":"references/benchmarks/","page":"Solver benchmarks","title":"Solver benchmarks","text":"gpu method el_type time GB percent_X_filled sizeDesign n_channels overlap comment\ntrue cholesky Float32   0.0068 (239522, 1210) 128 (0.2, 0.2) PosDefException(-1)\ntrue krylov_gpu Float32   0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue pinv Float32 0.39 0.25 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue qr Float32 0.62 0.24 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue intern Float32 0.69 0.24 0.0068 (239522, 1210) 128 (0.2, 0.2) \ntrue cg Float32 1.2 0.31 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse cholesky Float32 1.2 0.17 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse cg Float32 1.3 0.16 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse qr Float32 1.4 0.17 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse pinv Float32 1.6 0.21 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse intern Float32 13.0 0.86 0.0068 (239522, 1210) 128 (0.2, 0.2) \nfalse default_multi Float32 13.0 0.97 0.0068 (239522, 1210) 128 (0.2, 0.2) ","category":"page"},{"location":"references/benchmarks/#large,-realistic-model","page":"Solver benchmarks","title":"large, realistic model","text":"","category":"section"},{"location":"references/benchmarks/","page":"Solver benchmarks","title":"Solver benchmarks","text":"    n_channels = 128,\n    sfreq = 500,\n    n_splines = (4, 4),\n    n_repeats = 500,","category":"page"},{"location":"references/benchmarks/","page":"Solver benchmarks","title":"Solver benchmarks","text":"gpu method el_type time GB percent_X_filled sizeDesign n_channels overlap comment\ntrue cholesky Float64   0.0015 (3001479, 9616) 128 (0.2, 0.2) PosDefException(-1)\nfalse cholesky Float64   0.0015 (3001479, 9616) 128 (0.2, 0.2) PosDefException(2760)\nfalse intern Float64   0.0015 (3001479, 9616) 128 (0.2, 0.2) SingularException(9599)\ntrue cg Float64 9.3 3.6 0.0015 (3001479, 9616) 128 (0.2, 0.2) \ntrue qr Float64 11.0 3.5 0.0015 (3001479, 9616) 128 (0.2, 0.2) \ntrue intern Float64 13.0 3.5 0.0015 (3001479, 9616) 128 (0.2, 0.2) \nfalse qr Float64 80.0 6.3 0.0015 (3001479, 9616) 128 (0.2, 0.2) \ntrue pinv Float64 80.0 4.2 0.0015 (3001479, 9616) 128 (0.2, 0.2) \ntrue krylov_gpu Float64 107.0 3.9 0.0015 (3001479, 9616) 128 (0.2, 0.2) \nfalse default_multi Float64 500.0 15.0 0.0015 (3001479, 9616) 128 (0.2, 0.2) \nfalse pinv Float64 520.0 11.0 0.0015 (3001479, 9616) 128 (0.2, 0.2) \nfalse cg Float64 939.0 5.7 0.0015 (3001479, 9616) 128 (0.2, 0.2) ","category":"page"},{"location":"#Unfold-Documentation","page":"Unfold Documentation","title":"Unfold Documentation","text":"","category":"section"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"If you want to follow the tutorials, best to start with the mass-univariate approach, which should be familiar to you if you did ERPs before. Then the overlap-correction tutorial, mixed mass univariate, mixed overlap (tricky!). If you are then not satisfied, check out more advanced topics: effects-interface (aka what to do after fitting), or non-linear effects.","category":"page"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"In case you want to understand the tools better, check out our explanations.","category":"page"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"Once you are familiar with the tools, check out further how-to guides for specific applications.","category":"page"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"In case you want to understand the toolbox better, we plan to offer technical references. This includes Benchmarks & Explorations.","category":"page"},{"location":"#Quick-start","page":"Unfold Documentation","title":"Quick start","text":"","category":"section"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"There are four main model types","category":"page"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"Timeexpansion No, Mixed No  : fit(UnfoldModel, [Any=>(f, -0.1:0.01:0.5)], evts, data_epoch)\nTimeexpansion Yes, Mixed No : fit(UnfoldModel, [Any=>(f, basisfunction)], evts, data)\nTimeexpansion No, Mixed Yes : fit(UnfoldModel, [Any=>(fLMM, -0.1:0.01:0.5)], evts, data_epoch)\nTimeexpansion Yes, Mixed Yes: fit(UnfoldModel, [Any=>(fLMM, basisfunction)], evts, data)","category":"page"},{"location":"","page":"Unfold Documentation","title":"Unfold Documentation","text":"f = @formula 0 ~ 1 + condition\nfLMM = @formula 0 ~ 1 + condition + (1|subject) + (1|item)\nbasisfunction = firbasis(τ = (-0.1,0.5), sfreq = 100))","category":"page"}]
}
